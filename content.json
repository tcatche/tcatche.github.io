{"meta":{"title":"TryCatch","subtitle":"To try, then catch.","description":null,"author":"tcatche","url":"http://tcatche.site","root":"/"},"pages":[],"posts":[{"title":"Canvas 实例之绘制时钟","slug":"canvas_example_clock","date":"2021-08-19T08:00:00.000Z","updated":"2021-08-20T05:39:03.483Z","comments":true,"path":"2021/08/canvas_example_clock/","link":"","permalink":"http://tcatche.site/2021/08/canvas_example_clock/","excerpt":"","text":"这里总结下使用 canvas 绘制时钟的步骤。 下面来拆分一下绘制步骤： 绘制时钟的表框和刻度； 绘制时钟的指针； 使用定时器动态更新时间。 根据以上步骤可以写出绘制的主要代码： draw() &#123; const drawClock = () =&gt; &#123; this.ctx.clearRect(-150, -150, 300, 300); // 清除画布 this.drawCircle(); // 绘制时钟的表框 this.drawCalibration(); // 绘制时钟的刻度 this.drawPoints(); // 绘制时钟的指针 window.requestAnimationFrame(drawClock); &#125; window.requestAnimationFrame(drawClock); // 添加定时器&#125; 核心语法涉及到的核心语法主要有以下几个： ctx.translate 更改 canvas 的原点，本例设置为多边形的中心点。 ctx.rotate 旋转 casvas，本例通过旋转每次只需要绘制固定坐标 [width, 0] 可以有效降低计算坐标的复杂度； ctx.save 保存 canvas 全部状态，由于每次绘制都会进行旋转，每次绘制前保存状态，避免多次旋转后角度错乱导致错位； ctx.restore 还原上次保存的状态，每次绘制结束后进行还原； ctx.beginPath/ctx.closePath 用来关闭路径，避免不同的路径进行交叉； ctx.moveTo/ctx.lineTo 用来绘制一段直线。 下面看一下各个步骤的绘制过程： 绘制圆框绘制圆用到的方法为 ctx.arc 。 drawCircle() &#123; const &#123; ctx &#125; = this; ctx.save(); ctx.beginPath(); ctx.arc(0, 0, 100, 0, 2 * Math.PI); // 绘制圆形，半径为100，度数为360度 ctx.lineWidth = 5; // 设置线的宽度 ctx.strokeStyle = &#x27;#00B0F0&#x27;; ctx.closePath(); ctx.stroke(); ctx.restore();&#125; 其中 ctx.lineWidth 用来设定线的宽度。 注意，在绘制图形前后使用 ctx.beginPath，ctx.closePath，避免下次绘制图形时出现连线链接上次绘制的图形。 绘制刻度经过观察，时钟共计12个代表小时的刻度，它们之间又平均分布着4个表示分钟的刻度，出现很有规律，很容易写出如下代码： drawCalibration() &#123; const &#123; ctx &#125; = this; ctx.save(); const rotateStep = Math.PI * 2 / 60; // 共计60个刻度，计算每次绘制需要旋转的弧度 for (let i = 0; i &lt; 60; i ++) &#123; ctx.beginPath() if (i % 5 === 0) &#123; // 此次轮到“小时”的刻度 ctx.moveTo(0, -80); ctx.strokeStyle = &#x27;#00B0F0&#x27;; ctx.lineWidth = 3; &#125; else &#123; // 此次绘制“分钟”的刻度 ctx.moveTo(0, -85); ctx.strokeStyle = &#x27;#000&#x27;; ctx.lineWidth = 1; &#125; ctx.lineTo(0, -90)； ctx.closePath()； ctx.stroke()； ctx.rotate(rotateStep)； &#125; ctx.restore();&#125; 绘制时钟指针这里的要点是计算每个指针需要旋转的角度： 秒针很容易计算，旋转的角度等于 秒数 / 60。同样的，分针旋转角度等于 分钟数 / 60 ，但为了过度平滑，每一秒的变化都应该导致分钟的角度变化，最终可以计算出分钟平滑的旋转角度为 分钟数 / 60 + 秒针角度 / 60。同样的，时针也是如此，可以写出如下的代码： drawPoints() &#123; const now = new Date(); let hour = now.getHours() % 12; let minute = now.getMinutes(); let second = now.getSeconds(); // 计算指针旋转角度 const secondRotate = second * (2 * Math.PI / 60); const minuteRotate = minute * (2 * Math.PI / 60) + secondRotate / 60; const hourRotate = hour * (2 * Math.PI / 12) + minuteRotate / 12; // 绘制指针 this.drawHourPoint(hourRotate, hour); this.drawMinutePoint(minuteRotate, minute); this.drawSecondPoint(secondRotate, second);&#125; 时钟指针有三个，只要计算出旋转的角度，它们的绘制方法和刻度很类似，可以很容易写出以下代码： // 绘制小时的指针drawHourPoint(rotate, hour) &#123; const &#123; ctx &#125; = this; ctx.save(); ctx.rotate(rotate); ctx.beginPath(); ctx.moveTo(0, 10); ctx.lineTo(0, -30); ctx.closePath(); ctx.strokeStyle = &#x27;#00B0F0&#x27;; ctx.lineWidth = 8; ctx.stroke(); ctx.restore();&#125;// 绘制分钟的指针drawMinutePoint(rotate, minute) &#123; const &#123; ctx &#125; = this; ctx.save(); ctx.rotate(rotate); ctx.beginPath(); ctx.moveTo(0, 10); ctx.lineTo(0, -50); ctx.closePath(); ctx.strokeStyle = &#x27;#00B0F0&#x27;; ctx.lineWidth = 4; ctx.stroke(); ctx.restore();&#125;// 绘制秒的指针drawSecondPoint(rotate, minute) &#123; const &#123; ctx &#125; = this; ctx.save(); ctx.rotate(rotate); // 绘制个小圆圈作为装饰 ctx.beginPath(); ctx.arc(0, 0, 5, 0, 2 * Math.PI); ctx.closePath(); ctx.fillStyle = &#x27;red&#x27;; ctx.fill(); // 绘制指针 ctx.beginPath(); ctx.moveTo(0, 10); ctx.lineTo(0, -70); ctx.closePath(); ctx.strokeStyle = &#x27;red&#x27;; ctx.lineWidth = 1; ctx.stroke(); ctx.restore();&#125; 使用定时器动态更新时间这里使用 requestAnimationFrame 而不是使用 setInterval, setInterval 的时效性无法保证。 具体代码 draw() &#123; const drawClock = () =&gt; &#123; this.ctx.clearRect(-150, -150, 300, 300); // 清除画布 this.drawCircle(); // 绘制时钟的表框 this.drawCalibration(); // 绘制时钟的刻度 this.drawPoints(); // 绘制时钟的指针 window.requestAnimationFrame(drawClock); &#125; window.requestAnimationFrame(drawClock); // 添加定时器&#125; 注意，每次绘制前使用 ctx.save() 保存当前状态，绘制完成后使用 ctx.restore() 恢复保存的状态，这样可以避免绘制几次后找不到初始的状态。上面的每个绘制都是如此操作的。 完整代码和演示点击查看完整代码 演示： See the Pen by tcatche (@tcatche) on CodePen.","categories":[{"name":"js","slug":"js","permalink":"http://tcatche.site/categories/js/"}],"tags":[{"name":"canvas","slug":"canvas","permalink":"http://tcatche.site/tags/canvas/"}]},{"title":"Canvas 实例之绘制雷达图（蛛网图）","slug":"canvas_example_rader","date":"2021-08-10T01:40:00.000Z","updated":"2021-08-20T05:36:40.380Z","comments":true,"path":"2021/08/canvas_example_rader/","link":"","permalink":"http://tcatche.site/2021/08/canvas_example_rader/","excerpt":"","text":"之前在开发中需要用到雷达图（蛛网图），这里总结下使用 canvas 绘制雷达图的步骤。 对于雷达图这种中心对称的图形，绘制的要点就是找到圆心的位置，设为中心点，然后边旋转边绘制。 演示： See the Pen canvas draw radar by tcatche (@tcatche) on CodePen. 下面来拆分一下绘制步骤： 接口定义首先先定义接口和使用： class Rader &#123; draw() &#123; this.drawGrid(); // 绘制网格 this.drawLines(); // 绘制链接网格的线 this.drawData(); // 绘制数据组成的多边形 this.drawText(); // 绘制标签 &#125;&#125;// 使用方式new Rader(&#123; ele: document.getElementById(&#x27;canvas&#x27;), radius: 100, // 绘制半径 gridTurns: 5, // 蛛网的圈数 data: [ // 根据 data 长度决定绘制几边形 &#123; label: &#x27;速度&#x27;, value: 60, &#125;, &#123; label: &#x27;力量&#x27;, value: 50, &#125;, &#123; label: &#x27;爆发力&#x27;, value: 70, &#125;, &#123; label: &#x27;耐久力&#x27;, value: 60, &#125;, &#123; label: &#x27;强度&#x27;, value: 80, &#125;, &#123; label: &#x27;气势&#x27;, value: 10, &#125;, ]&#125;).draw(); 核心语法涉及到的核心语法主要有以下几个： ctx.translate 更改 canvas 的原点，本例设置为多边形的中心点。 ctx.rotate 旋转 casvas，本例通过旋转每次只需要绘制固定坐标 [width, 0] 可以有效降低计算坐标的复杂度； ctx.save 保存 canvas 全部状态，由于每次绘制都会进行旋转，每次绘制前保存状态，避免多次旋转后角度错乱导致错位； ctx.restore 还原上次保存的状态，每次绘制结束后进行还原； ctx.beginPath/ctx.closePath 用来关闭路径，避免不同的路径进行交叉； ctx.moveTo/ctx.lineTo 用来绘制一段直线。 初始化constructor(options) &#123; this.options = options; this.ctx = options.ele.getContext(&#x27;2d&#x27;); this.ctx.translate(options.ele.width / 2, options.ele.height / 2); // 指定绘制的原点为 canvas 的中心 this.edgesCount = options.data.length; // 几边形由数据的长度确定 this.rotateStep = (2 * Math.PI) / this.edgesCount; // 每次旋转的度数，注意是弧度单位而不是角度。&#125; 上面初始化主要指定了绘制的原点，方便计算每个要绘制的点，以及每次需要旋转的弧度。 下面开始具体图案的绘制，其实每次绘制都很类似。 绘制背景网格 具体代码 drawGrid() &#123; const &#123; options, ctx, edgesCount, rotateStep &#125; = this; ctx.save(); ctx.beginPath(); for (let i = 0; i &lt; options.gridTurns; i += 1) &#123; // 根据网格的圈数进行循环 const DRAW_RADIUS = ((i + 1) * options.radius) / options.gridTurns; // 计算每一圈网格的半径 ctx.moveTo(DRAW_RADIUS, 0); for (let j = 0; j &lt; edgesCount; j += 1) &#123; // 每一圈网格都是一个绘制小多边形的步骤 ctx.rotate(rotateStep); ctx.lineTo(DRAW_RADIUS, 0); &#125; &#125; ctx.closePath(); ctx.stroke(); ctx.restore();&#125; 绘制网格连接的线 具体代码 drawLines() &#123; const &#123; options, ctx, edgesCount, rotateStep &#125; = this; ctx.save(); ctx.beginPath(); for (let i = 0; i &lt; edgesCount; i += 1) &#123; ctx.rotate(rotateStep); ctx.moveTo(0, 0); ctx.lineTo(options.radius, 0); &#125; ctx.closePath(); ctx.stroke(); ctx.restore();&#125; 绘制数据 具体代码 drawData() &#123; const &#123; options, ctx, edgesCount, rotateStep &#125; = this; ctx.save(); const data = options.data.map((item) =&gt; Math.round(item.value * options.radius / 100)); // 根绝数据的百分比确定数据的绘制长度 ctx.beginPath(); ctx.moveTo(data[0], 0); for (let i = 1; i &lt; edgesCount; i += 1) &#123; ctx.rotate(rotateStep); ctx.lineTo(data[i], 0); &#125; ctx.rotate(this.rotateStep); ctx.lineTo(data[0], 0); ctx.fillStyle = &#x27;rgba(255, 0, 0, 0.3)&#x27;; ctx.fill(); ctx.closePath(); ctx.restore();&#125; 绘制标签 具体代码： drawText() &#123; const &#123; options, ctx, edgesCount, rotateStep &#125; = this; ctx.save(); const data = options.data.map((item) =&gt; item.label); ctx.font = &#x27;12px&#x27;; ctx.textBaseline = &#x27;middle&#x27;; ctx.textAlign = &#x27;center&#x27; const textRadius = options.radius + 20; for (let i = 0; i &lt; edgesCount; i += 1) &#123; const currentAngle = rotateStep * i; ctx.fillText(data[i], textRadius * Math.cos(currentAngle), textRadius * Math.sin(currentAngle)); &#125; ctx.restore(); &#125;&#125; 绘制标签的难点是需要计算标签的文本的坐标，这里用到正弦和余弦函数 x = cos(deg) * r, y = sin(deg) * r 注意，每次绘制前使用 ctx.save() 保存当前状态，绘制完成后使用 ctx.restore() 恢复保存的状态，这样可以避免绘制几次后找不到初始的状态。上面的每个绘制都是如此操作的。 完整代码和演示点击查看完整代码 演示： See the Pen canvas draw radar by tcatche (@tcatche) on CodePen.","categories":[{"name":"js","slug":"js","permalink":"http://tcatche.site/categories/js/"}],"tags":[{"name":"canvas","slug":"canvas","permalink":"http://tcatche.site/tags/canvas/"}]},{"title":"Git switch - 切换分支","slug":"git_switch","date":"2021-06-22T08:06:00.000Z","updated":"2021-07-14T08:14:46.613Z","comments":true,"path":"2021/06/git_switch/","link":"","permalink":"http://tcatche.site/2021/06/git_switch/","excerpt":"","text":"在开发中，通常会使用 git checkout 进行分支切换和变更撤销，checkout 是一个比较复杂的命令，承载了很多功能有点臃肿，因此引入了两个新的命令 git switch 和 git restore 用来拆分 git checkout 命令，本文介绍如何使用 git switch 进行分支切换。 使用这个命令比较简单，下面简单列一下各种使用方式，就不详细介绍了 切换分支git switch &lt;branch&gt; 创建并切换分支git switch -c &lt;branch&gt; 从指定的位置创建分支git switch -c &lt;branch&gt; &lt;start-point&gt; 切换回前一个分支git switch - 和 git checkout 对比git switch 是 git checkout 功能的一部分，因此这里列出了两个命令关于分支操作的对比： 命令 switch checkout 切换分支 git switch &lt;branch&gt; git checkout &lt;branch&gt; 新建并切换到新分支 git switch -c &lt;branch&gt; git checkout -b &lt;branch&gt; 从指定位置新建分支 git switch -c &lt;branch&gt; &lt;start-point&gt; git checkout -b &lt;branch&gt; &lt;start-point&gt; 切换到指定的 commitId git switch --detach &lt;commitId&gt; git checkout &lt;commitId&gt; 参考 git scm","categories":[{"name":"其它","slug":"其它","permalink":"http://tcatche.site/categories/%E5%85%B6%E5%AE%83/"}],"tags":[{"name":"git","slug":"git","permalink":"http://tcatche.site/tags/git/"}]},{"title":"Git restore - 撤销操作","slug":"git_restore","date":"2021-06-02T06:54:00.000Z","updated":"2021-06-22T08:02:51.369Z","comments":true,"path":"2021/06/git_restore/","link":"","permalink":"http://tcatche.site/2021/06/git_restore/","excerpt":"","text":"在开发中，通常会使用 git checkout 进行分支切换和变更撤销，checkout 是一个比较复杂的命令，承载了很多功能有点臃肿，因此引入了两个新的命令 git switch 和 git restore 用来拆分 git checkout 命令，本文介绍如何使用 git restore 进行变更撤销。 介绍git restore 命令会将指定文件的变更给撤销，先来看下面的示例： 在 git 仓库里有三个文件变更 restore.md、restore2.md、restore3.md，restore.md 的变更已经通过 git add 加入暂存区，restore2.md 变更未加入暂存区，restore3.md 是新建的文件还未被 git 追踪： $ git status On branch restore Changes to be committed: (use &quot;git restore --staged &lt;file&gt;...&quot; to unstage) modified: restore.md Changes not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git restore &lt;file&gt;...&quot; to discard changes in working directory) modified: restore2.md Untracked files: (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed) restore3.md 通过 git status 可以看到很明显的提示，对于已经加入暂存区的变更（上面的restore.md），可以通过 git restore --staged &lt;file&gt;... 进行撤销变更，对于未加入暂存区的文件变更（上面的restore2.md） git restore &lt;file&gt;... ，对于未追踪的文件，没有 git 操作提示，直接删除即可。 分别进行上面说的操作来看看： $ git restore --staged restore.md$ git restore restore2.md$ rm restore.md$ git status On branch restore nothing to commit, working tree clean 可以看到工作区的所有变更已经被撤销。 默认情况下，它们都是回滚到最新的提交状态，如果需要回滚到指定提交的内容，可以使用 --source=&lt;tree&gt;： 首先来创造一个变更的提交： $ cat restore.md test retore.$ echo test retore2 &gt; restore.md$ cat restore.md test retore2 回滚内容到历史最开始的状态： $ git log --oneline 50980a7 (HEAD -&gt; restore) init$ git restore --source=50980a7 --worktree restore.md$ cat restore.md test retore. 上面的是操作都是针对没有提交的情况，如果某个变更已经被提交了，也可以使用 git restore --source=&lt;tree&gt; &lt;pathspec&gt;…​ 进行内容回滚： $ git log --oneline 7dc813a (HEAD -&gt; restore) test2 # test restore2 50980a7 init # test restore$ cat restore.md test retore2$ git restore -s 50980a7 restore.md$ cat restore.md test retore 注意，这个回滚只是内容回滚，相当于把上次内容写到文件里，仍然需要重新提交才能应用，而且错误的提交依然存在： $ git log --oneline 7dc813a (HEAD -&gt; restore) error 50980a7 init$ git status On branch restore Changes not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git restore &lt;file&gt;...&quot; to discard changes in working directory) modified: restore.md no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;) 总结这里对它们使用做个总结： git restore --staged &lt;file&gt;...：撤销已经加入暂存区的变更； git restore [--worktree|-w] &lt;file&gt;...：撤销未加入暂存区的变更； git restore [--source|-s] tree &lt;file&gt;...：回退到指定的提交历史。 参考 git-scm restore","categories":[{"name":"其它","slug":"其它","permalink":"http://tcatche.site/categories/%E5%85%B6%E5%AE%83/"}],"tags":[{"name":"git","slug":"git","permalink":"http://tcatche.site/tags/git/"}]},{"title":"Git reflog - 介绍","slug":"git_reflog","date":"2021-05-27T02:05:00.000Z","updated":"2021-06-22T07:22:31.630Z","comments":true,"path":"2021/05/git_reflog/","link":"","permalink":"http://tcatche.site/2021/05/git_reflog/","excerpt":"","text":"在开发中，有时候需要紧急退回某个线上版本修复问题，特别是 reset 操作回滚之前的版本，如果操作不注意会发现新的一些工作的提交历史丢失了，这个时候 git reflog 会很有帮助。 git reflog 和 git log 功能很相近，都是记录日志的，和 git log 不同在于 git reflog 记录了 HEAD 指针的变更历史。 介绍首先使用准备好的分支来看一下： $ git log --oneline aea03a0 (HEAD -&gt; reflog) version5 1abb498 version4 97697e6 version3 d421d76 version2 b5ba58e version1$ git reflog aea03a0 (HEAD -&gt; reflog) HEAD@&#123;0&#125;: commit: version5 1abb498 HEAD@&#123;1&#125;: commit: version4 97697e6 HEAD@&#123;2&#125;: commit: version3 d421d76 HEAD@&#123;3&#125;: commit: version2 b5ba58e HEAD@&#123;4&#125;: commit (initial): version1 其中 git reflog 比 git log 多了一些信息： HEAD@&#123;n&#125;: 表示 HEAD 指针在第 n 次操作前的位置； commit: 表示这一次的操作，可能会有其他取值，比如 merge、fetch、reset、rebase 等。 来使用 git reset 回滚一下看看： $ git reset --hard 1abb498 HEAD is now at 1abb498 version4$ git log --oneline 1abb498 (HEAD -&gt; reflog) version4 97697e6 version3 d421d76 version2 b5ba58e version1$ git reflog 1abb498 (HEAD -&gt; reflog) HEAD@&#123;0&#125;: reset: moving to 1abb498 aea03a0 HEAD@&#123;1&#125;: commit: version5 1abb498 (HEAD -&gt; reflog) HEAD@&#123;2&#125;: commit: version4 97697e6 HEAD@&#123;3&#125;: commit: version3 d421d76 HEAD@&#123;4&#125;: commit: version2 b5ba58e HEAD@&#123;5&#125;: commit (initial): version1 可以看出，此时 git log 已经找不到之前保存的最新的提交 aea03a0 version5，而 其变更仍然保存在 git reflog 中。 这个时候时候如果想要找回这个丢失的提交就可以重新使用 reset 或者 cherry-pick 等操作： $ git reset --hard aea03a0# 或者$ git reset --hard HEAD@&#123;0&#125; HEAD is now at aea03a0 version5$ git log --oneline aea03a0 (HEAD -&gt; reflog) version5 1abb498 version4 97697e6 version3 d421d76 version2 b5ba58e verson1$ git reflog aea03a0 (HEAD -&gt; reflog) HEAD@&#123;0&#125;: reset: moving to aea03a0 1abb498 HEAD@&#123;1&#125;: reset: moving to 1abb498 aea03a0 (HEAD -&gt; reflog) HEAD@&#123;2&#125;: commit: version5 1abb498 HEAD@&#123;3&#125;: commit: version4 97697e6 HEAD@&#123;4&#125;: commit: version3 d421d76 HEAD@&#123;5&#125;: commit: version2 b5ba58e HEAD@&#123;6&#125;: commit (initial): verson1 当然 reflog 仍然会记录找回的这个过程。 其它命令其他命令基本不常使用，这里只做简单介绍，感兴趣可以去查看 git 文档 git reflog [show] [log-options] [] show 可以省略，等价于 git reflog； 支持增加其他 git log 命令的选项； ref 为需要查看的引用，可以省略，默认为展示全部的 HEAD， 下面为查看某个分支的 HEAD 变更记录： $ git reflog test 8d7244a (test) test@&#123;0&#125;: pull: Fast-forward 34beecc test@&#123;1&#125;: pull: Fast-forward a1ed01a test@&#123;2&#125;: pull: Fast-forward 20bbab4 test@&#123;3&#125;: pull: Fast-forward a8fd248 test@&#123;4&#125;: branch: Created from refs/remotes/origin/test git reflog expire删除旧的 reflog 记录。如果指定了过期时间则从 reflog 中删除超过过期时间的记录。 git reflog delete 从 reflog 中删除一条记录。 $ git reflog delete HEAD@&#123;n&#125; git reflog exists 检查一个引用是否有 reflog。 参考 git-scm reflog","categories":[{"name":"其它","slug":"其它","permalink":"http://tcatche.site/categories/%E5%85%B6%E5%AE%83/"}],"tags":[{"name":"git","slug":"git","permalink":"http://tcatche.site/tags/git/"}]},{"title":"Git revert - 回滚操作","slug":"git_revert","date":"2021-05-26T06:09:00.000Z","updated":"2021-05-26T06:10:01.672Z","comments":true,"path":"2021/05/git_revert/","link":"","permalink":"http://tcatche.site/2021/05/git_revert/","excerpt":"","text":"在开发过程中，有些时候会出现一些错误的提交，这个时候可以用 git revert 命令把这些错误的提交给回滚了。 介绍git revert 命令用来将指定的 commit 回滚。 回滚原理是通过新建一个指定的提交的反操作的提交。 下面以上面的例子介绍 revert 的使用，假设当前的分支状态如下图所示： featureA - featureB - featureC - featureD 想要在主分支应用 featureC 特性，可以进行如下的操作： $ git revert featureC 现在的分支状态变成了下面的结构： featureA - featureB - featureC - featureD - revertedFeatureC 示例结合一个示例来看上面的过程，下面是一个已经准备好的分支： $ git log --oneline a38fcc8 featureD 7eb26bc featureC 92a0733 featureB edd842a featureA 首先来查看 featureC 做了哪些改动： $ git show 7eb26bc diff --git a/featureC.md b/featureC.md new file mode 100644 index 0000000..7eb26bc --- /dev/null +++ b/featureC.md @@ -0,0 +1 @@ +&#x27;featureC&#x27; 从上面可以看出来 featureC 增加了 featureC.md 文件，此时尝试 revert featureC： $ git revert 7eb26bc [revert 7eb26bc] Revert &quot;featureC&quot; 1 file changed, 1 deletion(-) delete mode 100644 featureC.md$ git log --oneline a8be289 (HEAD -&gt; revert) Revert &quot;featureC&quot; a38fcc8 featureD 7eb26bc featureC 92a0733 featureB edd842a featureA 可以看出多了一个新的提交 a8be289: Revert &quot;featureC&quot; ，来看一下这个提交做了什么事情： $ git show a8be289 diff --git a/featureC.md b/featureC.md deleted file mode 100644 index 9d69d61..0000000 --- a/featureC.md +++ /dev/null @@ -1 +0,0 @@ -&#x27;featureC&#x27; 可以看出来，这个提交的内容刚好是和 featureC 相反，删了了 featureC.md 文件。 下面详细来看一下 git revert 的各种命令： 使用语法： git revert .. 可以 revert 一个或多个提交。 git revert commitHashA..commitHashB可以 revert 从 commitHashA 到 commitHashB 之间的所有提交，其中不包含 commitHashA ，包含 commitHashB。 git revert commitHashA^..commitHashB同上面类似，区别在于包含 commitHashA 的提交： 几个有用的参数-e 或 –edit允许你在 revert 之前编辑提交消息。 -m 或 –mainline 如果提交的是一个合并分支的提交，这个操作会失败，因为 revert 不知道选择那边的改动。 这个参数的作用就是告诉 revert 采用哪边的改动，通常不建议 revert 合并分支的提交。 -n 或 –no-commit只应用 revert 的内容变更，但不会产生新的提交，即需要自己手动进行 git commit 的过程。 冲突处理git revert (--continue | --skip | --abort | --quit) 在 revert 过程中，有时候会有代码的冲突，这时 revert 的操作会暂停，可以选择如下操作： git revert –continue在解决冲突后，可以使用 git revert --continue 继续后面的 revert 过程。 git revert –skip跳过当前的 commit，继续后续的 revert 过程。 git revert –abort放弃 revert，回到 revert 之前的状态。 git revert –quit停止 revert，不回到 revert 之前的状态，保留现状。 参考 git-revert","categories":[{"name":"其它","slug":"其它","permalink":"http://tcatche.site/categories/%E5%85%B6%E5%AE%83/"}],"tags":[{"name":"git","slug":"git","permalink":"http://tcatche.site/tags/git/"}]},{"title":"如何取消 Web 请求","slug":"cancel_request","date":"2021-05-14T07:00:00.000Z","updated":"2021-05-14T07:29:41.247Z","comments":true,"path":"2021/05/cancel_request/","link":"","permalink":"http://tcatche.site/2021/05/cancel_request/","excerpt":"","text":"在有些场景下可能需要用到取消请求的操作，比如在同一时刻触发多次请求，只保留最新的请求；比如表单提交中关闭页面等行为，本文加少一些常用的触发 Web 请求的方式如何取消。 AbortControllorAbortController 接口表示一个控制器对象，该对象允许您在需要时中止一个或多个 Web 请求。 AbortController 分别有一个属性 AbortController.signal 和一个方法 AbortController.abort，他们结合起来可以用来终止 Web 请求。 它的使用过程如下： 首先创建一个 AbortController 对象 controller，然后在调用 fetch 时，传入 controller.signal 作为选项，此时控制器和请求被关联在一起，使用控制器的 controller.abort 方法，即刻终止此请求。 const controller = new AbortController();function download() &#123; return fetch(url, &#123; signal: controller.signal &#125;);&#125;function abort() &#123; controller.abort();&#125; 注意，当 controller.abort 被调用时， fetch 返回的 promise 会进入 reject 状态并返回一个名为 AbortError 的 DOMException。 AbortController.signal 搭配 AbortController.abort 还可以用来响应一些取消类的行为： const controller = new AbortController();controller.signal.addEventListener(&#x27;abort&#x27;, (err) =&gt; &#123; console.log(&#x27;aborted!&#x27;);&#125;);controller.abort();// 输出aborted! 注意，AbortControllor 只对浏览器原生的 fetch 生效，在日常开发中经常使用其它的工具如 axios，下一节看一下 axios 怎么取消。 axios 请求取消axios 提供了 cancelToken 配置项可以用来取消其请求，其使用和 AbortControllor 很相似，看下面的例子： const cancelToken = axios.CancelToken;const source = cancelToken.source();axios.get(&#x27;/user/12345&#x27;, &#123; cancelToken: source.token&#125;).catch(function (thrown) &#123; if (axios.isCancel(thrown)) &#123; console.log(&#x27;Request canceled&#x27;, thrown.message); &#125; else &#123; // handle error &#125;&#125;);// cancel the request (the message parameter is optional)source.cancel(); 也可以给 CancelToken 传入一个执行器来执行： const CancelToken = axios.CancelToken;let cancel;axios.get(&#x27;/user/12345&#x27;, &#123; cancelToken: new CancelToken(function executor(c) &#123; // An executor function receives a cancel function as a parameter cancel = c; &#125;)&#125;);// cancel the requestcancel(); 都写到这里了，顺便看看 axios 内部是怎么实现取消的： 首先看 cancelToken 相关的代码： // lib/adapters/xhr.jsif (config.cancelToken) &#123; // Handle cancellation config.cancelToken.promise.then(function onCanceled(cancel) &#123; if (!request) &#123; return; &#125; request.abort(); reject(cancel); // Clean up request request = null; &#125;);&#125; 可以看到当 cancelToken.promise 调用 resolve 时进行了取消，结合它的使用不难猜测 cancelToken.source().cancel 和 传入 CancelToken 的 executor 返回给用户的方法一定用来是 resolve cancelToken.promise 的，接着找相关代码： // lib/cancel/CancelToken.jsCancelToken.source = function source() &#123; var cancel; var token = new CancelToken(function executor(c) &#123; cancel = c; &#125;); return &#123; token: token, cancel: cancel &#125;;&#125;; 从上面看出 axios 的第一个示例 cancelToken.source 方法就是是调用了 CancelToken 构造器，也就是上面 axios 示例的第二种写法，后面就没必要看了，继续找构造器相关的代码就知道做了什么： // lib/cancel/CancelToken.jsfunction CancelToken(executor) &#123; if (typeof executor !== &#x27;function&#x27;) &#123; throw new TypeError(&#x27;executor must be a function.&#x27;); &#125; var resolvePromise; this.promise = new Promise(function promiseExecutor(resolve) &#123; resolvePromise = resolve; &#125;); var token = this; executor(function cancel(message) &#123; if (token.reason) &#123; // Cancellation has already been requested return; &#125; token.reason = new Cancel(message); resolvePromise(token.reason); &#125;);&#125; 很明显可以看出 this.promise 就是 config.cancelToken.promise.then，而 executor 就是 new CancelToken 时传入的方法，最终暴露给外面了 function cancel 这个方法，而这个方法就是用来 config.cancelToken.promise，和前面的猜测一致，不在多说。 同样的，使用同一个 cancelToken 也可以取消多个请求。 中止 PromisePromise 也可以手动中止，只需要在创建 Promise 时，对外暴露 reject： let abort;let p = new Promise((resovle, reject) =&gt; &#123; abort = err =&gt; reject(err); // do sth;&#125;);abort(); XHR 请求取消XHR 原生提供了 abort 方法，可以直接取消： let xhr = new XMLHttpRequest();xhr.onerror = (err) =&gt; console.log(err);xhr.onabort = () =&gt; console.log(&#x27;aborted!&#x27;);xhr.open(&#x27;get&#x27;, &#x27;http://baidu.com&#x27;);xhr.send();setTimeout(() =&gt; &#123; xhr.abort();&#125;, 100); 注意，和其他不同的是，xhr 取消不会触发 error 事件，而是触发 abort 事件。 参考 can i use MDN axios cancellation","categories":[{"name":"js","slug":"js","permalink":"http://tcatche.site/categories/js/"}],"tags":[{"name":"promise","slug":"promise","permalink":"http://tcatche.site/tags/promise/"}]},{"title":"Git cherry-pick 操作","slug":"git_cherry_pick","date":"2021-05-11T07:42:00.000Z","updated":"2021-05-12T07:43:02.036Z","comments":true,"path":"2021/05/git_cherry_pick/","link":"","permalink":"http://tcatche.site/2021/05/git_cherry_pick/","excerpt":"","text":"在开发过程中，切换分支和合并代码是常用的操作，想想一种场景，在一个分支上进行了新版本开发，开发了若干新特性 featureD、featureE 等等，但是需要变更，这个开发被搁置了，但是又想引入新的 featureD 特性，这个时候 cherry-pick 就是一个很有用的操作了。 介绍git cherry-pick 命令用来将指定的 commit 应用到其它的分支。 下面以上面的例子介绍 cherry-pick 的使用，假设当前的分支状态如下图所示： a - b #Main \\ D - E #Feature 想要在主分支应用 featureD 特性，可以进行如下的操作： $ git checkout main$ git cherry-pick D 现在的分支状态变成了下面的结构： a - b - D #Main \\ C - D - E #Feature 使用语法： git cherry-pick .. 可以 cherry-pick 一个或多个提交。 git cherry-pick commitHashA..commitHashB可以 cherry-pick 从 commitHashA 到 commitHashB 之间的所有提交，其中不包含 commitHashA ，包含 commitHashB。 如： # beforea - b #Main \\ C - D - E - F #Feature# 执行$ git cherry-pick D..F# aftera - b - E - F #Main \\ C - D - E - F #Feature git cherry-pick commitHashA^..commitHashB同上面类似，区别在于包含 commitHashA 的提交： # beforea - b #Main \\ C - D - E - F #Feature# 执行$ git cherry-pick D..F# aftera - b - D - E - F #Main \\ C - D - E - F #Feature git cherry-pick 可以将 &lt;branchName&gt; 上的最新提交 cherry-pick 到当前分支 几个有用的参数-e 或 –edit允许你在提交之前编辑提交消息。 -x在原来的提交信息里追加一行 cherry picked from commit … 信息。 -m 或 –mainline 如果提交的是一个合并分支的提交，这个操作会失败，因为 cherry-pick 不知道选择那边的改动。 这个参数的作用就是告诉 cherry-pick 采用哪边的改动，通常不建议 cherry-pick 合并分支的提交。 -n 或 –no-commit只应用指定提交的内容变更，但不会产生新的提交，即需要自己手动进行 git commit 的过程。 冲突处理git cherry-pick (--continue | --skip | --abort | --quit) 在 cherry-pick 过程中，有时候会有代码的冲突，这时 cherry-pick 的操作会暂停，可以选择如下操作： git cherry-pick –continue在解决冲突后，可以使用 git cherry-pick --continue 继续后面的 cherry-pick 过程。 git cherry-pick –skip跳过当前的 commit，继续后续的 cherry-pick 过程。 git cherry-pick –abort放弃 cherry-pick，回到 cherry-pick 之前的状态。 git cherry-pick –quit停止 cherry-pick，不回到 cherry-pick 之前的状态，保留现状。 参考 git-scm","categories":[{"name":"其它","slug":"其它","permalink":"http://tcatche.site/categories/%E5%85%B6%E5%AE%83/"}],"tags":[{"name":"git","slug":"git","permalink":"http://tcatche.site/tags/git/"}]},{"title":"Git stash - 暂存操作","slug":"git_stash","date":"2021-05-11T07:04:00.000Z","updated":"2021-05-26T05:49:31.967Z","comments":true,"path":"2021/05/git_stash/","link":"","permalink":"http://tcatche.site/2021/05/git_stash/","excerpt":"","text":"当正在进行某项开发任务过程中，突然有另一件紧急的事情需要处理，比如有线上问题，这个时候，当前代码并没有开发完成不想提交， git stash 命令就是一个解决此问题的方法。 stash 命令可以把当前未提交的内容给暂存起来，还原到上次提交的状态，然后可以在任意合适的时刻，以及任意分支，把这些变动给还原回来。 本文看一下 git stash 相关的命令。注意，本文中示例 $ 开头的表示执行的命令，其他内容为命令的输出。 git stashgit stash [push [-p|--patch] [-k|--[no-]keep-index] [-q|--quiet]2 [-u|--include-untracked] [-a|--all] [-m|--message &lt;message&gt;]2 [--pathspec-from-file=&lt;file&gt; [--pathspec-file-nul]]2 [--] [&lt;pathspec&gt;…​]] 首先进入一个 git 仓库，使用 git status 查看一下状态： $ cd test$ git status# 输出 On branch test nothing to commit, working tree clean 可以看到此时工作区是干净的，没有任何变更，尝试修改一个文件： $ echo &#x27;stashed change&#x27; &gt; README.md$ git status On branch test Untracked files: (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed) modified: README.md nothing added to commit but untracked files present (use &quot;git add&quot; to track) 这个时候，有新的工作需要处理，执行 git stash 来暂存文件： $ git stash Saved working directory and index state WIP on test: 3ef7d58 release 1.0 $ git status On branch test nothing to commit, working tree clean 可以看到此时工作区已经回到了编辑前的干净状态，这个时候就可以进行其他的修改了。 使用 -m 命令可以在stash 时设置message: $ git stash -m &quot;debug code&quot;$ git stash list stash@&#123;0&#125;: On test: debug code stash@&#123;1&#125;: WIP on test: 3ef7d58 release 1.0 stash@&#123;2&#125;: WIP on test: 3ef7d58 release 1.0 默认情况下，stash 只会保存已修改和暂存的 已追踪文件，也就是说未被追踪过的文件是无法保存的，下面尝试新建一个文件来保存： $ touch newfile$ git stash No local changes to save$ git status On branch test Untracked files: (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed) newfilenothing added to commit but untracked files present (use &quot;git add&quot; to track) 可以看到新建的文件无法被存储，这个时候可以加上 --include-untracked 或 -u 参数，可以看到，此时新增加的文件也被 stash 暂存了： $ git stash -u Saved working directory and index state WIP on test: 3ef7d58 release 1.0$ git status On branch test nothing to commit, working tree clean git stash listgit stash list [&lt;log-options&gt;] git stash list 用于查看当前的 stash 都存储了哪些内容： $ git stash list stash@&#123;0&#125;: WIP on test: 3ef7d58 release 1.0 stash@&#123;1&#125;: WIP on test: 3ef7d58 release 1.0 stash@&#123;2&#125;: WIP on test: 3ef7d58 release 1.0 每个保存的 stash 都有个 name，如上命令的输出看到，格式为stash@&#123;&lt;name&gt;&#125;，stash 使用了栈的存储结构，所以数字越小的是越近保存的，如 stash@&#123;0&#125; 是最新保存的，stash@&#123;2&#125; 是最早保存的。 从上面的语法可以看出 stash list 命令还支持 git log 命令的参数，比如使用 --pretty=oneline 命令查看 stash 的详细改动： $ git stash list --pretty=oneline e2a114ca7692a1415b6d97e71dee8935af251a41 (refs/stash) refs/stash@&#123;0&#125;: WIP on test: 3ef7d58 release 1.0 6446c1dffa700c1b603396c19a372ce1cdd63956 refs/stash@&#123;1&#125;: WIP on test: 3ef7d58 release 1.0 e32b6ec77994ada19051586af37b0bc595bd9605 refs/stash@&#123;2&#125;: WIP on test: 3ef7d58 release 1.0 git stash showgit stash show [diff-options] [stash] git stash show 用于查看 stash 存储的改动，默认展示最近一次的改动： $ git stash show README.md | 2 +- 1 file changed, 1 insertion(+), 1 deletion(-) 如果要看其它的存储，可以加上 stash name ： $ git stash list stash@&#123;0&#125;: WIP on test: 3ef7d58 release 1.0$ git stash show stash@&#123;0&#125; README.md | 2 +- 1 file changed, 1 insertion(+), 1 deletion(-) 从上面的语法可以看出 stash show 命令还支持 git diff 命令的参数，比如使用 -p 命令，可以查看 stash 的详细改动： $ git stash show -p diff --git a/README.md b/README.md index ec3514a..79105b0 100644 --- a/README.md +++ b/README.md @@ -1 +1 @@ -&#x27;test&#x27; +&#x27;stashed change version 3&#x27; git stash dropgit stash drop [-q|--quiet] [stash] git stash drop 用于删除 stash 中的某个存储： $ git stash list stash@&#123;0&#125;: WIP on test: 3ef7d58 release 1.0 stash@&#123;1&#125;: WIP on test: 3ef7d58 release 1.0 stash@&#123;2&#125;: WIP on test: 3ef7d58 release 1.0$ git stash drop stash@&#123;2&#125; Dropped stash@&#123;2&#125; (e32b6ec77994ada19051586af37b0bc595bd9605)$ git stash list stash@&#123;0&#125;: WIP on test: 3ef7d58 release 1.0 stash@&#123;1&#125;: WIP on test: 3ef7d58 release 1.0 git stash applygit stash apply [--index] [-q|--quiet] [stash] git stash apply 是 git stash 的反操作，将 stash 保存的状态还原到工作区，也就是还原指定的 stash 的内容： $ echo &#x27;stashed and restore&#x27; &gt; README.md$ git status On branch test Changes not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git restore &lt;file&gt;...&quot; to discard changes in working directory) modified: README.md no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)$ git stash Saved working directory and index state WIP on test: 3ef7d58 release 1.0$ git status On branch test nothing to commit, working tree clean$ git stash apply On branch test Changes not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git restore &lt;file&gt;...&quot; to discard changes in working directory) modified: README.md no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;) 从上面的操作可以看出，执行了 git stash apply 后，工作取得状态又还原回 git stash 之前的状态了。 git stash popgit stash pop [--index] [-q|--quiet] [stash] git stash pop 和 git stash apply 的作用完全一样，不同点在于 git stash apply 不会从 stash 中删除还原的 stash，而 git stash pop 会从 stash 中删除： $ git stash list stash@&#123;0&#125;: WIP on test: 3ef7d58 release 1.0 stash@&#123;1&#125;: WIP on test: 3ef7d58 release 1.0 stash@&#123;2&#125;: WIP on test: 3ef7d58 release 1.0$ git stash apply$ git stash list stash@&#123;0&#125;: WIP on test: 3ef7d58 release 1.0 stash@&#123;1&#125;: WIP on test: 3ef7d58 release 1.0 stash@&#123;2&#125;: WIP on test: 3ef7d58 release 1.0$ git stash pop$ git stash list stash@&#123;0&#125;: WIP on test: 3ef7d58 release 1.0 stash@&#123;1&#125;: WIP on test: 3ef7d58 release 1.0 从上面的例子可以看出 git stash apply 执行后 stash list 没有变化，而 git stash pop 执行后 stash list 里没有了此内容。 git stash cleargit stash clear 用于清除所有 stash 里存储的内容： $ git stash list stash@&#123;0&#125;: WIP on test: 3ef7d58 release 1.0$ git stash clear$ git stash list//输出空 可以看到，此时的 stash 已经被清空了。 git stash branchgit stash branch &lt;branchname&gt; [&lt;stash&gt;] git stash branch 命令会以指定的分支名创建一个新分支，然后从 stash 中 检出存储的内容，然后从 stash 中丢弃保存的内容： $ git stash list stash@&#123;0&#125;: WIP on test: 3ef7d58 release 1.0 stash@&#123;1&#125;: WIP on test: 3ef7d58 release 1.0 stash@&#123;2&#125;: WIP on test: 3ef7d58 release 1.0$ git stash branch test-stash stash@&#123;1&#125; Switched to a new branch &#x27;test-stash&#x27; On branch test-stash Changes not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git restore &lt;file&gt;...&quot; to discard changes in working directory) modified: README.md no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;) Dropped stash@&#123;1&#125; (9a6040c186a91874c6949f5ec29de61b9bcc1014)$ git stash list stash@&#123;0&#125;: WIP on test: 3ef7d58 release 1.0 stash@&#123;1&#125;: WIP on test: 3ef7d58 release 1.0 stash@&#123;2&#125;: WIP on test: 3ef7d58 release 1.0 git stash create/store两个命令不常用，就不总结了，详细可以查看 git 的文档。 参考 git scm","categories":[{"name":"其它","slug":"其它","permalink":"http://tcatche.site/categories/%E5%85%B6%E5%AE%83/"}],"tags":[{"name":"git","slug":"git","permalink":"http://tcatche.site/tags/git/"}]},{"title":"Git tag - 打标签操作","slug":"git_tag","date":"2021-05-08T05:31:00.000Z","updated":"2021-05-26T05:22:10.891Z","comments":true,"path":"2021/05/git_tag/","link":"","permalink":"http://tcatche.site/2021/05/git_tag/","excerpt":"","text":"Git 可以给仓库里的分支打上标签做标记，比如在代码发布后经常会打上V1.0，V2.0 这样的标签，本文看一下这些打标签相关的操作。 本文中示例 $ 开头的表示执行的命令，其他内容为命令的输出。 创建标签通过 git tag 即可很容易的创建标签： 为当前提交创建标签 git tag 示例： $ git tag v1.0 使用 git log 也能看到打的标签。 $ git logcommit c5c2f2749577b998c4aff65663b40190dc4072a3 (HEAD -&gt; master, tag: v1.0)Author: tcatche &lt;tcatche@example.com&gt;Date: Sat May 8 11:25:00 2021 +0800 Release v1.0 为历史提交创建标签为历史提交创建标签，则在后面加上 commitHash 即可。 git tag 示例： $ git tag v0.9 标签增加备注使用 -m 可以为标签增加附属信息： git tag -m ““ $ git tag v2.5 -m &quot;记录一些附属信息&quot;$ git show v2.5# 输出tag v2.5Tagger: tcatche &lt;tcatche@example.com&gt;Date: Sat May 8 13:25:50 2021 +0800记录一些附属信息commit 3ef7d58f0bd8dba7a5c7d4b899b17d9c9dda8ad2 (HEAD -&gt; test, tag: v2.5, tag: v1.0)Author: tcatche &lt;tcatche@example.com&gt;Date: Sat May 8 11:18:26 2021 +0800 release 1.0 可以看到输出里多了打标签人、打标签的日期时间、记录的附注信息。 查看标签查看当前代码库全部的标签 git tag $ git tag# 输出v0.9v1.0v2.0 注意，标签是按字母排序而非提交日期或者标签创建日期排序。 使用通配符查看指定标签如果代码仓库有很多标签，也可以使用通配符匹配符合指定格式的标签： git tag -l ““ $ git tag -l &quot;v*.0&quot;# 输出v1.0v2.0 查看某个标签的详细信息 git show $ git show v1.0# 输出commit 3ef7d58f0bd8dba7a5c7d4b899b17d9c9dda8ad2 (HEAD -&gt; master, tag: v1.0)Author: tcatche &lt;tcatche@example.com&gt;Date: Sat May 8 11:18:26 2021 +0800 release 1.0diff --git a/README.md b/README.md 标签推送到远程仓库推送指定标签到远程仓库 git push origin $ git push origin v1.0# 输出Counting objects: 1, done.Writing objects: 100% (1/1), 160 bytes | 0 bytes/s, done.Total 1 (delta 0), reused 0 (delta 0)To git@github.com/example.git * [new tag] v1.0 -&gt; v1.0 推送全部标签到远程仓库可以把本地存在而远程仓库不存在的标签一次性推送到远程仓库。 git push origin –tags $ git push origin --tags# 输出Counting objects: 1, done.Writing objects: 100% (1/1), 160 bytes | 0 bytes/s, done.Total 1 (delta 0), reused 0 (delta 0)To git@github.com/example.git * [new tag] v0.9 -&gt; v0.9 * [new tag] v1.0 -&gt; v1.0 * [new tag] v2.0 -&gt; v2.0 删除标签删除本地标签 git tag -d $ git tag -d v1.0# 输出Deleted tag &#x27;v1.0&#x27; (was 3ef7d58) 删除远程仓库的标签 git push :refs/tags/orgit push origin –delete $ git push origin :refs/tags/v1.0# 输出To git@github.com/example.git - [deleted] v1.0 代码切换到指定标签使用 git checkout 命令，可以使代码回到指定的标签位置，但此时会处于 detached HEAD 状态： git checkout $ git checkout v1.0# 输出Note: switching to &#x27;v1.0&#x27;.You are in &#x27;detached HEAD&#x27; state. You can look around, make experimentalchanges and commit them, and you can discard any commits you make in thisstate without impacting any branches by switching back to a branch.If you want to create a new branch to retain commits you create, you maydo so (now or later) by using -c with the switch command. Example: git switch -c &lt;new-branch-name&gt;Or undo this operation with: git switch -Turn off this advice by setting config variable advice.detachedHead to falseHEAD is now at 3ef7d58 release 1.0 如果需要更改时，通常需要创建一个新的分支： git switch -c &lt;branchName&gt; 当然也可以在 checkout 的时候创建一个新分支： git checkout -b 参考 git-scm","categories":[{"name":"其它","slug":"其它","permalink":"http://tcatche.site/categories/%E5%85%B6%E5%AE%83/"}],"tags":[{"name":"git","slug":"git","permalink":"http://tcatche.site/tags/git/"}]},{"title":"浏览器 Fullscreen API","slug":"browser_full_screen","date":"2021-03-11T07:01:00.000Z","updated":"2021-05-12T02:28:00.208Z","comments":true,"path":"2021/03/browser_full_screen/","link":"","permalink":"http://tcatche.site/2021/03/browser_full_screen/","excerpt":"","text":"Fullscreen API 支持以全屏模式展示特定元素及其后代。这使得它可以将特定内容（如游戏，大屏可视化看板等）铺满整个屏幕。并在不再需要时退出全屏模式。 本文看一下全屏相关内容的操作： 进入全屏和退出全屏Element.requestFullscreenElement.requestFullscreen() 方法异步地使元素进入全屏模式，此方法返回一个 Promise。 var Promise = Element.requestFullscreen(options); 调用此API并不能保证元素能进入全屏模式。如果元素成功进入全屏模式，返回的 Promise 的状态会变为 resolve；如果失败，Promise 状态会变成 rejected。 document.body.onclick = function (event) &#123; document.body.requestFullscreen() .then(() =&gt; console.log(&#x27;进入全屏成功&#x27;)) .catch(err =&gt; &#123; console.log(&#x27;进入全屏失败&#x27;) console.error(err) &#125;)&#125; 注意，本方法调用必须在响应用户操作才会生效，也就是说才方法需要放在如 click 事件的回调函数中，直接调用会失败。 // 全屏模式只允许用户操作触发，此操作会发生错误document.documentElement.requestFullscreen();// 全屏模式只允许用户操作触发，此操作会成功document.body.onclick = function () &#123; document.documentElement.requestFullscreen();&#125; 注意，允许多个元素进入全屏状态，浏览器会内部维护一个全屏状态元素的列表。 Document.exitFullscreenDocument.exitFullscreen 方法，能够从当前全屏模式退回到上一次调用 Element.requestFullscreen 之前的状态。 与 Element.requestFullscreen 类似，本方法也返回一个 Promise 对象。 document.body.onclick = function (event) &#123; if (document.fullscreenElement) &#123; document.exitFullscreen() .then(() =&gt; console.log(&quot;退出成功&quot;)) .catch((err) =&gt; &#123; console.log(&#x27;退出失败&#x27;) console.error(err) &#125;) &#125; else &#123; document.body.requestFullscreen(); &#125;&#125; 注意，本方法调用一次只会关闭上次调用 Element.requestFullscreen 进入的全屏模式，如果有多次调用 Element.requestFullscreen 进入的全屏模式，此时仍处于全屏模式。 如果想要全部退出全屏，可以参考下面代码： // 所有的全屏元素都退出全屏async function exitFullscreenAll() &#123; while (document.fullscreenElement) &#123; console.log(document.fullscreenElement) await document.exitFullscreen() .then(() =&gt; console.log(&quot;退出成功&quot;)) .catch((err) =&gt; &#123; console.log(&#x27;退出失败&#x27;) console.error(err) &#125;) &#125;&#125;exitFullscreenAll(); 注意，这个方法是挂载在 Document 对象而不是 Element 对象上的。 注意，通常可以通过按 Esc 或 F11 键退出全屏模式。 全屏事件总共有两类事件 fullscreenchange 和 fullscreenerror： fullscreenchange: 进入或退出全屏成功后触发事件。 fullscreenerror: 进入或退出全屏发生错误后触发事件。 document.onfullscreenchange = function ( event ) &#123; console.log(&quot;全屏状态改变成功&quot;)&#125;;document.onfullscreenerror = function ( event ) &#123; console.log(&quot;全屏状态改变失败&quot;)&#125;;// 全屏模式只允许用户操作触发，此操作会发生错误document.documentElement.requestFullscreen();// 全屏模式只允许用户操作触发，此操作会成功document.body.onclick = function () &#123; document.documentElement.requestFullscreen();&#125; 注意，它们可以挂在 Document 对象监听文档中的所有元素进入/退出全屏状态或进入/退出出错，也可以挂在 Element 对象上监听某个元素进入/退出全屏状态或进入/退出出错。 相关属性document.fullscreenEnabled 属性document.fullscreenEnabled 属性返回一个布尔值，表明浏览器是否支持全屏模式。 document.fullscreenElement 属性document.fullscreenElement 可以用来获得当前全屏的元素，如果没有全屏的元素则返回 null。 // 指定元素是否全屏function isElementInFullscreen(ele) &#123; return document.fullscreenElement &amp;&amp; document.fullscreenElement === ele;&#125; document.mozFullScreen~~document.fullscreen~~ 属性返回一个布尔值，表示当前是否以全屏模式显示内容。该方法已经被废弃，不建议使用，可以使用上面的 document.fullscreenElement 属性替代。 相关的 CSS对应的有两个伪类和伪元素和全屏状态有关 :fullscreen 伪类 和 ::backdrop 伪元素。 :fullscreen 伪类CSS :fullscreen 伪类匹配当前处于全屏模式的每个元素。如果当前有多个元素处于全屏模式，则会选择所有元素。 /* 非全屏下，按钮的颜色为蓝色 */button:not(:fullscreen) &#123; background-color: blue;&#125;/* 全屏下，按钮的颜色为红色 */button:fullscreen &#123; background-color: red;&#125; ::backdrop 伪元素::backdrop 伪元素是一个与视口大小相同的框，它在全屏模式下直接呈现在全屏元素的下方。 /* button 全屏时，button元素背后的颜色为红色 注意，不是 button 的 background */button:backdrop &#123; background-color: red;&#125; 参考 MDN: Fullscreen API caniuse :fullscreen caniuse ::backdrop","categories":[{"name":"js","slug":"js","permalink":"http://tcatche.site/categories/js/"}],"tags":[{"name":"dom","slug":"dom","permalink":"http://tcatche.site/tags/dom/"},{"name":"浏览器","slug":"浏览器","permalink":"http://tcatche.site/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"}]},{"title":"状态切换","slug":"function_program_switch","date":"2021-03-10T05:15:00.000Z","updated":"2021-05-12T02:29:35.377Z","comments":true,"path":"2021/03/function_program_switch/","link":"","permalink":"http://tcatche.site/2021/03/function_program_switch/","excerpt":"","text":"切换状态是一个比较常见的操作，通常会这么进行切换： 常规操作let state: boolean = truefunction toggle(): boolean &#123; this.state = !this.state return this.state&#125; 更通用一点的写法会进行一个封装： class Switch &#123; private state:boolean constructor(initState: boolean) &#123; this.state = initState &#125; getState(): boolean &#123; return this.state &#125; toggle(): boolean &#123; this.state = !this.state return this.getState() &#125;&#125; 更改状态的表示方法如果是文字状态切换呢？可能会这么写： const switcher = new Switch(false)let currentState = switcher.getState()currentState ? &#x27;on&#x27; : &#x27;off&#x27; 或许你会想到可以更改 Switch 的定义： class Switch &#123; private state: boolean private trueState: string private falseState: string constructor(initState: boolean, trueState: string, falseState: string) &#123; this.state = initState this.trueState = trueState this.falseState = falseState &#125; toggle(): boolean &#123; this.state = !this.state return this.getState() &#125; getState(): boolean &#123; return this.state &#125;&#125; 切换多个状态在有些场合，会有有多个状态进行切换，比如十字路口的灯有红黄绿三种状态切换，这个时候应该想到可以使用数组。 这里直接一步到位，使用泛型，支持任意的状态类型切换： class Switch&lt;T&gt; &#123; private index: number private state: T[] constructor(initState: T, state: T[]) &#123; this.state = state this.index = state.indexOf(initState) &#125; getState(): T &#123; return this.state[this.index] &#125; toggle(): T &#123; this.index = (this.index + 1) % this.state.length return this.getState() &#125;&#125;const switcher = new Switch(&#x27;红&#x27;, [&#x27;红&#x27;, &#x27;黄&#x27;, &#x27;绿&#x27;])console.log(switcher.toggle()) // 黄console.log(switcher.toggle()) // 绿console.log(switcher.toggle()) // 红 使用泛型，当然也支持函数，比如根据不同的状态执行不同的操作： const redFn = () =&gt; console.log(&#x27;红灯，禁止通行&#x27;)const yellowFn = () =&gt; console.log(&#x27;黄灯，谨慎通行&#x27;)const greenFn = () =&gt; console.log(&#x27;绿灯，畅通无阻&#x27;)const roadSwitcher = new Switch(redFn, [redFn, yellowFn, greenFn])roadSwitcher.getState()() // 红灯，禁止通行roadSwitcher.toggle()() // 黄灯，谨慎通行roadSwitcher.toggle()() // 绿灯，畅通无阻roadSwitcher.toggle()() // 红灯，禁止通行 高阶函数除了使用类，使用高阶函数也是可以做到的： function switchFn&lt;T&gt;(initState: T, state: T[]) &#123; let index: number = state.indexOf(initState) return function() &#123; index = (index + 1) % state.length return state[index] &#125;&#125;const switcher = switchFn(&#x27;红&#x27;, [&#x27;红&#x27;, &#x27;黄&#x27;, &#x27;绿&#x27;])console.log(switcher()) // 黄console.log(switcher()) // 绿console.log(switcher()) // 红console.log(switcher()) // 黄const redFn = () =&gt; console.log(&#x27;红灯，禁止通行&#x27;)const yellowFn = () =&gt; console.log(&#x27;黄灯，谨慎通行&#x27;)const greenFn = () =&gt; console.log(&#x27;绿灯，畅通无阻&#x27;)const roadSwitcher = switchFn(redFn, [redFn, yellowFn, greenFn])roadSwitcher()() // 黄灯，谨慎通行roadSwitcher()() // 绿灯，畅通无阻roadSwitcher()() // 红灯，禁止通行roadSwitcher()() // 黄灯，谨慎通行 生成器 Generator遍历多个状态时，也可以使用 Generator function *loop&lt;T&gt;(initIndex: number, list: T[])&#123; let currentIndex: number = initIndex while(true)&#123; currentIndex = (currentIndex + 1) % list.length yield list[currentIndex] &#125;&#125;function switchFn&lt;T&gt;(initState: T, state: T[]) &#123; const list = loop(state.indexOf(initState), state) return function() &#123; return list.next().value as T &#125;&#125; 自定义 hookconst useSwitch = &lt;T extends unknown &gt;(initialValue: T, stateList: T[]): [T, () =&gt; void] =&gt; &#123; const switcher = switchFn(initialValue, stateList); const [state, setState] = useState&lt;T&gt;(switcher(false)); return [state, () =&gt; &#123; setState(switcher(true)); &#125;];&#125;","categories":[{"name":"js","slug":"js","permalink":"http://tcatche.site/categories/js/"}],"tags":[{"name":"状态","slug":"状态","permalink":"http://tcatche.site/tags/%E7%8A%B6%E6%80%81/"},{"name":"hook","slug":"hook","permalink":"http://tcatche.site/tags/hook/"},{"name":"generator","slug":"generator","permalink":"http://tcatche.site/tags/generator/"}]},{"title":"使用 npm link 开发 npm 模块","slug":"node_npm_link","date":"2021-03-09T08:58:00.000Z","updated":"2021-03-09T08:58:32.055Z","comments":true,"path":"2021/03/node_npm_link/","link":"","permalink":"http://tcatche.site/2021/03/node_npm_link/","excerpt":"","text":"npm link 命令主要用于本地开发 npm 模块。 使用 npm link 命令，可以将当前开发的 npm 模块链接到对应的测试项目中，可以很方便地对开发中的模块进行调试和测试。 语法 npm link (in npm package dir)npm link [&lt;@scope&gt;/][@] 别名: npm ln 使用步骤npm link 的过程有两个步骤： 1.在指定的文件夹里执行 npm link 命令 将在全局文件夹 &#123;prefix&#125;/lib/node_modules/&lt;package&gt; 中创建一个符号链接，该链接到执行 npm 链接命令的包。 如下： λ npm link输出：C:\\Users\\userName\\AppData\\Roaming\\npm\\node_modules\\npm-link -&gt; D:\\works\\test\\npm-link 2.在测试项目目录里运行 npm link &lt;package&gt;，注意，&lt;package&gt; 从 npm 包 中的 package.json 中取出的，而不是 npm 包的目录名称 λ mkdir npm-link-testλ cd npm-link-testλ npm link npm-link输出：D:\\works\\test\\npm-link-test\\node_modules\\npm-link -&gt; C:\\Users\\userName\\AppData\\Roaming\\npm\\node_modules\\npm-link -&gt; D:\\works\\test\\npm-link 测试文件是否链接进去了： λ cd npm-linkλ touch test.jsλ cd npm-link-testλ ls node_modules\\npm-link输出：index.js package.json package-lock.json test.js 这样就可以很方便地进行开发和调试 npm 包了。 取消 link分别在模块目录和测试项目目录执行 npm unlink 参考npm link","categories":[{"name":"js","slug":"js","permalink":"http://tcatche.site/categories/js/"}],"tags":[{"name":"node","slug":"node","permalink":"http://tcatche.site/tags/node/"},{"name":"npm","slug":"npm","permalink":"http://tcatche.site/tags/npm/"}]},{"title":"CSS currentColor 属性值","slug":"css_current_color","date":"2021-02-04T05:49:00.000Z","updated":"2021-08-09T06:40:14.327Z","comments":true,"path":"2021/02/css_current_color/","link":"","permalink":"http://tcatche.site/2021/02/css_current_color/","excerpt":"","text":"currentColor 关键字表示当前元素设置的或者继承来的 color 属性的颜色值，可以用到任意属性值为颜色的地方。 这样说有点抽象，下面直接看几个例子，本文所有示例都在文章末尾： currentColor 可以设置为颜色的属性值下面是一个设置边框，阴影颜色和文字颜色一样的例子： .example1 &#123; color: red; border: 1px solid currentColor;&#125;.example2 &#123; color: red; box-shadow: 0 0 2px currentColor;&#125; currentColor 也可以使用到伪类和伪元素如下，currentColor 对于伪元素也生效： .example3 &#123; color: red;&#125;.example3::after &#123; content: &#x27;&#x27;; display: inline-block; border: 4px solid transparent; border-left-color: currentColor&#125; 结合其他伪类，可以很方便的设置一些特殊的效果，比如下面是 .example3 的三角形随着 hover 状态改变的例子： /* 使用了 currentColor */.example3:hover &#123; color: green;&#125;/* 不使用 currentColor */.example3:hover &#123; color: green;&#125;.example3:hover::after &#123; border-left-color: green;&#125; 从上面例子可以看出，使用 currentColor 代码精简了很多，特别是党当还有更多的伪类如 :hover、 :visited、 :focus、 :active 等存在时，可以节省更多的重复代码。 上述示例在线代码： See the Pen OJbyaxM by tcatche (@tcatche) on CodePen. caniuse caniuse currentColor 基本上主流浏览器都支持了这个属性，可以放心使用。","categories":[{"name":"css","slug":"css","permalink":"http://tcatche.site/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"http://tcatche.site/tags/css/"},{"name":"color","slug":"color","permalink":"http://tcatche.site/tags/color/"}]},{"title":"CSS min()，max() 和 clamp() 函数","slug":"css_min_max_clamp","date":"2021-02-03T07:41:00.000Z","updated":"2021-02-04T05:49:30.019Z","comments":true,"path":"2021/02/css_min_max_clamp/","link":"","permalink":"http://tcatche.site/2021/02/css_min_max_clamp/","excerpt":"","text":"min()，max() 和 clamp() 是css 的三个函数，它们的作用都是从其参数中选择一个值作为实际的属性值。 这三个函数可以被用在任何允许&lt;长度&gt;、&lt;频率&gt;、&lt;角度&gt;、&lt;时间&gt;、&lt;百分比&gt;、&lt;数字&gt;或&lt;整数&gt;的地方使用。 min()min() 函数接受一个或多个以逗号分隔的表达式作为参数，并从参数中选择最小的值作为实际的 CSS 属性值。 签名为： property: min(expression [, expression]); /* min() 示例 */min(100px, 200px); /* 100px */min(100px, 200px, 300px); /* 100px */min(50vw, 200px); /* screen width &gt; 400px ? 200px : 50vw; */ min() 的参数也允许是表达式： min(100px, min(200px, 300px)); /* 100px */ max()max() 函数接受一个或多个以逗号分隔的表达式作为参数，并参数中选择最大的值作为实际的 CSS 属性值。 签名为： property: max(expression [, expression]); /* max() 示例 */width: max(100px, 200px); /* 200px */width: max(100px, 200px, 300px); /* 300px */width: max(50vw, 200px); /* screen width &gt; 400px ? 50vw : 200px; */ max() 的参数也允许是表达式： width: max(100px, min(200px, 300px)); /* 200px */ clamp()clamp() 函数允许在定义的最小值和最大值之间的数值范围内选择一个中间值。与 min() 和 max() 不同的是，它接受三个参数: 最小值（MIN）、首选值(VALUE)和最大值(MAX)。 签名为： property: max(MIN, VALUE, MAX); 如果 VALUE 在 MIN 和 MAX 范围之间，则使用 VALUE 作为函数返回值；如果 VALUE 大于 MAX，则使用 MAX 作为返回值；如果 VALUE 小于 MIN ，则使用 MIN 作为返回值。 clamp(min, value, max)/* 等价于下面的逻辑 */if (value &lt; min) return min;else if (value &gt; max) return max;else return value; clamp() 还可以使用组合 min() 和 max() 实现： clamp(min, value, max)// 等价于max(min, min(value, max))// 也等价于min(max(min, value), max) caniuse CSS math functions min(), max() and clamp()","categories":[{"name":"css","slug":"css","permalink":"http://tcatche.site/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"http://tcatche.site/tags/css/"}]},{"title":"使用 elementFromPoint 和 elementsFromPoint 根据坐标获取元素","slug":"dom_get_elements_from_point","date":"2021-01-28T06:39:00.000Z","updated":"2021-03-10T01:57:17.182Z","comments":true,"path":"2021/01/dom_get_elements_from_point/","link":"","permalink":"http://tcatche.site/2021/01/dom_get_elements_from_point/","excerpt":"","text":"简介elementFromPoint 系列有两个方法：document.elementFromPoint 和 document.elementsFromPoint (注意是 elements,多个“s”）。 document.elementFromPoint 获取指定坐标点最上面的元素，而 document.elementsFromPoint 获取指定坐标点下面的所有元素，包括 html 元素，body 元素取决于其是否在指定的坐标上。 签名它们的签名分别为： elementFromPoint(x: number, y: number): Element elementsFromPoint(x: number, y: number): Array 示例 下面是一个在线示例: See the Pen elementFromPoint by tcatche (@tcatche) on CodePen. 从示例中可以看出，返回的元素和位置顺序和其层叠的层级有关。 再看另一个实例，更改点击的元素的文字颜色： See the Pen 更改点击元素的背景颜色 by tcatche (@tcatche) on CodePen. 注意 point-events 设置为 none 的元素将被忽略。 如果指定的坐标点在文档的可视范围外，或者坐标包含负数，那么结果返回 null 或 [] （与浏览器版本有关）。 如果指定的位置为匿名元素（如 ::before, ::after）或 滚动条，则返回其最近一个非匿名类型的祖先元素。 caniuse caniuse elementFromPoint caniuse elementsFromPoint 参考 MDN elementFromPoint MDN elementsFromPoint","categories":[{"name":"js","slug":"js","permalink":"http://tcatche.site/categories/js/"}],"tags":[{"name":"dom","slug":"dom","permalink":"http://tcatche.site/tags/dom/"}]},{"title":"Git 修改提交的邮箱或用户名","slug":"git-filter-branch","date":"2021-01-26T06:28:00.000Z","updated":"2021-05-12T07:23:48.230Z","comments":true,"path":"2021/01/git-filter-branch/","link":"","permalink":"http://tcatche.site/2021/01/git-filter-branch/","excerpt":"","text":"修改全局的 commit 的用户名和邮箱如果需要以后 commit 默认的用户名和邮箱为指定的内容，可以通过 git config --global命令: $ git config --global user.email &quot;global@example.com&quot;$ git config --global user.name &quot;example&quot; 然后编辑提交后可以看到修改已生效： $ git log# 输出commit d4a341f8aab5acd0468cbe3d029fc1801f62678d (HEAD -&gt; master)Author: example &lt;global@example.com&gt;Date: Tue Jan 26 14:34:48 2021 +0800 test 对某个仓库设置特定的用户名和邮箱如果想针对某个仓库设置特定的用户名和邮箱，比如工作项目使用工作邮箱，个人项目使用个人邮箱，可以去掉 --global 在特定代码仓库运行： $ cd my-work-repo$ git config user.email &quot;work@example.com&quot;$ git config user.name &quot;work&quot; 然后重新提交 commit ,可以看到此时最新的的提交的用户名已经修改了： $ git log# 输出commit 65a152b75e6c3748eb086830b836d6ec18e3baee (HEAD -&gt; master)Author: work &lt;work@example.com&gt;Date: Tue Jan 26 14:38:04 2021 +0800 test2commit d4a341f8aab5acd0468cbe3d029fc1801f62678dAuthor: example &lt;global@example.com&gt;Date: Tue Jan 26 14:34:48 2021 +0800 test 而全局的用户信息仍为 example 和 global@example.com ： $ git config --global user.emailglobal@example.com # 输出$ git config --global user.nameexample # 输出 修改最新提交中的用户信息上面的内容只针对新提交的记录，如果想要修改以前的提交中的用户信息，则上面的方式并不生效，需要采用其他方式。 如果需要修改最近一次提交的信息，通常可以使用 git commit --amend --author=&quot;example &lt;global@example.com&gt;&quot;，此时会弹窗 vim 编辑器，可以进一步编辑其它提交信息（注意在 vim 修改用户信息并不生效。）： $ git commit --amend --author=&quot;example &lt;global@example.com&gt;&quot;#vim 弹出提示修改 git 信息test2# Please enter the commit message for your changes. Lines starting# with &#x27;#&#x27; will be ignored, and an empty message aborts the commit.## Author: example &lt;global@example.com&gt;# Date: Tue Jan 26 14:38:04 2021 +0800## On branch master# Changes to be committed:# new file: test2# 如果不需要编辑其它提交信息，只需要增加个 --no-edit 参数即可： $ git commit --amend --author=&quot;example &lt;global@example.com&gt;&quot; --no-edit git rebase 修改多个指定的历史提交如果有多个历史提交，类似的，可以使用 git rebase 命令，和 rebase 操作类似，只是在 git commit --amend 时加上 --author=&quot;example &lt;global@example.com&gt;&quot;，不再详细说明。 使用 git filter-branch 修改全部历史提交git filter-branch 可以重写分支信息，如果需要修改全部的提交信息，可以使用。 $ git filter-branch -f --env-filter &quot;GIT_AUTHOR_NAME=&#x27;Example&#x27;; GIT_AUTHOR_EMAIL=&#x27;example@test.com&#x27;&quot;# 输出Proceeding with filter-branch...Rewrite d4a341f8aab5acd0468cbe3d029fc1801f62678d (1/2) (0 seconds passed, remaining 0 predicted)Rewrite 559892effdc205a2315589b0199fff158a2cd1f8 (2/2) (1 seconds passed, remaining 0 predicted)Ref &#x27;refs/heads/master&#x27; was rewritten 运行 git log 可以看到，变更已经生效。 #运行$ git log#输出commit bf98e0e451072d9e46955e4e779fec0097a51bff (HEAD -&gt; master)Author: Example &lt;example@test.com&gt;Date: Tue Jan 26 14:38:04 2021 +0800 test2 Author: global &lt;global-test@example.com&gt; Date: Tue Jan 26 14:38:04 2021 +0800commit 05aa39b6ce9126ea84caa1be00d6f8b0c742ad9fAuthor: Example &lt;example@test.com&gt;Date: Tue Jan 26 14:34:48 2021 +0800 test 使用 git filter-branch 修改特定的历史提交可以使用脚本，增加判断，只修改特定的历史提交，如下示例： # filter-branch.sh#!/bin/shgit filter-branch -f --env-filter &#x27;OLD_EMAIL=&quot;example@test.com&quot;CORRECT_NAME=&quot;Example-New&quot;CORRECT_EMAIL=&quot;example-new@test.com&quot;if [ &quot;$GIT_COMMITTER_EMAIL&quot; = &quot;$OLD_EMAIL&quot; ]then export GIT_COMMITTER_NAME=&quot;$CORRECT_NAME&quot; export GIT_COMMITTER_EMAIL=&quot;$CORRECT_EMAIL&quot;if [ &quot;$GIT_AUTHOR_EMAIL&quot; = &quot;$OLD_EMAIL&quot; ]then export GIT_AUTHOR_NAME=&quot;$CORRECT_NAME&quot; export GIT_AUTHOR_EMAIL=&quot;$CORRECT_EMAIL&quot;fi&#x27; HEAD 新提交一个 commit 作为区分，然后运行脚本: # 运行$ git config user.email &quot;example-not-change@test.com&quot;$ git commit -m &quot;test3&quot; --allow-empty$ bash filter-branch.sh$ git log# 输出commit 292062018b88641f3233efa08dfd23df04e8dc3c (HEAD -&gt; master)Author: work &lt;example-not-change@test.com&gt;Date: Tue Jan 26 15:23:08 2021 +0800 testcommit 4dc68a1ebfd8c2600f09ed7de307c1a4aa3acf52Author: Example-New &lt;example-new@test.com&gt;Date: Tue Jan 26 14:38:04 2021 +0800 test2 Author: global &lt;global-test@example.com&gt; Date: Tue Jan 26 14:38:04 2021 +0800commit b3761e99006c662cca4a8285842eeca3232f70d0Author: Example-New &lt;example-new@test.com&gt;Date: Tue Jan 26 14:34:48 2021 +0800 test 可以看到，第一个 log 并没有修改。 在使用 git filter-branch 时，可能会注意到控制台有个警告输出： WARNING: git-filter-branch has a glut of gotchas generating mangled history rewrites. Hit Ctrl-C before proceeding to abort, then use an alternative filtering tool such as &#x27;git filter-repo&#x27; (https://github.com/newren/git-filter-repo/) instead. See the filter-branch manual page for more details; to squelch this warning, set FILTER_BRANCH_SQUELCH_WARNING=1. 翻译过来就是说而且 filter-branch 有很多缺陷，可能会对预期的历史重写造成不明显的破坏。而且它的速度非常慢，推荐使用git filter-repo替代。 注意需要注意的是，如果使用上面的方法更改历史提交的用户信息，历史提交的 commit hash，也会随之改变，如果一个仓库是多人协作的，需要慎重使用。 To change the name and/or email address recorded in existing commits, you must rewrite the entire history of your Git repository. Warning: This action is destructive to your repository’s history. If you’re collaborating on a repository with others, it’s considered bad practice to rewrite published history. You should only do this in an emergency. 提交后如果推动到远端，需要加上 --force 或 -f: $ git push --force 参考 git commit git filter-branch","categories":[{"name":"其它","slug":"其它","permalink":"http://tcatche.site/categories/%E5%85%B6%E5%AE%83/"}],"tags":[{"name":"git","slug":"git","permalink":"http://tcatche.site/tags/git/"}]},{"title":"Git 修改提交的邮箱或用户名","slug":"git_modify_history_commit_author","date":"2021-01-26T06:28:00.000Z","updated":"2021-05-26T05:21:15.734Z","comments":true,"path":"2021/01/git_modify_history_commit_author/","link":"","permalink":"http://tcatche.site/2021/01/git_modify_history_commit_author/","excerpt":"","text":"修改全局的 commit 的用户名和邮箱如果需要以后 commit 默认的用户名和邮箱为指定的内容，可以通过 git config --global命令: git config --global user.email &quot;global@example.com&quot;git config --global user.name &quot;example&quot; 然后编辑提交后可以看到修改已生效： git log# 输出commit d4a341f8aab5acd0468cbe3d029fc1801f62678d (HEAD -&gt; master)Author: example &lt;global@example.com&gt;Date: Tue Jan 26 14:34:48 2021 +0800 test 对某个仓库设置特定的用户名和邮箱如果想针对某个仓库设置特定的用户名和邮箱，比如工作项目使用工作邮箱，个人项目使用个人邮箱，可以去掉 --global 在特定代码仓库运行： cd my-work-repogit config user.email &quot;work@example.com&quot;git config user.name &quot;work&quot; 然后重新提交 commit ,可以看到此时最新的的提交的用户名已经修改了： git log# 输出commit 65a152b75e6c3748eb086830b836d6ec18e3baee (HEAD -&gt; master)Author: work &lt;work@example.com&gt;Date: Tue Jan 26 14:38:04 2021 +0800 test2commit d4a341f8aab5acd0468cbe3d029fc1801f62678dAuthor: example &lt;global@example.com&gt;Date: Tue Jan 26 14:34:48 2021 +0800 test 而全局的用户信息仍为 example 和 global@example.com ： git config --global user.emailglobal@example.com # 输出git config --global user.nameexample # 输出 修改最新提交中的用户信息上面的内容只针对新提交的记录，如果想要修改以前的提交中的用户信息，则上面的方式并不生效，需要采用其他方式。 如果需要修改最近一次提交的信息，通常可以使用 git commit --amend --author=&quot;example &lt;global@example.com&gt;&quot;，此时会弹窗 vim 编辑器，可以进一步编辑其它提交信息（注意在 vim 修改用户信息并不生效。）： git commit --amend --author=&quot;example &lt;global@example.com&gt;&quot;#vim 弹出提示修改 git 信息test2# Please enter the commit message for your changes. Lines starting# with &#x27;#&#x27; will be ignored, and an empty message aborts the commit.## Author: example &lt;global@example.com&gt;# Date: Tue Jan 26 14:38:04 2021 +0800## On branch master# Changes to be committed:# new file: test2# 如果不需要编辑其它提交信息，只需要增加个 --no-edit 参数即可： git commit --amend --author=&quot;example &lt;global@example.com&gt;&quot; --no-edit git rebase 修改多个指定的历史提交如果有多个历史提交，类似的，可以使用 git rebase 命令，和 rebase 操作类似，只是在 git commit --amend 时加上 --author=&quot;example &lt;global@example.com&gt;&quot;，不再详细说明。 使用 git filter-branch 修改全部历史提交git filter-branch 可以重写分支信息，如果需要修改全部的提交信息，可以使用。 git filter-branch -f --env-filter &quot;GIT_AUTHOR_NAME=&#x27;Example&#x27;; GIT_AUTHOR_EMAIL=&#x27;example@test.com&#x27;&quot;# 输出Proceeding with filter-branch...Rewrite d4a341f8aab5acd0468cbe3d029fc1801f62678d (1/2) (0 seconds passed, remaining 0 predicted)Rewrite 559892effdc205a2315589b0199fff158a2cd1f8 (2/2) (1 seconds passed, remaining 0 predicted)Ref &#x27;refs/heads/master&#x27; was rewritten 运行 git log 可以看到，变更已经生效。 #运行git log#输出commit bf98e0e451072d9e46955e4e779fec0097a51bff (HEAD -&gt; master)Author: Example &lt;example@test.com&gt;Date: Tue Jan 26 14:38:04 2021 +0800 test2 Author: global &lt;global-test@example.com&gt; Date: Tue Jan 26 14:38:04 2021 +0800commit 05aa39b6ce9126ea84caa1be00d6f8b0c742ad9fAuthor: Example &lt;example@test.com&gt;Date: Tue Jan 26 14:34:48 2021 +0800 test 使用 git filter-branch 修改特定的历史提交可以使用脚本，增加判断，只修改特定的历史提交，如下示例： # filter-branch.sh#!/bin/shgit filter-branch -f --env-filter &#x27;OLD_EMAIL=&quot;example@test.com&quot;CORRECT_NAME=&quot;Example-New&quot;CORRECT_EMAIL=&quot;example-new@test.com&quot;if [ &quot;$GIT_COMMITTER_EMAIL&quot; = &quot;$OLD_EMAIL&quot; ]then export GIT_COMMITTER_NAME=&quot;$CORRECT_NAME&quot; export GIT_COMMITTER_EMAIL=&quot;$CORRECT_EMAIL&quot;if [ &quot;$GIT_AUTHOR_EMAIL&quot; = &quot;$OLD_EMAIL&quot; ]then export GIT_AUTHOR_NAME=&quot;$CORRECT_NAME&quot; export GIT_AUTHOR_EMAIL=&quot;$CORRECT_EMAIL&quot;fi&#x27; HEAD 新提交一个 commit 作为区分，然后运行脚本: # 运行git config user.email &quot;example-not-change@test.com&quot;git commit -m &quot;test3&quot; --allow-emptybash filter-branch.shgit log# 输出commit 292062018b88641f3233efa08dfd23df04e8dc3c (HEAD -&gt; master)Author: work &lt;example-not-change@test.com&gt;Date: Tue Jan 26 15:23:08 2021 +0800 testcommit 4dc68a1ebfd8c2600f09ed7de307c1a4aa3acf52Author: Example-New &lt;example-new@test.com&gt;Date: Tue Jan 26 14:38:04 2021 +0800 test2 Author: global &lt;global-test@example.com&gt; Date: Tue Jan 26 14:38:04 2021 +0800commit b3761e99006c662cca4a8285842eeca3232f70d0Author: Example-New &lt;example-new@test.com&gt;Date: Tue Jan 26 14:34:48 2021 +0800 test 可以看到，第一个 log 并没有修改。 在使用 git filter-branch 时，可能会注意到控制台有个警告输出： WARNING: git-filter-branch has a glut of gotchas generating mangled history rewrites. Hit Ctrl-C before proceeding to abort, then use an alternative filtering tool such as &#x27;git filter-repo&#x27; (https://github.com/newren/git-filter-repo/) instead. See the filter-branch manual page for more details; to squelch this warning, set FILTER_BRANCH_SQUELCH_WARNING=1. 翻译过来就是说而且 filter-branch 有很多缺陷，可能会对预期的历史重写造成不明显的破坏。而且它的速度非常慢，推荐使用git filter-repo替代。 注意需要注意的是，如果使用上面的方法更改历史提交的用户信息，历史提交的 commit hash，也会随之改变，如果一个仓库是多人协作的，需要慎重使用。 To change the name and/or email address recorded in existing commits, you must rewrite the entire history of your Git repository. Warning: This action is destructive to your repository’s history. If you’re collaborating on a repository with others, it’s considered bad practice to rewrite published history. You should only do this in an emergency. 提交后如果推动到远端，需要加上 --force 或 -f: git push --force 参考 git commit git filter-branch","categories":[{"name":"其它","slug":"其它","permalink":"http://tcatche.site/categories/%E5%85%B6%E5%AE%83/"}],"tags":[{"name":"git","slug":"git","permalink":"http://tcatche.site/tags/git/"}]},{"title":"React 编码规范整理","slug":"react-code-spec","date":"2020-08-19T01:58:00.000Z","updated":"2021-01-20T05:54:22.665Z","comments":true,"path":"2020/08/react-code-spec/","link":"","permalink":"http://tcatche.site/2020/08/react-code-spec/","excerpt":"","text":"基础规则每个文件只应包含一个有状态的组件。每个文件只包含一个组件，如有需要，该文件还可以包含多个无状态的纯组件。 使用JSX 书写组件，如非必要，禁止使用 React.createElement。 类组件State不要直接修改 state除了 state 初始化外，其它地方修改 state，需要使用 setState() 方法，直接赋值 state 不会触发组件的渲染。 // badthis.setState(&#123;comment: &#x27;Hello&#x27;&#125;);// goodthis.state.comment = &#x27;hello&#x27;; Methods 函数当在 render() 里使用事件处理方法时，提前在构造函数里把 this 绑定上去，或者使用箭头函数。 // badclass extends React.Component &#123; onClickDiv() &#123; // do stuff &#125; render() &#123; return &lt;div onClick=&#123;this.onClickDiv.bind(this)&#125; /&gt;; &#125;&#125;// goodclass extends React.Component &#123; constructor(props) &#123; super(props); this.onClickDiv = this.onClickDiv.bind(this); &#125; onClickDiv() &#123; // do stuff &#125; render() &#123; return &lt;div onClick=&#123;this.onClickDiv&#125; /&gt;; &#125;&#125;// goodclass extends React.Component &#123; onClickDiv: () =&gt; &#123; // do stuff &#125; render() &#123; return &lt;div onClick=&#123;this.onClickDiv&#125; /&gt;; &#125;&#125; 在React模块中，不要给所谓的私有函数添加 _ 前缀，如果在 typescript 可以使用 private 关键字。 // badReact.createClass(&#123; _onClickSubmit() &#123; // do stuff &#125;, // other stuff&#125;);// good typescriptclass extends React.Component &#123; private onClickSubmit() &#123; // do stuff &#125; // other stuff&#125; 在 render 方法中总是确保 return 有返回值. // badrender() &#123; (&lt;div /&gt;);&#125;// goodrender() &#123; return (&lt;div /&gt;);&#125; 异步请求通常在 componentDidMount 这个生命周期函数中发起异步请求。 componentDidMount() &#123; loadData().then(res =&gt; &#123; this.setState(&#123; data: res.data &#125;); &#125;);&#125; 计算属性/复合属性如果有用到复杂的计算属性，可以使用 getter，不要使用计算函数： // badgetComputedValue() &#123; return this.state.value1 + this.state.value2;&#125;//goodget computedValue() &#123; return this.state.value1 + this.state.value2;&#125; 渲染函数复杂的条件逻辑，使用一个函数渲染，使用函数渲染时需要以 render 开头。 // bad&#123;someConditional ? ( &lt;Bar superLongParam=&quot;bar&quot; anotherSuperLongParam=&quot;baz&quot; /&gt; ) : ( anotherOneConditional ? ( &lt;Tee superLongParam=&quot;bar&quot; anotherSuperLongParam=&quot;baz&quot; /&gt; ) : ( &lt;Bee superLongParam=&quot;bar&quot; anotherSuperLongParam=&quot;baz&quot; /&gt; ) )&#125;// goodrenderText() &#123; if (someConditional) &#123; return ( &lt;Bar superLongParam=&quot;bar&quot; anotherSuperLongParam=&quot;baz&quot; /&gt; ); &#125; if (anotherOneConditional) &#123; return ( &lt;Tee superLongParam=&quot;bar&quot; anotherSuperLongParam=&quot;baz&quot; /&gt; ); &#125; return ( &lt;Bee superLongParam=&quot;bar&quot; anotherSuperLongParam=&quot;baz&quot; /&gt; );&#125; 禁止使用 componentWillMount、 componentWillReceiveProps 和 componentWillUpdateReact v16 废弃了这三个方法，具体原因参考：Update on Async Rendering 禁止使用 MixinsMixins Considered Harmful 组件属性书写排序 class extends React.Component 的生命周期函数: 可选的 static 方法 private 属性 constructor 构造函数 getter 如 get selectReason() 或 get footerContent() getChildContext 获取子元素内容 componentDidMount 模块渲染后 shouldComponentUpdate 判断模块需不需要重新渲染 componentDidUpdate 模块渲染结束 componentWillUnmount 模块将从DOM中清除, 做一些清理任务 点击回调或者事件处理器 如 onClickSubmit() 或 onChangeDescription() 可选的 render 方法 如 renderNavigation() 或 renderProfilePicture() render render() 方法 如何定义 propTypes, defaultProps, contextTypesimport React from &#x27;react&#x27;;import PropTypes from &#x27;prop-types&#x27;;const propTypes = &#123; id: PropTypes.number.isRequired, url: PropTypes.string.isRequired, text: PropTypes.string,&#125;;const defaultProps = &#123; text: &#x27;Hello World&#x27;,&#125;;class Link extends React.Component &#123; static methodsAreOk() &#123; return true; &#125; render() &#123; return &lt;a href=&#123;this.props.url&#125; data-id=&#123;this.props.id&#125;&gt;&#123;this.props.text&#125;&lt;/a&gt;; &#125;&#125;Link.propTypes = propTypes;Link.defaultProps = defaultProps;export default Link; 命名规范文件名使用大驼峰命名法，如 ReservationCard.jsx // badimport reservationCard from &#x27;./ReservationCard&#x27;;// goodimport ReservationCard from &#x27;./ReservationCard&#x27;; 如果整个目录是一个组件, 使用 index.js 作为文件名, import 的时候忽略文件名： // badimport Footer from &#x27;./Footer/Footer&#x27;;// badimport Footer from &#x27;./Footer/index&#x27;;// goodimport Footer from &#x27;./Footer&#x27;; 扩展名如果文件内是一个 React 组件，则文件后缀名使用 jsx，如果引入了 typescript 使用 tsx // badReservationCard.js// goodReservationCard.jsx// goodReservationCard.tsx 组件命名使用大驼峰命名法，一般和文件名保持一致，避免使用 displayName 而是使用类名。 // badexport default class extends React.Component &#123; displayName: &#x27;ReservationCard&#x27;, // stuff goes here&#125;// goodexport default class ReservationCard extends React.Component &#123;&#125; 高阶组件命名生成一个新的组件时, 新组件的组件名 displayName 应该为高阶组件名和传入的组件名的组合. 例如, 高阶组件 withFoo(), 当传入一个 Bar 组件的时候, 生成的组件名 displayName 应该为 withFoo(Bar)。 // badexport default function withFoo(WrappedComponent) &#123; return function WithFoo(props) &#123; return &lt;WrappedComponent &#123;...props&#125; foo /&gt;; &#125;&#125;// goodexport default function withFoo(WrappedComponent) &#123; function WithFoo(props) &#123; return &lt;WrappedComponent &#123;...props&#125; foo /&gt;; &#125; const wrappedComponentName = WrappedComponent.displayName || WrappedComponent.name || &#x27;Component&#x27;; WithFoo.displayName = `withFoo($&#123;wrappedComponentName&#125;)`; return WithFoo;&#125; Why? A component’s displayName may be used by developer tools or in error messages, and having a value that clearly expresses this relationship helps people understand what is happening. 组件的引用名组件的实例应该使用小驼峰法命名。 // badconst ReservationItem = &lt;ReservationCard /&gt;;// goodconst reservationItem = &lt;ReservationCard /&gt;; 组件的属性名JSX属性名使用小驼峰法命名。 // bad&lt;Foo UserName=&quot;hello&quot; phone_number=&#123;12345678&#125;/&gt;// good&lt;Foo userName=&quot;hello&quot; phoneNumber=&#123;12345678&#125;/&gt; 组件的事件监听函数事件监听函数使用 on 或 handle 开头的小驼峰命名法。 // baddoclick() &#123;&#125;// badafterChange() &#123;&#125;// goodhandleClick() &#123;&#125;// goodonClick() &#123;&#125;// goodhandleAfterChange() &#123;&#125;// goodonChanged() &#123;&#125; 渲染函数如果一个函数返回值为要渲染的JSX 时，需要以 render 开头。 // badgetText() &#123; return ( &lt;Bar superLongParam=&quot;bar&quot; anotherSuperLongParam=&quot;baz&quot; /&gt; );&#125;// goodrenderText() &#123; return ( &lt;Bar superLongParam=&quot;bar&quot; anotherSuperLongParam=&quot;baz&quot; /&gt; );&#125; 空格、缩进和对齐在自关闭的标签前加一个空格。 // bad&lt;Foo/&gt;// very bad&lt;Foo /&gt;// bad&lt;Foo /&gt;// good&lt;Foo /&gt; 属性能在一行中完全显示, 则可以直接写成一行，如果有多行属性的话, 新建一行编写属性，并新建一行关闭标签。 // bad&lt;Foo superLongParam=&quot;bar&quot; anotherSuperLongParam=&quot;baz&quot; /&gt;// good&lt;Foo superLongParam=&quot;bar&quot; anotherSuperLongParam=&quot;baz&quot;/&gt;// if props fit in one line then keep it on the same line&lt;Foo bar=&quot;bar&quot; /&gt; 子组件要缩进两个空格 &lt;Foo superLongParam=&quot;bar&quot; anotherSuperLongParam=&quot;baz&quot;&gt; &lt;Quux /&gt;&lt;/Foo&gt; 组件在表达式中换行时，需要使用括号包裹起来 // bad&#123; showButton &amp;&amp; &lt;Button /&gt;&#125;// good&#123;showButton &amp;&amp; ( &lt;Button /&gt;)&#125;// good&#123;showButton &amp;&amp; &lt;Button /&gt;&#125;// good&#123;someReallyLongConditional &amp;&amp; anotherLongConditional &amp;&amp; ( &lt;Foo superLongParam=&quot;bar&quot; anotherSuperLongParam=&quot;baz&quot; /&gt; )&#125;// good&#123;someConditional ? ( &lt;Foo /&gt;) : ( &lt;Foo superLongParam=&quot;bar&quot; anotherSuperLongParam=&quot;baz&quot; /&gt;)&#125; 对于没有子元素的标签来说总是自己关闭标签。 // bad&lt;Foo className=&quot;stuff&quot;&gt;&lt;/Foo&gt;// good&lt;Foo className=&quot;stuff&quot; /&gt; Props 属性属性值如果属性值为 true, 可以直接省略。 // bad&lt;Foo hidden=&#123;true&#125; /&gt;// good&lt;Foo hidden /&gt; key避免使用数组的 index 来作为 key 属性的值。 应当使用稳定不变的 ID。(使用不稳定的 ID 会降低性能、造成组件状态出错) 。特别是当元素的顺序可能改变的情况下，不应使用数组的 index 作为 key. // bad&#123;todos.map((todo, index) =&gt;&lt;Todo &#123;...todo&#125; key=&#123;index&#125;/&gt;)&#125;// good&#123;todos.map(todo =&gt; (&lt;Todo &#123;...todo&#125; key=&#123;todo.id&#125;/&gt;))&#125; defaultProps对于所有非必须的属性，总是定义defaultProps属性. // badfunction SFC(&#123; foo, bar, children &#125;) &#123; return &lt;div&gt;&#123;foo&#125;&#123;bar&#125;&#123;children&#125;&lt;/div&gt;;&#125;SFC.propTypes = &#123; foo: PropTypes.number.isRequired, bar: PropTypes.string, children: PropTypes.node,&#125;;// goodfunction SFC(&#123; foo, bar, children &#125;) &#123; return &lt;div&gt;&#123;foo&#125;&#123;bar&#125;&#123;children&#125;&lt;/div&gt;;&#125;SFC.propTypes = &#123; foo: PropTypes.number.isRequired, bar: PropTypes.string, children: PropTypes.node,&#125;;SFC.defaultProps = &#123; bar: &#x27;&#x27;, children: null,&#125;; Refs总是在Refs里使用回调函数 // bad&lt;Foo ref=&quot;myRef&quot; /&gt;// good&lt;Foo ref=&#123;(ref) =&gt; &#123; this.myRef = ref; &#125;&#125;/&gt; 说明本规范主要参考 airbnb 的标准，并结合以前的 React 开发经验和 React 的版本迭代改变做了大量修改整理而成。","categories":[{"name":"js","slug":"js","permalink":"http://tcatche.site/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"http://tcatche.site/tags/js/"},{"name":"安全","slug":"安全","permalink":"http://tcatche.site/tags/%E5%AE%89%E5%85%A8/"},{"name":"react","slug":"react","permalink":"http://tcatche.site/tags/react/"}]},{"title":"空值合并操作符(??) 和可选链操作符(?.)","slug":"nullish_coalescing_and_optional_chaining_operator","date":"2020-08-17T08:10:00.000Z","updated":"2020-08-17T08:29:27.952Z","comments":true,"path":"2020/08/nullish_coalescing_and_optional_chaining_operator/","link":"","permalink":"http://tcatche.site/2020/08/nullish_coalescing_and_optional_chaining_operator/","excerpt":"","text":"空值合并操作符(??) 空值合并操作符 ?? 类似于 || 运算符，当其左侧的操作数为 null 或者 undefined 时，返回右侧的操作数，否则返回左侧的操作数。 看下面的例子： const value = value1 ?? value2;// 等价于const value = (value1 === undefined || value1 === null) ? value2 : value1;const val1 = null ?? &#x27;test&#x27; // testconst val2 = undefined ?? &#x27;test&#x27; // test 从定义上看，空值合并操作符 ?? 类似于 || 运算符，但是是很不同的，看接下来的几个例子： const val3 = 0 ?? &#x27;test&#x27; // 0const val4 = &#x27;&#x27; ?? &#x27;test&#x27; // &#x27;&#x27;const val5 = NaN ?? &#x27;test&#x27; // NaNconst val6 = false ?? &#x27;test&#x27; // false || 左侧的操作数会被强制转换成布尔值。因此，当使用 || 时，需要考虑左侧是否为 0, &#39;&#39;, NaN, false 等值，如果为这几个值时，可能会出现非预期的结果。 注意，当 ?? 直接与 &amp;&amp; 或 || 组合使用时，必须加上括号，否则会抛出 SyntaxError。 null || undefined ?? &quot;default&quot;; // Uncaught SyntaxError: Unexpected token &#x27;??&#x27;(null || undefined ) ?? &quot;default&quot;; // 返回 &quot;default&quot; 可选链操作符(?.) 可选链操作符(?.)允许读取位于连接对象链深处的属性的值，而不必明确验证链中的每个引用是否有效 看下面的例子： const obj = &#123;&#125;;const value = obj.first?.second;等价于:const value = ((obj.first === null || obj.first === undefined) ? undefined : obj.first.second); 当然，函数调用也可以： const value = obj.test?.(); 搭配空值合并操作符使用，也很方便： const value = obj.first?.second ?? &#x27;default value&#x27;; 也可以使用数组和方括号的表达式的形式访问： const key = &#x27;test&#x27;const value = obj?.[key];const valueAt12 = arr?.[12]; 当然，可选连操作符可以连着使用： const value = obj.first?.second?.third.forth; 搭配空值合并操作符使用，效果更佳： const value = obj.first?.second ?? &#x27;default value&#x27;; 注意：可选链操作符不能用于赋值 obj.first?.second = &#x27;second&#x27;; // Uncaught SyntaxError: Invalid left-hand side in assignment Can I Use?空值合并操作符(??) Data on support for the mdn-javascript__operators__nullish_coalescing feature across the major browsers 可选链操作符(?.) Data on support for the mdn-javascript__operators__optional_chaining feature across the major browsers babelbabel 也有两个插件处理这种操作： @babel/plugin-proposal-nullish-coalescing-operator @babel/plugin-proposal-optional-chaining 参考 MDN: Nullish coalescing operator (??)","categories":[{"name":"js","slug":"js","permalink":"http://tcatche.site/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"http://tcatche.site/tags/js/"},{"name":"操作符","slug":"操作符","permalink":"http://tcatche.site/tags/%E6%93%8D%E4%BD%9C%E7%AC%A6/"}]},{"title":"Windows 下查看全局快捷键占用情况","slug":"win10-global-hot-key-use","date":"2020-08-03T06:20:00.000Z","updated":"2021-08-10T03:35:21.472Z","comments":true,"path":"2020/08/win10-global-hot-key-use/","link":"","permalink":"http://tcatche.site/2020/08/win10-global-hot-key-use/","excerpt":"","text":"之前使用的截图工具快捷键无效了，后来发现快捷键被其它程序全局注册了，然后尝试找出被哪个注册了，尝试在搜索引擎中找了一圈，发现搜索出来的好多工具不能用了，比如 Windows Hotkey Explorer 现在会把所有的快捷键都打开一遍，效果极其酸爽。还有推荐 PCHunter 这个作者已经停止维护了，有网友反馈 win10 1709、1903 版本都不支持。 经过一番踩坑，发现一个工具还比较好用：OpenArk。其文档是这么介绍自己的： OpenArk是一款Windows平台上的开源Ark工具. Ark是Anti-Rootkit（对抗恶意程序）的简写, OpenArk目标成为逆向工程师、编程人员的工具，同时也能为那些希望清理恶意软件的用户服务。以后也将会支持更多功能和命令。 这里只介绍它查看全局快捷键的功能，其它的功能就自行体验吧：","categories":[{"name":"其它","slug":"其它","permalink":"http://tcatche.site/categories/%E5%85%B6%E5%AE%83/"}],"tags":[{"name":"快捷键","slug":"快捷键","permalink":"http://tcatche.site/tags/%E5%BF%AB%E6%8D%B7%E9%94%AE/"},{"name":"工具","slug":"工具","permalink":"http://tcatche.site/tags/%E5%B7%A5%E5%85%B7/"}]},{"title":"Resize Observer","slug":"resize-observer","date":"2020-07-21T10:10:00.000Z","updated":"2020-07-21T10:10:39.284Z","comments":true,"path":"2020/07/resize-observer/","link":"","permalink":"http://tcatche.site/2020/07/resize-observer/","excerpt":"","text":"ResizeObserver 用于观察元素内容或边框的尺寸变化。 在这个 API 之前，都是通过 window 的 resize 事件监听元素的尺寸变化。但是这种方法不适用于这种场合： 浏览器窗口大小没有变化但是元素的大小改变了的情况，比如添加删除元素隐藏元素，以及动态改变元素的大小。 浏览器窗口尺寸改变了，但是元素的尺寸并没有变化，此时 resize 事件就浪费了。ResizeObserver 对这种场景下的使用提供了支持，而且可以替代常规的 resize 事件监听器，由于 ResizeObserver 避免了事件捕获/泡泡的开销，在性能上也会更好。 使用从名字上看，ResizeObserver 采用了观察者模式，观察者模式在前端是一个很常用的设计模式，不再详细介绍。使用起来也很简单： // 创建一个观察者对象const observer = new ResizeObserver(callback);// 指定一个观察目标observer.observe(target); ResizeObserverEntry 对象传递给 ResizeObserver 构造器回调函数 callback 中的参数是 ResizeObserverEntry 对象的集合。它有两个属性 contentRect 和 target。来看一下 ResizeObserverEntry 结构： const observer = new ResizeObserver(entries =&gt; &#123; entries.forEach(entry =&gt; &#123; console.log(entry); &#125;);&#125;);observer.observe(document.body); 可以看到输出： 接口定义下面列出了 ResizeObserver 的详细定义： interface ResizeObserver &#123; constructor(ResizeObserverCallback callback); void observe(Element target);// 观察一个指定的元素 void unobserve(Element target); // 取消观察一个指定的元素 void disconnect(); // 取消观察所有指定的元素&#125;; 触发条件W3C 规范指定了 ResizeObserver 的触发条件： 当被观察的元素从 DOM 中插入或移除时，将会触发; 当被观察的元素可见或不可见时，也会触发，比如 display 属性改变为 none 或者取消 none; 以下条件下不会触发： 内联元素不会触发; CSS transform 也不会触发; 一些使用场景总结适用于替代原来的 onresize 事件比如监听 textarea 大小的改变: const initContentRect = null;const observer = new ResizeObserver(function (entries) &#123; const entry = entries[0]; const contentRect = entry.contentRect; if (!initContentRect) &#123; initContentRect = contentRect; return; &#125; console.log(`width changed: $&#123;contentRect.width - initContentRect.width&#125;, height changed: $&#123;contentRect.height - initContentRect.height&#125;`)&#125;);observer.observe(textareaEle); 感知元素的可见性元素的 display 属性改变也会触发 ResizeObserver 的可见性，因此也可以被用来感知元素是否被使用 display: none 隐藏。 const observer = new ResizeObserver(function(entries) &#123; const ele = entries[0]; if (getComputedStyle(ele).display == &#x27;none&#x27;) &#123; console.log(&#x27;隐藏&#x27;); &#125; else &#123; console.log(&#x27;显示&#x27;); &#125;&#125;);observer.observe(ele); 兼容性接下来看一下浏览器兼容性： 从上面可以看出来，浏览器兼容性支持度还可以，而且还有基于 MutationObserver API 实现的 polyfill 。 更多文档 Resize Observer - MDN Resize Observer - W3C caniuse polyfill","categories":[{"name":"js","slug":"js","permalink":"http://tcatche.site/categories/js/"}],"tags":[{"name":"DOM","slug":"DOM","permalink":"http://tcatche.site/tags/DOM/"},{"name":"window","slug":"window","permalink":"http://tcatche.site/tags/window/"}]},{"title":"React Hooks 文档翻译 - 7 - Hooks API Reference（Hooks API 参考）","slug":"react-hooks-reference","date":"2019-04-28T07:54:00.000Z","updated":"2019-04-28T07:54:56.000Z","comments":true,"path":"2019/04/react-hooks-reference/","link":"","permalink":"http://tcatche.site/2019/04/react-hooks-reference/","excerpt":"","text":"翻译自：https://reactjs.org/docs/hooks-reference.html Hooks 是 React 16.8 新增的功能。它允许你在不编写类的情况下使用状态和其他 React 特性。 If you’re new to Hooks, you might want to check out the overview first. You may also find useful information in the frequently asked questions section. 如果你是 Hooks 的新手，可能需要先查看概述。你还可以在常见问题部分找到有用的信息。 Basic HooksuseStateconst [state, setState] = useState(initialState); 返回一个状态值，以及一个更新它的函数。 在首次渲染时，返回的状态（state）与传递给它的第一个参数（initialState）的值相同。 setState 函数用于更新状态。它接受一个新的状态值，并将组件的重新渲染排入队列。 setState(newState); 在后续的重新渲染中，useState 返回的第一个值将始终是更新后的最新状态。 Note React 保证 setState 函数是稳定的，并且重新渲染时不会改变。这就是为什么省略 useEffect 或useCallback 的依赖列表是安全地。 Functional updates如果新状态需要使用先前的状态来计算，则可以传递函数给 setState 。该函数接收先前的状态值做为参数，并返回更新后的值。下面示例演示了使用两种形式的 setState 的计数器组件： function Counter(&#123;initialCount&#125;) &#123; const [count, setCount] = useState(initialCount); return ( &lt;&gt; Count: &#123;count&#125; &lt;button onClick=&#123;() =&gt; setCount(0)&#125;&gt;Reset&lt;/button&gt; &lt;button onClick=&#123;() =&gt; setCount(prevCount =&gt; prevCount + 1)&#125;&gt;+&lt;/button&gt; &lt;button onClick=&#123;() =&gt; setCount(prevCount =&gt; prevCount - 1)&#125;&gt;-&lt;/button&gt; &lt;/&gt; );&#125; “+” 和 “-” 按钮使用函数形式，因为更新后的值基于先前的值。“重置”按钮则使用普通的形式，因为它总是将计数设置回 0。 Note 与类组件中的 setState 方法不同，useState 不会自动合并更新后的状态对象到之前的状态对象上。你可以通过将函数形式与对象扩展语法组合复制这种行为： setState(prevState =&gt; &#123; // Object.assign would also work return &#123;...prevState, ...updatedValues&#125;;&#125;); 另一个选择是 useReducer，它更适合用来管理包含多个子值的状态对象。 Lazy initializationinitialState 参数是首次渲染时使用的状态。在随后的渲染中，它将被忽略。如果初始状态是一个复杂计算的结果，则可以改为提供函数参数，且该函数仅在首次渲染时执行： const [state, setState] = useState(() =&gt; &#123; const initialState = someExpensiveComputation(props); return initialState;&#125;); useEffectuseEffect(didUpdate); 接受一个函数参数，包含命令式，有副作用的代码。 如突变，订阅，计时器，日志记录和其他副作用等都不允许在函数组件的主体内使用（也即不允许在 React 的渲染阶段运行）。这会导致 UI 中出现错误和不一致的混乱。 Instead, use useEffect. The function passed to useEffect will run after the render is committed to the screen. Think of effects as an escape hatch from React’s purely functional world into the imperative world. 相反，使用 useEffect。传递给 useEffect 的函数将在渲染更新到屏幕后运行。将 effects 视为从 React 的纯粹功能性世界进入命令式世界的“逃生舱”。 默认情况下，effects 在每次完成渲染后运行，但你可以选择仅在某些值发生更改时触发它。 Cleaning up an effectOften, effects create resources that need to be cleaned up before the component leaves the screen, such as a subscription or timer ID. To do this, the function passed to useEffect may return a clean-up function. For example, to create a subscription: 通常， effect 创建的资源在组件从屏幕上消失前需要被清理，例如订阅数据源或定时器的 ID。为了清理，传递给 useEffect 的函数可以返回一个清理函数。例如，创建订阅的返回： useEffect(() =&gt; &#123; const subscription = props.source.subscribe(); return () =&gt; &#123; // Clean up the subscription subscription.unsubscribe(); &#125;;&#125;); 清除函数在从 UI 中删除组件前运行，以防止内存泄漏。此外，如果组件渲染多次（通常都是这样），则在**执行下一个 effect 前会清除先前的 effect **。在我们的示例中，意味着每次更新都会创建一个新订阅。要避免每次更新都触发 effect ，请参阅下一节。 Timing of effects与 componentDidMount 和 componentDidUpdate 不同，传递给 useEffect 的函数在布局和绘制到屏幕之后触发。这使得它适用于许多常见的副作用，例如设置订阅和事件处理，因为大多数此类型的工作不应该阻止浏览器更新屏幕的内容。 但是，并非所有 effect 都可以推迟。例如，对用户可见的 DOM 突变必须在下一次绘制之前同步触发，以便用户不会感觉到视觉上的不一致。（它们区别在概念上类似于被动事件侦听器和活动事件侦听器。）对于这些类型的 effects ，React 提供了一个名为 useLayoutEffect 的附加 Hook。它与 useEffect 具有相同的签名，仅仅在触发时机不同。 虽然 useEffect 延迟到浏览器绘制完成之后，但 React 保证它在任何新渲染发生前会被触发。在开始新的更新之前，React 将始终刷新先前渲染的 effect 。 Conditionally firing an effect有条件地触发 effect effect 的默认行为是在每次完成渲染后触发 effect 。这种情况下，如果任何一个传入的参数发生变化，则始终会重新创建 effect 。 但是，在某些情况下，可能是矫枉过正的，例如上一节中的订阅示例。我们无需在每次组件更新时创建新的订阅，除非 source 这个 props 发生了变化。 要实现这样的功能，请传递给 useEffect 第二个参数，它是 effect 所依赖的值数组。更改后的示例是这样的： useEffect( () =&gt; &#123; const subscription = props.source.subscribe(); return () =&gt; &#123; subscription.unsubscribe(); &#125;; &#125;, [props.source],); 现在只有在 props.source 发生更改时才会重新创建订阅。 Note 如果使用此优化，请确保该数组使用组件作用域中的任意值（例如 props 和 state），这些值随时间变化且被 effect 使用。否则，你的代码将引用之前渲染时的陈旧值。了解更多关于如何使用函数处理以及在数组值变化太频繁怎么解决的详细信息。 如果你想要运行 effects 一次并仅清理一次（在装载和卸载时），则可以将空数组（[]）作为第二个参数传递。这告诉 React 你的 effect 不依赖于来自 props 或 state 的任何值，所以它永远不需要重新运行。这不作为特殊情况处理 – 它遵循通常的依赖项数组的工作方式。 如果传递一个空数组（[]），则 effect 内部的 props 和 state 将始终具有其初始值。虽然传递 [] 作为第二个参数更接近熟悉的 componentDidMount 和 componentWillUnmount 心理模型，但通常有更好的解决方案来避免经常重新运行效果。此外，不要忘了 React 推迟 useEffect 到浏览器绘制完成后才执行，所以多做额外的工作也没什么问题。 我们建议使用 exhaustive-deps 规则作为 eslint-plugin-react-hooks 包的一部分。它会在错误地指定依赖项时发出警告并建议修复。 依赖的数组并不会作为参数传递给 effect 函数。但从概念上讲，它们就是这样表达的：effect 函数内引用的每个值应该出现在所依赖的数组中。将来，一个足够先进的编译器可以自动创建这个数组。 useContextconst context = useContext(Context); 接受 Context 对象（从 React.createContext 返回的值）并返回当前的 Context 值的函数，当前 Context 值由组件树上方最近的 &lt;MyContext.Provider&gt; 确定。 当组件最近的 &lt;MyContext.Provider&gt; 更新时，此 Hook 将触发重新渲染，并将最新的 Context 值传递给该MyContext provider。 不要忘记 useContext 的参数必须是 Context 对象本身： 正确：useContext(MyContext) 不正确：useContext(MyContext.Consumer) 不正确：useContext(MyContext.Provider) 当 Context 值更改时，调用 useContext 的组件始终将重新渲染。如果重新渲染组件的代价很昂贵，可以使用 memoization 优化。 Tip 如果你之前熟悉 Context API，则 useContext(MyContext) 等同于类中的 static contextType = MyContext，也等同于 &lt;MyContext.Consumer&gt;。 useContext(MyContext) 只允许你读取 Context 并订阅其更改。你仍然需要组件树中的 &lt;MyContext.Provider&gt; 来提供 Context 的值。 Additional Hooks以下 Hooks 可能是上一节中基本的 Hooks 的变体，也可能仅用于特定的边缘情况。现在不用急着学习它们。 useReducerconst[state, dispatch]=useReducer(reducer, initialArg, init); useState 的替代方案。接受类型为 (state, action) =&gt; newState 的 reducer，并返回与当前状态配对的 dispatch 方法。（如果你熟悉 Redux，你肯定了解它是如何工作的。） 当你有多个涉及子值的复杂状态逻辑或下一个状态取决于前一个状态时，useReducer 通常优于 useState。useReducer 还允许你优化触发深度更新的组件的性能，因为你可以传递 dispatch 而不是使用回调。 这是 useState 一节的计数器示例，使用 reducer 重写为： const initialState = &#123;count: 0&#125;;function reducer(state, action) &#123; switch (action.type) &#123; case &#x27;increment&#x27;: return &#123;count: state.count + 1&#125;; case &#x27;decrement&#x27;: return &#123;count: state.count - 1&#125;; default: throw new Error(); &#125;&#125;function Counter(&#123;initialState&#125;) &#123; const [state, dispatch] = useReducer(reducer, initialState); return ( &lt;&gt; Count: &#123;state.count&#125; &lt;button onClick=&#123;() =&gt; dispatch(&#123;type: &#x27;increment&#x27;&#125;)&#125;&gt;+&lt;/button&gt; &lt;button onClick=&#123;() =&gt; dispatch(&#123;type: &#x27;decrement&#x27;&#125;)&#125;&gt;-&lt;/button&gt; &lt;/&gt; );&#125; Note React 确保 dispatch 函数是稳定的，并且在重新渲染时不会改变。这就是为什么可以安全地省略 useEffect 或 useCallback 的依赖项列表。 Specifying the initial state指定初始状态 有两种不同的方法初始化 useReducer 状态。你可以根据用例选择其中一个。最简单方法是将初始状态作为第二个参数传递给useReducer： const [state, dispatch] = useReducer( reducer, &#123;count: initialCount&#125;); Note React 不使用 Redux 推广的 state = initialState 参数惯例。初始值有时需要依赖于 props，因此采用在调用 Hooks 时指定。如果你强烈希望这么做，可以调用 useReducer(reducer, undefined, reducer) 来模拟Redux 的行为，但我们并不鼓励。 Lazy initialization懒初始化 你还可以推迟创建初始状态。为此，可以将 init 函数作为第三个参数传递。初始状态将设置为 init(initialArg)。 它允许你提取计算初始状态的逻辑到 reducer 的外部。这对于稍后重置状态以响应操作也很方便： function init(initialCount) &#123; return &#123;count: initialCount&#125;;&#125;function reducer(state, action) &#123; switch (action.type) &#123; case &#x27;increment&#x27;: return &#123;count: state.count + 1&#125;; case &#x27;decrement&#x27;: return &#123;count: state.count - 1&#125;; case &#x27;reset&#x27;: return init(action.payload); default: throw new Error(); &#125;&#125;function Counter(&#123;initialCount&#125;) &#123; const [state, dispatch] = useReducer(reducer, initialCount, init); return ( &lt;&gt; Count: &#123;state.count&#125; &lt;button onClick=&#123;() =&gt; dispatch(&#123;type: &#x27;reset&#x27;, payload: initialCount&#125;)&#125;&gt; Reset &lt;/button&gt; &lt;button onClick=&#123;() =&gt; dispatch(&#123;type: &#x27;increment&#x27;&#125;)&#125;&gt;+&lt;/button&gt; &lt;button onClick=&#123;() =&gt; dispatch(&#123;type: &#x27;decrement&#x27;&#125;)&#125;&gt;-&lt;/button&gt; &lt;/&gt; );&#125; Bailing out of a dispatch如果从 Reducer Hook 返回与当前状态相同的值，则 React 将不渲染子组件且不触发 effects。（React 使用Object.is 比较算法 。） 注意，React 可能仍需要在停止渲染子组件前再次渲染该组件。这不应该不是问题，因为 React 不会不必要地“深入”到子组件树中。如果你在渲染时进行了昂贵的计算，则可以使用 useMemo 对其进行优化。 useCallbackconst memoizedCallback = useCallback( () =&gt; &#123; doSomething(a, b); &#125;, [a, b],); 返回一个 memoized 的回调。 传递内联回调函数和数组依赖。useCallback 将返回一个回调函数的 memoized 版本，它只有在其中一个依赖项发生更改时才会更改。这非常有用，通过将回调传递给依赖引用相等性判断优化过的子组件，可以防止不必要的渲染（例如，shouldComponentUpdate）。 useCallback(fn, deps) 等同于 useMemo(() =&gt; fn, deps). Note 依赖的数组并不会作为参数传递给回调函数。虽然概念上，代表了这样的含义：回调函数中引用的每个值也应该出现在依赖项数组中。将来，一个足够先进的编译器可以自动创建这个数组。 我们建议使用 exhaustive-deps 规则作为 eslint-plugin-react-hooks 包的一部分。它会在错误地指定依赖项时发出警告并提供修复建议。 useMemoconst memoizedValue = useMemo(() =&gt; computeExpensiveValue(a, b), [a, b]); 返回一个 memoized 的值。 传递一个执行“创建”的函数和依赖的变量的数组。useMemo 只会在其中一个依赖的变量发生更改时重新计算 memoized的值。此优化有助于避免在每个渲染时进行昂贵的计算。 请记住，传递给 useMemo 的函数在渲染中运行。不要做那些在渲染时通常不会做的事情。例如，副作用通常属于useEffect，而不是useMemo。 如果未提供数组，则将在每次渲染是都会重新计算值。 你可以依赖 useMemo 作为性能优化，而不是语义保证。将来，React 可能会选择“忘记”一些以前记忆的值，并在下一次渲染时重新计算它们，例如为屏幕外组件释放内存。写代码时，确保在没有 useMemo 的情况下仍可正常工作 – 然后再考虑添加它优化性能。 Note 依赖的数组并不会作为参数传递给回调函数。虽然概念上，代表了这样的含义：回调函数中引用的每个值也应该出现在依赖项数组中。将来，一个足够先进的编译器可以自动创建这个数组。 我们建议使用 exhaustive-deps 规则作为 eslint-plugin-react-hooks 包的一部分。它会在错误地指定依赖项时发出警告并提供修复建议。 useRefconst refContainer = useRef(initialValue); useRef 返回一个可变的 ref 对象，其 .current 属性被初始化为传递的参数（initialValue）。返回的对象将持续整个组件的生命周期。 一个常见的用例是强行访问子组件对象： function TextInputWithFocusButton() &#123; const inputEl = useRef(null); const onButtonClick = () =&gt; &#123; // `current` points to the mounted text input element inputEl.current.focus(); &#125;; return ( &lt;&gt; &lt;input ref=&#123;inputEl&#125; type=&quot;text&quot; /&gt; &lt;button onClick=&#123;onButtonClick&#125;&gt;Focus the input&lt;/button&gt; &lt;/&gt; );&#125; 本质上，useRef 就像一个“盒子”，可以在其 .current 属性中保存一个可变值。 你可能了解 refs 主要是作为 访问 DOM 的一种方式。如果使用 &lt;div ref=&#123;myRef&#125; /&gt; 将 ref 对象传递给 React，只要该节点发生更改，React 就会将其 .current 属性设置为相应的DOM 节点。 但是， useRef() 比 ref 属性更有用。使用它随手保存任何可变值 与你在类中使用实例字段的方式类似，这很方便。 这样可以工作，因为 useRef() 创建了一个普通的 JavaScript 对象。 useRef() 与自己创建 &#123;current: ...&#125; 对象之间的唯一区别是 useRef 会在每次渲染时为你提供同一个 ref 对象。 请记住，useRef 在内容更改时不会通知你。.current 属性的改变不会导致重新渲染。如果要在 React 将引用附加到 DOM 节点或从 DOM 节点分离时运行某些代码，可使用callback ref替代。 useImperativeHandleuseImperativeHandle(ref, createHandle, [deps]) useImperativeHandle 自定义使用 ref 时公开给父组件的实例值。与以前一样，在大多数情况下应避免使用 refs 的命令式代码。useImperativeHandle 应与 forwardRef 一起使用： function FancyInput(props, ref) &#123; const inputRef = useRef(); useImperativeHandle(ref, () =&gt; (&#123; focus: () =&gt; &#123; inputRef.current.focus(); &#125; &#125;)); return &lt;input ref=&#123;inputRef&#125; ... /&gt;;&#125;FancyInput = forwardRef(FancyInput); 在这个例子里，渲染了 &lt;FancyInput ref=&#123;fancyInputRef&#125; /&gt; 的父组件能够调用 fancyInputRef.current.focus() 。 useLayoutEffect签名与 useEffect 相同，但在所有 DOM 突变后会同步触发。使用它从 DOM 读取布局并同步重新渲染，在 useLayoutEffect 内部计划的更新将在浏览器有机会重绘前同步刷新到屏幕。 如果可能的话，首选标准的 useEffect 以避免阻塞视觉更新。 Tip 如果要从类组件迁移代码，请注意 useLayoutEffect 在与 componentDidMount 和 componentDidUpdate 相同的阶段触发。但是，**我们建议优先使用 useEffect **，只在 useEffect 导致问题时，尝试使用 useLayoutEffect。 如果使用服务端渲染，记住，在下载完 JavaScript 前，useLayoutEffect 和 useEffect 都不能运行。这就是 React 在服务器渲染的组件包含 useLayoutEffect 时会发出警告。要解决这个问题，要么将该逻辑移动到useEffect（如果是首次渲染则不需要），要么延迟显示该组件直到客户端渲染后（如果 useLayoutEffect 运行时， HTML 看起来不正常）。 要从服务器呈现的 HTML 中排除需要布局效果的组件，请使用 showChild &amp;&amp; &lt;Child /&gt; 来条件地渲染它，并使用 useEffect(() =&gt; &#123; setShowChild(true); &#125;, []) 延迟显示。这样，UI 不会出现展示错误。 useDebugValueuseDebugValue(value) useDebugValue 可用于在 React DevTools 中显示自定义挂钩的标签。 例如，在“构建自己的Hooks”中描述的 useFriendStatus 的自定义 Hook： function useFriendStatus(friendID) &#123; const [isOnline, setIsOnline] = useState(null); // ... // Show a label in DevTools next to this Hook // e.g. &quot;FriendStatus: Online&quot; useDebugValue(isOnline ? &#x27;Online&#x27; : &#x27;Offline&#x27;); return isOnline;&#125; Tip 我们不建议将调试值添加到每个自定义 Hook。它对于作为共享库中的一部分的自定义 Hook 最有价值。 Defer formatting debug values推迟格式化调试值 在某些情况下，格式化显示值可能是昂贵的操作。除非检查 Hook，否则没有必要。 因此，useDebugValue 接受格式化函数作为可选的第二个参数。只有在检查 Hooks 时才会调用此功能。它接收调试值作为参数，并应返回格式化后的显示值。 例如，返回 Date 值的自定义 Hook 可以通过传入以下格式化程序来避免不必要地调用 toDateString 函数： useDebugValue(date, date =&gt; date.toDateString());","categories":[{"name":"翻译","slug":"翻译","permalink":"http://tcatche.site/categories/%E7%BF%BB%E8%AF%91/"}],"tags":[{"name":"react","slug":"react","permalink":"http://tcatche.site/tags/react/"},{"name":"翻译","slug":"翻译","permalink":"http://tcatche.site/tags/%E7%BF%BB%E8%AF%91/"},{"name":"hooks","slug":"hooks","permalink":"http://tcatche.site/tags/hooks/"}]},{"title":"React Hooks 文档翻译 - 6 - Building Your Own Hooks（建立你自己的 Hooks）","slug":"react-hooks-custom","date":"2019-04-08T04:02:00.000Z","updated":"2020-07-22T02:19:40.199Z","comments":true,"path":"2019/04/react-hooks-custom/","link":"","permalink":"http://tcatche.site/2019/04/react-hooks-custom/","excerpt":"","text":"翻译自：https://reactjs.org/docs/hooks-custom.html Hooks 是 React 16.8 新增的功能。它允许你在不编写类的情况下使用状态和其他 React 特性。 构建你自己的 Hooks 可以将组件逻辑提取到可重用的函数中。 我们在学习 Effect Hook 时，在聊天应用程序中看到过这个组件，该组件显示一条指示朋友是在线还是离线消息： import &#123; useState, useEffect &#125; from &#x27;react&#x27;;function FriendStatus(props) &#123; const [isOnline, setIsOnline] = useState(null); function handleStatusChange(status) &#123; setIsOnline(status.isOnline); &#125; useEffect(() =&gt; &#123; ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange); return () =&gt; &#123; ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange); &#125;; &#125;); if (isOnline === null) &#123; return &#x27;Loading...&#x27;; &#125; return isOnline ? &#x27;Online&#x27; : &#x27;Offline&#x27;;&#125; 现在，假如我们的聊天应用程序也有一个联系人列表，想要呈现绿色的在线用户名。我们可以将上面类似的逻辑复制粘贴到 FriendListItem 组件中，但这样并不理想： import &#123; useState, useEffect &#125; from &#x27;react&#x27;;function FriendListItem(props) &#123; const [isOnline, setIsOnline] = useState(null); function handleStatusChange(status) &#123; setIsOnline(status.isOnline); &#125; useEffect(() =&gt; &#123; ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange); return () =&gt; &#123; ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange); &#125;; &#125;); return ( &lt;li style=&#123; &#123; color: isOnline ? &#x27;green&#x27; : &#x27;black&#x27; &#125; &#125;&gt; &#123;props.friend.name&#125; &lt;/li&gt; );&#125; 相反，我们更想在 FriendStatus 和 FriendListItem 之间分享这个逻辑。 传统上，在 React 中，有两种流行的方式来共享组件之间的状态逻辑：渲染 props和高阶组件。我们来看看 Hook 如何在不强迫你在组件树中添加更多组件的情况下解决同样的问题。 Extracting a Custom Hook提取自定义 Hook 当我们想要在两个 JavaScript 函数之间共享逻辑时，我们将它提取到第三个函数。组件和 Hooks 都是函数，所以这一点也适用于它们！ 自定义 Hook 是一个 JavaScript 名字以“use”开头函数，并且可以调用其他的 Hooks。 例如，下面的 useFriendStatus 是我们的第一个自定义 Hook： import &#123; useState, useEffect &#125; from &#x27;react&#x27;;function useFriendStatus(friendID) &#123; const [isOnline, setIsOnline] = useState(null); function handleStatusChange(status) &#123; setIsOnline(status.isOnline); &#125; useEffect(() =&gt; &#123; ChatAPI.subscribeToFriendStatus(friendID, handleStatusChange); return () =&gt; &#123; ChatAPI.unsubscribeFromFriendStatus(friendID, handleStatusChange); &#125;; &#125;); return isOnline;&#125; 里面没有任何新内容 – 逻辑是从上面的组件中复制的。就像在组件中使用 Hooks 的限制，确保自定义的 Hooks 只在顶层非条件性地调用其他的 Hooks。 与 React 组件不同，自定义 Hook 不需要具有特定签名。我们可以自由地决定它需要什么参数，以及它返回什么（如果有返回的话）。换句话说，它就像一个普通的函数。它的名字应始终以 use 开始，这样你就可以一眼就看出适用于它的 钩子的规则。 我们使用 FriendStatus Hook 的目的是订阅朋友的状态。这就是为什么它将 friendID 作为参数，并返回此朋友是否在线： function useFriendStatus(friendID) &#123; const [isOnline, setIsOnline] = useState(null); // ... return isOnline;&#125; 现在来看看怎么使用我们自定义的 Hook。 Using a Custom Hook使用自定义的 Hook 最初，我们的目标是从 FriendStatus 和 FriendListItem 组件中删除重复的逻辑。它们都想知道朋友是否在线。 现在我们已经将这个逻辑提取到 useFriendStatus hook 里，我们可以直接使用它： function FriendStatus(props) &#123; const isOnline = useFriendStatus(props.friend.id); if (isOnline === null) &#123; return &#x27;Loading...&#x27;; &#125; return isOnline ? &#x27;Online&#x27; : &#x27;Offline&#x27;;&#125; function FriendListItem(props) &#123; const isOnline = useFriendStatus(props.friend.id); return ( &lt;li style=&#123; &#123; color: isOnline ? &#x27;green&#x27; : &#x27;black&#x27; &#125; &#125;&gt; &#123;props.friend.name&#125; &lt;/li&gt; );&#125; 这段代码是否等同于原始示例？ 是的，它以完全相同的方式工作。如果你仔细观察，你会注意到我们没有对行为做任何改变。我们所做的只是将两个函数之间的一些公共代码提取到一个单独的函数中。自定义 Hooks 是自然地遵循 Hooks 设计的约定，而不是一个新的 React 功能。 我是否必须以“use”开头命名我的自定义 Hook？ 请这样做。这个约定非常重要。没有它，我们将无法自动检查是否违反了 Hook 规则，因为我们无法判断某个函数是否在内部包含对 Hooks 的调用。 使用相同的 Hook 的两个组件共享同一个状态吗？ 并不是。自定义 Hooks 是一种重用有状态逻辑的机制（例如设置订阅和记住当前值），但每次使用自定义 Hooks 时，其中的所有 state 和 effects 都是完全隔离的。 自定义 Hook 如何获得被隔离的状态？ 每次对 Hooks 的调用都会获得隔离的 state。因为我们直接调用了 useFriendStatus，从 React 的角度来看，我们的组件只是调用了 useState 和 useEffect 。正如我们之前所了解的，我们可以在一个组件中多次调用 useState 和 useEffect ，它们将完全独立。 Tip: Pass Information Between Hooks提示：在 Hooks 之间传递信息 由于 Hooks 是函数，我们可以在它们之间传递信息。 To illustrate this, we’ll use another component from our hypothetical chat example. This is a chat message recipient picker that displays whether the currently selected friend is online: 为了说明这一点，我们将使用聊天示例中的另一个组件。这是一个聊天消息收件人选择器，显示当前所选朋友是否在线： const friendList = [ &#123; id: 1, name: &#x27;Phoebe&#x27; &#125;, &#123; id: 2, name: &#x27;Rachel&#x27; &#125;, &#123; id: 3, name: &#x27;Ross&#x27; &#125;,];function ChatRecipientPicker() &#123; const [recipientID, setRecipientID] = useState(1); const isRecipientOnline = useFriendStatus(recipientID); return ( &lt;&gt; &lt;Circle color=&#123;isRecipientOnline ? &#x27;green&#x27; : &#x27;red&#x27;&#125; /&gt; &lt;select value=&#123;recipientID&#125; onChange=&#123;e =&gt; setRecipientID(Number(e.target.value))&#125; &gt; &#123;friendList.map(friend =&gt; ( &lt;option key=&#123;friend.id&#125; value=&#123;friend.id&#125;&gt; &#123;friend.name&#125; &lt;/option&gt; ))&#125; &lt;/select&gt; &lt;/&gt; );&#125; 我们将当前选择的朋友的 ID 保存在 recipientID 状态变量中，如果用户在 &lt;select&gt; 选择器中选择其他朋友，则更新它。 因为 useState Hook 的调用提供了 recipientID 状态变量的最新值，所以我们可以将它作为参数传递给自定义的 useFriendStatus Hook： const [recipientID, setRecipientID] = useState(1);const isRecipientOnline = useFriendStatus(recipientID); 这让我们知道当前选择的朋友是否在线。如果我们选择其他朋友并更新了 recipientID 状态变量，useFriendStatus Hook 将取消订阅之前选择的朋友，并订阅新选择的朋友的状态。 useYourImagination()Custom Hooks 提供了以前在 React 组件中无法实现的共享逻辑的灵活性。你可以编写自定义 Hook，涵盖广泛的用例，如表单处理，动画，声明订阅，计时器，以及可能还有更多我们没有想过的。更重要的是，你可以构建像 React 内置功能一样易于使用的 Hook。 尽量避免过早添加抽象。既然函数组件可以做得更多，那么代码库中的函数组件平均长度可能会变得更长。这是正常的 – 不要觉得你必须将它们拆分到多个 Hooks。但我们也鼓励你开始了解自定义 Hook 可以隐藏简单接口背后的复杂逻辑，这或有助于解开混乱组件的情况。 例如，你可能有一个复杂的组件，其中包含许多以 ad-hoc 的方式管理的本地状态。useState 不会使更新逻辑更容易集中化，因此你可能希望将其编写为 Redux reducer ： function todosReducer(state, action) &#123; switch (action.type) &#123; case &#x27;add&#x27;: return [...state, &#123; text: action.text, completed: false &#125;]; // ... other actions ... default: return state; &#125;&#125; Reducers 非常便于单独测试，并且可以扩展以表达复杂的更新逻辑。如有必要，你可以将它们分成更小的 reducers 。但是，你可能享受使用 React 本地状态的好处，或者可能不想安装其他库。 那么，如果我们可以写一个 useReducer Hook，让我们用 reducer 管理组件的本地状态呢？它的简化版本可能如下所示： function useReducer(reducer, initialState) &#123; const [state, setState] = useState(initialState); function dispatch(action) &#123; const nextState = reducer(state, action); setState(nextState); &#125; return [state, dispatch];&#125; 现在我们可以在组件中使用它，让 reducer 驱动它的状态管理： function Todos() &#123; const [todos, dispatch] = useReducer(todosReducer, []); function handleAddClick(text) &#123; dispatch(&#123; type: &#x27;add&#x27;, text &#125;); &#125; // ...&#125; 在复杂组件中使用 reducer 管理本地状态的需求很常见，我们已经将 useReducer Hook 构建到 React中。你可以在 Hooks API 参考 中找到它与其他内置 Hook。","categories":[{"name":"翻译","slug":"翻译","permalink":"http://tcatche.site/categories/%E7%BF%BB%E8%AF%91/"}],"tags":[{"name":"react","slug":"react","permalink":"http://tcatche.site/tags/react/"},{"name":"翻译","slug":"翻译","permalink":"http://tcatche.site/tags/%E7%BF%BB%E8%AF%91/"},{"name":"hooks","slug":"hooks","permalink":"http://tcatche.site/tags/hooks/"}]},{"title":"React Hooks 文档翻译 - 5 - Rules of Hooks（Hooks 的使用规则）","slug":"react-hooks-rules","date":"2019-04-08T03:28:00.000Z","updated":"2019-04-28T07:55:24.000Z","comments":true,"path":"2019/04/react-hooks-rules/","link":"","permalink":"http://tcatche.site/2019/04/react-hooks-rules/","excerpt":"","text":"翻译自：https://reactjs.org/docs/hooks-rules.html Hooks 是 React 16.8 新增的功能。它允许你在不编写类的情况下使用状态和其他 React 特性。 Hooks 是 JavaScript 函数，但在使用时需要遵循两个规则。我们提供了一个linter 插件 来自动检查这些规则： Only Call Hooks at the Top Level只在顶层调用 Hooks 不要在循环语句，条件语句或嵌套函数中调用 Hook。而是在 React 函数的顶层使用 Hooks。遵循此规则，可以确保组件每次渲染时都以相同的顺序调用 Hook。这是 React 能够在多次的 useState 和 useEffect 调用后正确保留 Hooks 状态的原因。（如果你很好奇这是为什么，我们将在后面深入解释。） Only Call Hooks from React Functions只在 React 函数组件中调用 Hooks 不要在普通的 JavaScript 函数中调用 Hooks。 相反，你可以： 在 React 函数组件中调用 Hooks。 在自定义的 Hooks 中调用 Hooks（我们将在下一页了解它们）。 遵循这两条规则，可以确保组件中的所有的状态逻辑在源码中很清晰。 ESLint Plugin我们发布了一个名为 eslint-plugin-react-hooks 的 ESLint 插件，来强制执行这两个规则。如果你想尝试，可以添加到项目中： npm install eslint-plugin-react-hooks@next // Your ESLint configuration&#123; &quot;plugins&quot;: [ // ... &quot;react-hooks&quot; ], &quot;rules&quot;: &#123; // ... &quot;react-hooks/rules-of-hooks&quot;: &quot;error&quot; &#125;&#125; 将来，我们打算将此插件包含在 Create React App 和类似的脚手架中。 你可以直接跳到下一页，查看如何编写自己的 Hooks。 我们将在本文继续解释这些规则背后的原因。 Explanation如前文所述，我们可以在一个组件中使用多个 State 或 Effect Hook： function Form() &#123; // 1. Use the name state variable const [name, setName] = useState(&#x27;Mary&#x27;); // 2. Use an effect for persisting the form useEffect(function persistForm() &#123; localStorage.setItem(&#x27;formData&#x27;, name); &#125;); // 3. Use the surname state variable const [surname, setSurname] = useState(&#x27;Poppins&#x27;); // 4. Use an effect for updating the title useEffect(function updateTitle() &#123; document.title = name + &#x27; &#x27; + surname; &#125;); // ...&#125; 那么 React 如何知道哪个状态对应于哪个 useState 的调用？答案是** React 依赖于调用 Hooks 的顺序。 **我们的示例之所以可以工作，因为 Hooks 被调用的顺序在每次渲染都是相同的： // ------------// First render// ------------useState(&#x27;Mary&#x27;) // 1. Initialize the name state variable with &#x27;Mary&#x27;useEffect(persistForm) // 2. Add an effect for persisting the formuseState(&#x27;Poppins&#x27;) // 3. Initialize the surname state variable with &#x27;Poppins&#x27;useEffect(updateTitle) // 4. Add an effect for updating the title// -------------// Second render// -------------useState(&#x27;Mary&#x27;) // 1. Read the name state variable (argument is ignored)useEffect(persistForm) // 2. Replace the effect for persisting the formuseState(&#x27;Poppins&#x27;) // 3. Read the surname state variable (argument is ignored)useEffect(updateTitle) // 4. Replace the effect for updating the title// ... 只要 Hooks 调用的顺序在多次渲染时都是相同的，React 就可以将其本地状态与它们关联起来。但是如果我们在条件语句中调用 Hook （例如，persistForm effect）会发生什么？ // 🔴 We&#x27;re breaking the first rule by using a Hook in a conditionif (name !== &#x27;&#x27;) &#123; useEffect(function persistForm() &#123; localStorage.setItem(&#x27;formData&#x27;, name); &#125;);&#125; 条件 name !== &#39;&#39; 在第一次渲染时为 true，因此运行此 Hook。但是，在下一次渲染时，用户可能会清除表单，使条件值为 false 。此时的渲染过程中将跳过此 Hook，Hooks 被调用的顺序将变得和之前不同： useState(&#x27;Mary&#x27;) // 1. Read the name state variable (argument is ignored)// useEffect(persistForm) // 🔴 This Hook was skipped!useState(&#x27;Poppins&#x27;) // 🔴 2 (but was 3). Fail to read the surname state variableuseEffect(updateTitle) // 🔴 3 (but was 4). Fail to replace the effect React 不知道第二个 useState Hook调用返回什么。React 期望此组件中的第二个 Hook 对应 persistForm effect，就像上次渲染时一样，但它已不再存在。此时，在我们跳过的 Hook 之后的每个 Hook 调用也被移动，结果导致错误。 这就是必须在我们组件的顶层调用 Hooks 的原因。如果想要在条件语句下运行一个 effect，可以把这个条件放在 Hook 中： useEffect(function persistForm() &#123; // 👍 We&#x27;re not breaking the first rule anymore if (name !== &#x27;&#x27;) &#123; localStorage.setItem(&#x27;formData&#x27;, name); &#125;&#125;); 请注意，如果使用了提供的 lint 规则，则无需担心此问题。 不过现在你知道了为什么 Hooks 以这种方式工作，以及这些规则可以阻止了哪些问题。 Next StepsFinally, we’re ready to learn about writing your own Hooks! Custom Hooks let you combine Hooks provided by React into your own abstractions, and reuse common stateful logic between different components. 最后，我们已经准备好去了解编写自己的Hooks！Custom Hooks 允许你将 React 提供的 Hooks 组合到你的抽象中，并在不同组件之间重用常见的状态逻辑。","categories":[{"name":"翻译","slug":"翻译","permalink":"http://tcatche.site/categories/%E7%BF%BB%E8%AF%91/"}],"tags":[{"name":"react","slug":"react","permalink":"http://tcatche.site/tags/react/"},{"name":"翻译","slug":"翻译","permalink":"http://tcatche.site/tags/%E7%BF%BB%E8%AF%91/"},{"name":"hooks","slug":"hooks","permalink":"http://tcatche.site/tags/hooks/"}]},{"title":"React Hooks 文档翻译 - 4 - Using the Effect Hook（使用 Effect Hook）","slug":"react-hooks-effect","date":"2019-04-04T09:02:00.000Z","updated":"2019-04-28T07:55:06.000Z","comments":true,"path":"2019/04/react-hooks-effect/","link":"","permalink":"http://tcatche.site/2019/04/react-hooks-effect/","excerpt":"","text":"翻译自：https://reactjs.org/docs/hooks-effects.html Hooks 是 React 16.8 新增的功能。它允许你在不编写类的情况下使用状态和其他 React 特性。 The Effect Hook lets you perform side effects in function components: Effect Hook 用来在函数组件中处理副作用： import &#123; useState, useEffect &#125; from &#x27;react&#x27;;function Example() &#123; const [count, setCount] = useState(0); // Similar to componentDidMount and componentDidUpdate: useEffect(() =&gt; &#123; // Update the document title using the browser API document.title = `You clicked $&#123;count&#125; times`; &#125;); return ( &lt;div&gt; &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt; &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt; Click me &lt;/button&gt; &lt;/div&gt; );&#125; 此代码段基于上一节的计数器示例 ，但添加了一项新功能：将文档标题设置为包含点击次数的自定义信息。 在 React 组件中执行数据获取，设置订阅以及手动更改 DOM 都是常见的副作用。不管你是否习惯于将这些操作称为“副作用”（或“effects”），你之前可能已经在组件中执行过这类操作。 Tip 如果你很熟悉 React 的类生命周期方法，则可以将 useEffect Hook 看做 componentDidMount， componentDidUpdate 和 componentWillUnmount 的组合。 React 组件中有两种常见的副作用：不需要清理的副作用，以及需要清理的副作用。我们来详细地看一下它们的区别。 Effects Without Cleanup不需要清理的副作用 有时，我们希望在 React 更新 DOM 之后执行一些额外的操作。常见的不需要清理的副作用有网络请求，手动修改 DOM 和记录日志等。之所以这样说是因为可以直接运行它们并忘记它们。我们来比较下类组件和 Hooks 是如何处理这样的副作用。 Example Using Classes使用类的示例 在 React 类组件中，render 方法本身不应该执行副作用。这里太早了 – 我们通常希望在 React 更新 DOM 之后执行我们的 effect 。 这就是为什么在 React 类中，把副作用放入 componentDidMount 和 componentDidUpdate 中。回到示例来看，下面是一个 React 计数器类组件，它在 React 对 DOM 进行更改后立即更新文档标题： class Example extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; count: 0 &#125;; &#125; componentDidMount() &#123; document.title = `You clicked $&#123;this.state.count&#125; times`; &#125; componentDidUpdate() &#123; document.title = `You clicked $&#123;this.state.count&#125; times`; &#125; render() &#123; return ( &lt;div&gt; &lt;p&gt;You clicked &#123;this.state.count&#125; times&lt;/p&gt; &lt;button onClick=&#123;() =&gt; this.setState(&#123; count: this.state.count + 1 &#125;)&#125;&gt; Click me &lt;/button&gt; &lt;/div&gt; ); &#125;&#125; 注意看，我们不得不在类的两个生命周期方法里重复类似的代码。 这是因为在许多情况下，我们想要执行同一个副作用，无论组件是在刚挂载还是已更新。从概念上讲，我们希望它在每次渲染后都被执行，但是 React 类组件没有这样的方法。虽然可以提取副作用到一个方法里，但是仍然需要在两个不同的地方调用它。 现在让我们看看如何使用 useEffect Hook 做同样的事情。 Example Using Hooks使用 Hooks 的示例 我们已经在本文开始看到过这个例子，再来看一下： import &#123; useState, useEffect &#125; from &#x27;react&#x27;;function Example() &#123; const [count, setCount] = useState(0); useEffect(() =&gt; &#123; document.title = `You clicked $&#123;count&#125; times`; &#125;); return ( &lt;div&gt; &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt; &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt; Click me &lt;/button&gt; &lt;/div&gt; );&#125; useEffect 做了什么？通过它，你告诉 React 你的组件需要在渲染后执行某些操作。React 将记住你传递的函数（我们将其称为“effect”），并在 DOM 更新后调用它。在这个 effect 中，我们设置了文档标题，还可以执行数据获取或调用其他的命令式 API。 为什么在组件内调用 useEffect？在组件内放置 useEffect 可以从 effect 中直接访问 count 状态变量（或其它 props）。这样就不需要新的特殊的 API 来读取它们，因为它们已经在函数范围内了。Hooks 拥抱 JavaScript 闭包，并避免在 JavaScript 已经提供解决方案的情况下引入新的 API。 每次渲染后 useEffect 都会运行吗？默认情况下答案是“是的”!它在第一次渲染后以及每次更新后都运行。（我们稍后将讨论如何自定义它。）可能你会发现 effect 发生在“渲染后”，与“挂载”和“更新”后相比更有助于理解。React 保证 DOM 在执行 effects 时已更新 DOM。 Detailed Explanation详细解释 现在我们已经更了解 effect ，下面的代码应该很容易理解： function Example() &#123; const [count, setCount] = useState(0); useEffect(() =&gt; &#123; document.title = `You clicked $&#123;count&#125; times`; &#125;); 我们声明了 count 的状态变量，然后告诉 React 我们需要使用一个 effect 。并将一个函数传递给 useEffect Hook。所传递的这个函数就是 effect。在 effect 中，使用了浏览器的 document.title API 设置文档标题。我们可以在 effect 中读取最新的 count 值，因为它在组件的函数作用域内。当 React 渲染我们的组件时，它会记住使用的 effect，然后在更新 DOM 后运行 effect 。这种情况在每次渲染后都会发生，包括第一次渲染。 有经验的 JavaScript 开发人员可能会注意到，传递给 useEffect 的函数在每次渲染时都是不同的。这是故意这样做的。事实上，这是从 effect 中读取 count 值而不用担心它失效的原因。每次重新渲染时，都会使用一个不同的 effect ，取代之前的。这样，effect 看起来更像是渲染结果的一部分 – 每个 effect “属于”特定的某次渲染。我们将在本页后面看到为什么这很有用。 Tip 与 componentDidMount 或 componentDidUpdate 不同，使用 useEffect 调度的 effects 不会阻止浏览器更新屏，这使你的应用更具响应性。大多数 effect 并不需要被同步执行。当然，对于不常见的需要同步执行的情况（例如测量布局），有一个单独的 useLayoutEffect Hook，它的 API 与 useEffect 相同。 Effects with Cleanup带清理的 Effects 之前，我们看了如何编写不需要任何清理的副作用的代码。但是，有些 effect 会需要执行清理操作。例如，我们可能想设置对某些外部数据源的订阅。 在这种情况下，清理是非常重要的，这样就可以确保不会引入内存泄漏！接下来比较下如何在类和 Hooks 中实现这类副作用。 Example Using Classes使用类的示例 在 React 类中，通常在 componentDidMount 中设置订阅，并在 componentWillUnmount 中取消订阅。例如，假设我们有一个 ChatAPI 模块，可以订阅朋友的在线状态。下面是在类中使用订阅和显示此状态的示例： class FriendStatus extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; isOnline: null &#125;; this.handleStatusChange = this.handleStatusChange.bind(this); &#125; componentDidMount() &#123; ChatAPI.subscribeToFriendStatus( this.props.friend.id, this.handleStatusChange ); &#125; componentWillUnmount() &#123; ChatAPI.unsubscribeFromFriendStatus( this.props.friend.id, this.handleStatusChange ); &#125; handleStatusChange(status) &#123; this.setState(&#123; isOnline: status.isOnline &#125;); &#125; render() &#123; if (this.state.isOnline === null) &#123; return &#x27;Loading...&#x27;; &#125; return this.state.isOnline ? &#x27;Online&#x27; : &#x27;Offline&#x27;; &#125;&#125; Notice how componentDidMount and componentWillUnmount need to mirror each other. Lifecycle methods force us to split this logic even though conceptually code in both of them is related to the same effect. 请注意 componentDidMount 和 componentWillUnmount 如何成对地使用。生命周期方法迫使我们不得不拆分这个订阅逻辑，即使它们内部的代码都与同一副作用有关。 Note 眼尖的读者可能会注意到这个例子还需要一个 componentDidUpdate 方法才完全正确。我们暂时忽略这一点，在本文的后面部分再来讨论它。 Example Using Hooks使用 Hooks 的示例 来看看使用 Hooks 如何编写这个组件。 你可能认为需要单独的 effect 来执行清理。但是添加订阅和删除订阅的代码是紧密联系的，因此 useEffect 设计为将相关内容保持在同一地方。如果你的 effect 返回一个函数，React 将在清理时运行它： import &#123; useState, useEffect &#125; from &#x27;react&#x27;;function FriendStatus(props) &#123; const [isOnline, setIsOnline] = useState(null); function handleStatusChange(status) &#123; setIsOnline(status.isOnline); &#125; useEffect(() =&gt; &#123; ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange); // Specify how to clean up after this effect: return function cleanup() &#123; ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange); &#125;; &#125;); if (isOnline === null) &#123; return &#x27;Loading...&#x27;; &#125; return isOnline ? &#x27;Online&#x27; : &#x27;Offline&#x27;;&#125; 为什么从 effect 中返回一个函数？ 这是 effect 的可选的清理机制。每个 effect 都可以返回一个在它之后执行清理的函数。这让我们可以将相似的添加订阅和删除订阅的逻辑放在一起。它们是同一个 effect 的一部分！ React 什么时候清理 effect ？当组件卸载时，React 会执行清理。然而，如之前所了解的， effect 会在每个渲染后运行，而非仅运行一次。这就是为什么 React 还会在下次运行 effect 之前清除前一次渲染的 effect 的原因。稍后我们将讨论为什么这有助于避免错误 以及如何在发生性能问题时停止此类行为。 Note 不必从 effect 中返回命名函数。在这里称之为 cleanup 是为了解释其目的，你可以返回箭头函数或名字为其它的函数。 Recap我们已经了解 useEffect 可以在组件渲染后执行不同类型的副作用。有些 effects 可能需要清理，则它们需要返回一个清理函数： useEffect(() =&gt; &#123; ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange); return () =&gt; &#123; ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange); &#125;;&#125;); 其它 effects 不需要清理阶段，因此不必返回任何内容。 useEffect(() =&gt; &#123; document.title = `You clicked $&#123;count&#125; times`;&#125;); Effect Hook 将两种用例统一到一个 API 中。 如果你对 Effect Hook 的工作方式已经有了很好的把握，又或者你感到不知所措，那么现在就可以跳转到下一页的 Hooks 规则 Tips for Using Effects使用 effect 的几点提示 我们继续深入了解 React 用户可能会对 useEffect 产生好奇心的其他内容。当然，你不必现在就深入了解它们。你可以随时返回此页面来了解有关 effect hook 的更多详细信息。 Tip: Use Multiple Effects to Separate Concerns提示：使用多个 effect 来分离问题 我们在 Hooks 的 Motivation 中列出的一个问题是类生命周期方法通常包含不相关的逻辑，而相关的逻辑被分离到几个生命周期方法中。下面组件混合了前面示例中的计数器和朋友状态指示器的逻辑： class FriendStatusWithCounter extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; count: 0, isOnline: null &#125;; this.handleStatusChange = this.handleStatusChange.bind(this); &#125; componentDidMount() &#123; document.title = `You clicked $&#123;this.state.count&#125; times`; ChatAPI.subscribeToFriendStatus( this.props.friend.id, this.handleStatusChange ); &#125; componentDidUpdate() &#123; document.title = `You clicked $&#123;this.state.count&#125; times`; &#125; componentWillUnmount() &#123; ChatAPI.unsubscribeFromFriendStatus( this.props.friend.id, this.handleStatusChange ); &#125; handleStatusChange(status) &#123; this.setState(&#123; isOnline: status.isOnline &#125;); &#125; // ... 请注意设置 document.title 的逻辑是怎么拆分到 componentDidMount 和 componentDidUpdate 两个方法中。而订阅逻辑也分布在 componentDidMount 和 componentWillUnmount 中。componentDidMount 包含了两个任务的代码。 那么，Hooks 如何解决这个问题呢？像你可以多次使用State Hook所说，你可以使用多个 effects，将不相关的逻辑拆分到不同的 effects 中 ： function FriendStatusWithCounter(props) &#123; const [count, setCount] = useState(0); useEffect(() =&gt; &#123; document.title = `You clicked $&#123;count&#125; times`; &#125;); const [isOnline, setIsOnline] = useState(null); useEffect(() =&gt; &#123; ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange); return () =&gt; &#123; ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange); &#125;; &#125;); function handleStatusChange(status) &#123; setIsOnline(status.isOnline); &#125; // ...&#125; Hooks 允许我们根据它执行的操作来拆分代码而不是根据生命周期方法进行拆分。React 将按照 effects 声明的顺序调用组件的每个 effect 。 Explanation: Why Effects Run on Each Update解释：为什么每次更新都运行 Effects 如果经常使用类，你可能想知道为什么 effect 的清理工作在每次重新渲染后都会发生，而不是在组件卸载中只执行一次。来看一个实际的例子，解释为什么这个设计有助于减少 bug。 在本页前面，介绍了一个 FriendStatus 组件的例子，该组件显示朋友是否在线。我们的类从 this.props 读取 friend.id ，在组件挂载后订阅朋友状态，并在组件卸载时取消订阅： componentDidMount() &#123; ChatAPI.subscribeToFriendStatus( this.props.friend.id, this.handleStatusChange );&#125;componentWillUnmount() &#123; ChatAPI.unsubscribeFromFriendStatus( this.props.friend.id, this.handleStatusChange );&#125; 但是如果 friend 这个 prop 在组件已经渲染到屏幕上时发生了变化，会发生什么？我们的组件将显示其它朋友的在线状态，这种显示是错误的。而且，卸载时还会导致内存泄漏或崩溃，因为取消订阅会使用错误的朋友 ID。 在类组件中，需要添加 componentDidUpdate 来处理这种情况： componentDidMount() &#123; ChatAPI.subscribeToFriendStatus( this.props.friend.id, this.handleStatusChange );&#125;componentDidUpdate(prevProps) &#123; // Unsubscribe from the previous friend.id // 取消订阅前一个 friend.id 的在线状态 ChatAPI.unsubscribeFromFriendStatus( prevProps.friend.id, this.handleStatusChange ); // Subscribe to the next friend.id // 订阅新的 friend.id 的在线状态 ChatAPI.subscribeToFriendStatus( this.props.friend.id, this.handleStatusChange );&#125;componentWillUnmount() &#123; ChatAPI.unsubscribeFromFriendStatus( this.props.friend.id, this.handleStatusChange );&#125; 忘了处理 componentDidUpdate 也是 React 应用程序常见的错误。 现在来看这个组件的 Hooks 版本： function FriendStatus(props) &#123; // ... useEffect(() =&gt; &#123; ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange); return () =&gt; &#123; ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange); &#125;; &#125;); 它不会受到这个 bug 的影响。（而且我们也没有对它做任何改动。） 没有处理更新的特殊代码，因为在默认的情况下 useEffect 会自动去处理它们。它会在应用新的 effects 前清除之前的 effects 。为了说明这一点，这里展示了一个组件随着时间的推移产生的订阅和取消订阅的调用序列： // Mount with &#123; friend: &#123; id: 100 &#125; &#125; propsChatAPI.subscribeToFriendStatus(100, handleStatusChange); // Run first effect// Update with &#123; friend: &#123; id: 200 &#125; &#125; propsChatAPI.unsubscribeFromFriendStatus(100, handleStatusChange); // Clean up previous effectChatAPI.subscribeToFriendStatus(200, handleStatusChange); // Run next effect// Update with &#123; friend: &#123; id: 300 &#125; &#125; propsChatAPI.unsubscribeFromFriendStatus(200, handleStatusChange); // Clean up previous effectChatAPI.subscribeToFriendStatus(300, handleStatusChange); // Run next effect// UnmountChatAPI.unsubscribeFromFriendStatus(300, handleStatusChange); // Clean up last effect 这种默认的行为确保了组件的一致性，并可以防止类组件中常见的由于缺少更新后逻辑而发生的错误。 Tip: Optimizing Performance by Skipping Effects提示：跳过 effects 来优化性能 对于有些场景，每次渲染后清理或执行 effects 可能会产生性能问题。在类组件中，可以在 componentDidUpdate 中通过与 prevProps 或 prevState 比较来解决这个问题： componentDidUpdate(prevProps, prevState) &#123; if (prevState.count !== this.state.count) &#123; document.title = `You clicked $&#123;this.state.count&#125; times`; &#125;&#125; 这个需求很常见，它被内置到 useEffect Hook 的 API 中。如果在重新渲染中没有更改某些值，则可以告诉 React 跳过执行 effect 。如果想要跳过，为 useEffect 可选的第二个参数传入数组： useEffect(() =&gt; &#123; document.title = `You clicked $&#123;count&#125; times`;&#125;, [count]); // Only re-run the effect if count changes 在上面的例子中，将 [count] 作为第二个参数传递给 effect。这有什么用呢？如果 count 值之前为 5，然后在组件重新渲染时 count 仍然等于 5，则 React 将比较前一个渲染的 [5] 和这次渲染的 [5]。因为数组中的所有项都是相同的（5 === 5），所以 React 会跳过执行这个 effect 。这就是我们说的优化。 当我们渲染时 count 值更新为 6 ，React 会将前一渲染中数组中的项目 [5] 与下一渲染中数组中的项目 [6] 进行比较。这次，React 将重新应用 effect ，因为 5 !== 6 。如果数组中有多个元素，即使其中只有一个是不同的，React 也将继续运行 effect 。 这也适用于具有清理阶段的 effect： useEffect(() =&gt; &#123; ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange); return () =&gt; &#123; ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange); &#125;;&#125;, [props.friend.id]); // Only re-subscribe if props.friend.id changes 将来，第二个参数可能会通过构建时变成自动添加。 Note 如果使用此优化，请确保该数组包含任意在外部作用域中 effect 使用了且随时间变化的值。否则，你的代码将引用之前渲染中的陈旧值。我们还将在Hooks API参考中讨论其他优化选项。 如果要运行 effect 并清理仅一次（在装载和卸载时），则可以将空数组（[]）作为第二个参数传入。这将告诉 React 你的 effect 不依赖于来自 props 或 state 的任何值，它永远不需要重新运行。这不作为特殊情况处理 - 它直接遵循输入数组的工作方式。虽然传递 [] 更接近熟悉的 componentDidMount 和 componentWillUnmount 心理模型，但我们建议不要经常这样做，因为它经常会导致上面所述：为什么 Effects 每次更新都运行 的错误。不要忘记了 React 会推迟到浏览器绘制完成后才执行 useEffect ，所以进行额外的工作不是什么太大的问题。 Next Steps恭喜！这是一个很长的页面，希望现在你的大部分 effect 的问题都得到了回答。你已经学习了 State Hook 和 Effect Hook，你可以将两者结合起来做很多事情。它们涵盖了大多数类的用例 – 如果有没覆盖到的地方，你会发现有额外的 Hook 会很有帮助。 我们也开始看到 Hooks 如何解决 Motivation 中列出的问题。也看到了清理 effect 的代码如何避免在 componentDidUpdate 和 componentWillUnmount 中重复，使相关代码更加紧密，并帮助避免错误。还看到了如何根据目的分离 effect ，这是我们根本无法在类上做到的事情。 此时你可能会疑问 Hooks 是如何工作的。React 是如何知道哪个 useState 调用对应于重新渲染中的哪个状态变量？React如何“匹配”每次更新的上一个和下一个 effect ？在下一页，我们将了解Hooks 规则 – 它们对使 Hooks 工作非常重要。","categories":[{"name":"翻译","slug":"翻译","permalink":"http://tcatche.site/categories/%E7%BF%BB%E8%AF%91/"}],"tags":[{"name":"react","slug":"react","permalink":"http://tcatche.site/tags/react/"},{"name":"翻译","slug":"翻译","permalink":"http://tcatche.site/tags/%E7%BF%BB%E8%AF%91/"},{"name":"hooks","slug":"hooks","permalink":"http://tcatche.site/tags/hooks/"}]},{"title":"React Hooks 文档翻译 - 3 - Using the State Hook（使用状态 Hook）","slug":"react-hooks-state","date":"2019-04-03T09:52:00.000Z","updated":"2019-04-28T07:55:20.000Z","comments":true,"path":"2019/04/react-hooks-state/","link":"","permalink":"http://tcatche.site/2019/04/react-hooks-state/","excerpt":"","text":"翻译自：https://reactjs.org/docs/hooks-state.html Hooks 是 React 16.8 新增的功能。它允许你在不编写类的情况下使用状态和其他 React 特性。 上一篇文章使用了下面的示例介绍了 Hooks： import &#123; useState &#125; from &#x27;react&#x27;;function Example() &#123; // Declare a new state variable, which we&#x27;ll call &quot;count&quot; const [count, setCount] = useState(0); return ( &lt;div&gt; &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt; &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt; Click me &lt;/button&gt; &lt;/div&gt; );&#125; 我们将通过此代码与同样功能的类实现的代码进行比较来学习 Hooks。 Equivalent Class Example等效的类实现示例 如果你之前在 React 中使用过类，那么这段代码应该很熟悉： class Example extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; count: 0 &#125;; &#125; render() &#123; return ( &lt;div&gt; &lt;p&gt;You clicked &#123;this.state.count&#125; times&lt;/p&gt; &lt;button onClick=&#123;() =&gt; this.setState(&#123; count: this.state.count + 1 &#125;)&#125;&gt; Click me &lt;/button&gt; &lt;/div&gt; ); &#125;&#125; state 的初始状态为 &#123; count: 0 &#125; ，当用户单击按钮调用 this.setState() 时，会增加 state.count 。我们将在整个页面中使用此类的片段。 Note 你可能想知道为什么我们使用计数器而不是更真实的例子。这是为了我们在 Hooks 迈出第一步时能够更专注于API。 Hooks and Function ComponentsHooks 和函数组件 提醒一下，React 中的函数组件如下所示： const Example = (props) =&gt; &#123; // You can use Hooks here! return &lt;div /&gt;;&#125; 或者： function Example(props) &#123; // You can use Hooks here! return &lt;div /&gt;;&#125; 你可能以前称之为“无状态组件”。现在我们为它们引入了使用 React state 的能力，所以我们更喜欢“函数组件”的名称。 Hooks 在类里不起作用。你可以使用它们而不用再编写类组件。 What’s a Hook?什么是 Hooks？ 我们的新示例首先从 React 中引入 useState Hook： import &#123; useState &#125; from &#x27;react&#x27;;function Example() &#123; // ...&#125; 什么是 Hook？ Hook 是一种特殊功能，可以让你“挂钩到” React 的一些功能。例如，useState 就是一个 Hook，允许你将 React 的状态添加到函数组件。我们稍后会学习其他的 hooks。 我什么时候使用 Hook？ 如果你写了一个函数组件并意识到需要为它添加一些状态，如果在以前，你必须将它转换为一个类。现在，你可以在现有的函数组件中使用 Hook。就像我们现在这么做的！ Note: 关于在何处可以或者不可以使用 Hook ，有一些特殊规则。我们可以在Hooks 的规则中学习它们。 Declaring a State Variable声明一个状态变量 在类中，我们初始化 count 状态为 0 通过在构造器中设置 this.state 的值为 &#123; count: 0 &#125;。 class Example extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; count: 0 &#125;; &#125; 函数组件中没有 this ，因此，不能设置或者读取 this.state ，相反，我们直接在组件中调用 useState Hook。 import &#123; useState &#125; from &#x27;react&#x27;;function Example() &#123; // Declare a new state variable, which we&#x27;ll call &quot;count&quot; const [count, setCount] = useState(0); 调用 useState 做了什么？ 它声明了一个“状态变量”。我们的变量叫做 count ，也可以叫其他任何名字，比如 banana 。这是一种在函数调用间“保留”某些值的方法 – useState 是一种新方法，可以提供和类中 this.state 完全相同的功能。通常，当函数结束时变量“消失”但 React 可以为我们保留“状态变量”。 我们传递给 useState 的参数是什么？ useState() Hook 的唯一参数是初始状态值。与类不同，状态不必是对象。如果需要的话，可以设置为一个数字或字符串。在示例中，我们只需要一个数字来表示用户点击的次数，因此传入 0 作为变量的初始状态。（如果我们想在状态中存储两个不同的值，可以调用 useState() 两次。） useState 返回值是什么？ 它返回了一对值：当前状态值和更新状态值的函数。这就是我们写 const [count, setCount] = useState()。它与类中的 this.state.count 和 this.setState 类似，只不过它们是成对的。如果你不熟悉我们使用的方括号语法（即数组解构，译者注），我们将在本页底部回顾它。 现在，了解了 useState Hook的作用，我们的例子就更容易理解： import &#123; useState &#125; from &#x27;react&#x27;;function Example() &#123; // Declare a new state variable, which we&#x27;ll call &quot;count&quot; const [count, setCount] = useState(0); We declare a state variable called count, and set it to 0. React will remember its current value between re-renders, and provide the most recent one to our function. If we want to update the current count, we can call setCount. 我们声明一个名为 count 的状态变量，并将其设置为 0。 React 能记住它在多次渲染时的当前值，并为组件提供了最新的值。如果想要更新当前计数值 count ，可以调用 setCount。 Note 你可能想知道：为什么 useState 没有命名为 createState ？ “创建”不很准确，因为状态仅在组件首次渲染时创建。在下一次渲染时，useState 提供了当前的状态值，否则它根本不会是“状态”！Hooks 名称总是从使用开始也是有原因的。我们将在后面的 Hooks 的规则 中了解它。 Reading State读状态 当我们想要在类组件中显示当前计数时，通过 this.state.count 读取值： &lt;p&gt;You clicked &#123;this.state.count&#125; times&lt;/p&gt; 在函数组件中，可以直接使用 count ： &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt; Updating State更新状态 In a class, we need to call this.setState() to update the count state: 在类组件中，需要调用 this.setState() 来更新 count 状态值： &lt;button onClick=&#123;() =&gt; this.setState(&#123; count: this.state.count + 1 &#125;)&#125;&gt; Click me&lt;/button&gt; 在函数组件中，已经有了 setCount 和 count 变量，不需要再使用 this: &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt; Click me&lt;/button&gt; Recap概括 现在，我们通过下面代码逐行概括我们学习到的内容，并检查我们的理解。 import &#123; useState &#125; from &#x27;react&#x27;; function Example() &#123; const [count, setCount] = useState(0); return ( &lt;div&gt; &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt; &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt; Click me &lt;/button&gt; &lt;/div&gt; );&#125; 第1行：我们从 React 引入 useState Hook。它允许我们将本地状态保存在函数组件中。 第4行：在 Example 组件内部，通过调用 useState Hook 声明一个新的状态变量。它返回一对值到给它们的命名上。我们调用变量计数 count，它保存了按钮点击次数。我们将其值初始化为零，通过传递 0 作为 useState 的唯一参数。第二个返回项是一个函数，它可以用来更新计数 count，因此我们将其命名为 setCount。 第9行：当用户点击时，使用新值调用 setCount。然后，React 将重新渲染 Example 组件，并将新计数值传递给它。 开始，看起来似乎需要考虑很多东西，不要急于求成！如果你被上面的解释迷糊了，请再次查看上面的代码并尝试逐行阅读。我们保证，一旦你“忘记”了状态如何在类上工作，并以新的眼光看待这个代码，就会很容易理解。 Tip: What Do Square Brackets Mean?提示：方括号语法什么意思？ 当声明一个状态变量时，你可能已经注意到了方括号： const [count, setCount] = useState(0); 左侧的名称不是 React 的 API。你可以随便命名自己的状态变量： const [fruit, setFruit] = useState(&#x27;banana&#x27;); This JavaScript syntax is called “array destructuring”. It means that we’re making two new variables fruit and setFruit, where fruit is set to the first value returned by useState, and setFruit is the second. It is equivalent to this code: 这段 JavaScript 语法称为“数组解构”。它的意思是创建两个新变量 fruit 和 setFruit ，其中 fruit 设置为 useState 返回的数组的第一个值，setFruit 是数组的第二个值。它等价于这段代码： var fruitStateVariable = useState(&#x27;banana&#x27;); // Returns a pairvar fruit = fruitStateVariable[0]; // First item in a pairvar setFruit = fruitStateVariable[1]; // Second item in a pair 当使用 useState 声明一个状态变量时，返回一个包含两个项的数组。第一项是当前值，第二项是允许更新它的函数。使用 [0] 和 [1] 访问它们有点令人困惑，因为它们有着特定含义。这就是在这里使用数组解构的原因。 Note 你可能很好奇， React 如何知道 useState 和组件的对应关系，因为并没有将像 this 这样的任何内容传递给 React。我们将在FAQ部分回答这个问题以及许多其他问题。 Tip: Using Multiple State Variables提示：使用多个状态变量 将状态变量声明为一对 [something，setSomething] 的结构也很方便，因为如果我们想要多个状态变量，可以很方便的为不同的状态变量赋予不同的名称： function ExampleWithManyStates() &#123; // Declare multiple state variables! const [age, setAge] = useState(42); const [fruit, setFruit] = useState(&#x27;banana&#x27;); const [todos, setTodos] = useState([&#123; text: &#x27;Learn Hooks&#x27; &#125;]); 在上面的组件中，age，fruit 和 todos 作为局部变量，可以单独更新它们： function handleOrangeClick() &#123; // Similar to this.setState(&#123; fruit: &#x27;orange&#x27; &#125;) setFruit(&#x27;orange&#x27;);&#125; 你不是必须使用多个状态变量。状态变量也可以很好地保存在对象和数组中，因此你仍然可以将相关数据组合在一起。但是，与类中的 this.setState 不同，更新状态变量总是替换它而不是合并它。 我们在FAQ中提供了有关拆分独立状态变量的更多建议。 Next Steps下一步 本文，我们了解了 React 提供的名为 useState 的 Hook。有时也会称为“状态 Hook”。它允许我们将内部状态添加到 React 函数组件 – 历史上第一次可以这样做！ 我们还了解了更多关于 Hooks 是什么的内容。Hooks 让你从函数组件“挂钩” React 的功能。它们的名字总是从 use 开始，并且还有其它更多还没见过的钩子。 现在让我们继续学习下一个 Hook：useEffect。它允许你在组件中执行副作用的操作，类似类组件中的生命周期方法。","categories":[{"name":"翻译","slug":"翻译","permalink":"http://tcatche.site/categories/%E7%BF%BB%E8%AF%91/"}],"tags":[{"name":"react","slug":"react","permalink":"http://tcatche.site/tags/react/"},{"name":"翻译","slug":"翻译","permalink":"http://tcatche.site/tags/%E7%BF%BB%E8%AF%91/"},{"name":"hooks","slug":"hooks","permalink":"http://tcatche.site/tags/hooks/"}]},{"title":"React Hooks 文档翻译 - 2 - Hooks at a Glance（Hooks 一览）","slug":"react-hooks-overview","date":"2019-04-03T07:45:00.000Z","updated":"2020-07-22T02:19:40.199Z","comments":true,"path":"2019/04/react-hooks-overview/","link":"","permalink":"http://tcatche.site/2019/04/react-hooks-overview/","excerpt":"","text":"翻译自：https://reactjs.org/docs/hooks-overview.html Hooks 是 React 16.8 新增的功能。它允许你在不编写类的情况下使用状态和其他 React 特性。 Hooks 是向后兼容的。本文为经验丰富的 React 用户提供了 Hooks 的概述。这是一个快速讲解的概述。如果你感到困惑，请找这样的概括： 详细解释阅读动机 以了解我们为何将 Hooks 引入React。 ↑↑↑ Each section ends with a yellow box like this. They link to detailed explanations. ↑↑↑ 每一节的结尾都以这样的黄色背景结束（译者的主题不是黄色 2333） 它们链接到到详细的解释。 📌 State Hook这个示例渲染了一个计数器。当你点击按钮时，它会将值递增1： import &#123; useState &#125; from &#x27;react&#x27;;function Example() &#123; // Declare a new state variable, which we&#x27;ll call &quot;count&quot; const [count, setCount] = useState(0); return ( &lt;div&gt; &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt; &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt; Click me &lt;/button&gt; &lt;/div&gt; );&#125; 这里的 useState 就是一个 Hook（我们将在稍后解释它的含义）。我们在函数组件中调用它来添加一些内部状态。React 将在多次渲染之间保留此状态。useState 返回一对内容：当前的状态值和更新这个状态值的函数。你可以从事件处理程序或其他位置调用此函数。它类似于类中的this.setState，除了它不会将旧状态和新状态合并在一起。（我们将在使用 State Hook 使用示例比较 useState 与 this.state 。） useState 的唯一参数是初始状态。在上面的例子中，它是 0 ，因为我们的计数器从零开始。请注意，与 this.state 不同旳是，状态值不必是对象 – 它可以是任意你希望的类型。初始状态参数仅在第一次渲染时使用。 Declaring multiple state variables声明多个状态变量 你可以在同一个组件中多次使用 State Hook： function ExampleWithManyStates() &#123; // Declare multiple state variables! const [age, setAge] = useState(42); const [fruit, setFruit] = useState(&#x27;banana&#x27;); const [todos, setTodos] = useState([&#123; text: &#x27;Learn Hooks&#x27; &#125;]); // ...&#125; 数组解构 语法使我们能够为调用 useState 得到的状态变量赋予不同的名称。这些名字（如上面例子中的 age，fruit, todos 译者注）并不是 useState API 的一部分。并且 React 指定了，如果多次调用 useState，则在它们每次渲染时都会以相同的顺序执行。稍后，我们将解释为什么这样以及何时有用。 But what is a Hook?但是，什么是 Hook 呢？ Hooks 是能让你从函数组件中 “访问” 到 React 状态和生命周期功能的函数。Hooks 在类里不起作用 – 它们能够让你使用 React 不写类的语法。（我们不建议 你立即重写现有的组件，但如果你愿意，可以开始在新组件中使用Hook。） React provides a few built-in Hooks like useState. You can also create your own Hooks to reuse stateful behavior between different components. We’ll look at the built-in Hooks first. React 提供了一些像 useState 这样的内置 Hooks。你还可以创建自己的 Hooks 以方便在不同组件间重用状态行为。我们先来看看内置的 Hooks。 详细说明你可以在此页面上了解有关 State Hook 的更多信息：使用 State Hook。 ⚡️ Effect Hook你之前很可能在 React 组件执行过数据获取，订阅内容或手动更改 DOM 的操作。我们将这些操作称为“包含副作用的操作”（或简称为“副作用”），因为它们会影响其他组件，并且在渲染中无法完成。 副作用的 Hook，useEffect 增加了从函数组件执行“副作用”的功能。它与 React 类中的componentDidMount，componentDidUpdate 和 componentWillUnmount 具有相同的用途，但统一为单个API。（我们将在使用副作用 Hook 这个示例中比较它们的差异。） 例如，下面这个组件在 React 更新到 DOM 后设置文档标题： import &#123; useState, useEffect &#125; from &#x27;react&#x27;;function Example() &#123; const [count, setCount] = useState(0); // Similar to componentDidMount and componentDidUpdate: useEffect(() =&gt; &#123; // Update the document title using the browser API document.title = `You clicked $&#123;count&#125; times`; &#125;); return ( &lt;div&gt; &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt; &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt; Click me &lt;/button&gt; &lt;/div&gt; );&#125; 当调用 useEffect 时，你告诉了 React 在更新 DOM 的后运行你的 effect 函数。effect 在组件内声明，因此可以访问组件的 props 和 state 。默认情况下，React 在每次渲染后都运行 effect –包括第一次渲染。（我们将在使用 Effect Hook 中更多地讨论它与类生命周期的比较。） effect 还可以通过返回一个函数来指定如何“清理”它们。例如，下面这个组件使用 effect 来订阅朋友的在线状态，并通过取消订阅函数来清理： import &#123; useState, useEffect &#125; from &#x27;react&#x27;;function FriendStatus(props) &#123; const [isOnline, setIsOnline] = useState(null); function handleStatusChange(status) &#123; setIsOnline(status.isOnline); &#125; useEffect(() =&gt; &#123; ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange); return () =&gt; &#123; ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange); &#125;; &#125;); if (isOnline === null) &#123; return &#x27;Loading...&#x27;; &#125; return isOnline ? &#x27;Online&#x27; : &#x27;Offline&#x27;;&#125; 在此示例中，当组件卸载时，或者由于后续渲染而导致重新运行 effect 前，React 都将取消订阅 ChatAPI。（如果需要的话，有一种方法可以告诉 React 跳过重新订阅，如果我们传递给 ChatAPI 的 props.friend.id 没有改变。） 就像使用 useState 一样，你可以在组件中使用多个 effect： function FriendStatusWithCounter(props) &#123; const [count, setCount] = useState(0); useEffect(() =&gt; &#123; document.title = `You clicked $&#123;count&#125; times`; &#125;); const [isOnline, setIsOnline] = useState(null); useEffect(() =&gt; &#123; ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange); return () =&gt; &#123; ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange); &#125;; &#125;); function handleStatusChange(status) &#123; setIsOnline(status.isOnline); &#125; // ... Hooks 能够让你自由地将组件中相关联的副作用（例如添加和删除订阅）组织在一起，而不是像类组件一样，被不同的生命周期方法强制拆分到不同的方法中。 详细解释你可以在此页面上了解关于 useEffect 的更多信息：使用 Effect Hook。 ✌️ Rules of HooksHooks 是 JavaScript 函数，但它强加了两个额外的规则： 只在函数顶层调用 Hooks。不要在循环，条件或嵌套函数中调用 Hook。 Only call Hooks from React function components. Don’t call Hooks from regular JavaScript functions. (There is just one other valid place to call Hooks – your own custom Hooks. We’ll learn about them in a moment.) 只在 React 函数组件中调用 Hooks。不要在普通的 JavaScript 函数中调用 Hook。（还有另一个被允许的地方调用 Hooks – 你的自定义 Hooks。我们稍后会介绍它们。） 我们提供了一个linter 插件 来强制执行这些规则。我们知道这些规则最初可能看起来很受限制或令人困惑，但它们对于使 Hooks 良好运行至关重要。 详细解释你可以在此页面上了解关于 Hooks 使用规则的更多信息：Hooks 使用规则。 💡 Building Your Own Hooks有时，我们想在组件间重用一些状态的逻辑。以前，有两个流行的解决方案：高阶组件和 render props。现在，自定义 Hooks 也允许你这么做，并无需向组件树中添加更多组件层级。 在本页前面，我们介绍了一个 FriendStatus 组件,调用 useState 和 useEffect Hooks 订阅朋友的在线状态。假设我们还希望在另一个组件中重用此订阅逻辑。 首先，我们将这个逻辑提取到一个名为 useFriendStatus 的自定义 Hook 中： import &#123; useState, useEffect &#125; from &#x27;react&#x27;;function useFriendStatus(friendID) &#123; const [isOnline, setIsOnline] = useState(null); function handleStatusChange(status) &#123; setIsOnline(status.isOnline); &#125; useEffect(() =&gt; &#123; ChatAPI.subscribeToFriendStatus(friendID, handleStatusChange); return () =&gt; &#123; ChatAPI.unsubscribeFromFriendStatus(friendID, handleStatusChange); &#125;; &#125;); return isOnline;&#125; 它接收 friendID 作为参数，并返回我们的朋友是否在线。 现在我们可以从两个组件中使用它： function FriendStatus(props) &#123; const isOnline = useFriendStatus(props.friend.id); if (isOnline === null) &#123; return &#x27;Loading...&#x27;; &#125; return isOnline ? &#x27;Online&#x27; : &#x27;Offline&#x27;;&#125; function FriendListItem(props) &#123; const isOnline = useFriendStatus(props.friend.id); return ( &lt;li style=&#123; &#123; color: isOnline ? &#x27;green&#x27; : &#x27;black&#x27; &#125; &#125;&gt; &#123;props.friend.name&#125; &lt;/li&gt; );&#125; 这些组件的状态是完全独立的。Hooks 是重用已有状态逻辑的一种方式，而不是状态的本身。事实上，每次调用 Hook 都有一个完全隔离的状态–所以你甚至可以在一个组件中使用相同的自定义Hook 两次。 自定义 Hooks 更像是一种约定而非功能。如果函数的名称以“use”开头并且它调用了其他 Hooks，我们称之为自定义 Hook。useSomething 的命名约定使我们的 linter 插件能够在使用 Hooks 的代码中查找错误。 You can write custom Hooks that cover a wide range of use cases like form handling, animation, declarative subscriptions, timers, and probably many more we haven’t considered. We are excited to see what custom Hooks the React community will come up with. 你可以编写自定义 Hooks，涵盖更广泛的使用场景，如表单处理，动画，声明订阅，计时器，以及更多我们没有考虑过的。我们很期望看到 React 社区发布各种定制的 Hooks。 详细说明你可以在此专题页面上关于自定义 Hook 的更多信息：创造你自己的 Hooks。 🔌 Other Hooks你可能会发现一些不太常用的内置 Hooks 也很有用。例如， useContext 允许你不引入嵌套来订阅 React context： function Example() &#123; const locale = useContext(LocaleContext); const theme = useContext(ThemeContext); // ...&#125; useReducer 允许你使用 reducer 管理复杂组件的内部状态： function Todos() &#123; const [todos, dispatch] = useReducer(todosReducer); // ... 详细说明你可以在此页面上了解关于内置 Hooks 的更多信息：Hooks API 参考。 Next Steps如果这些介绍对你来说太简单了，或者你想详细了解更多内容，可以阅读下一节，从 State Hook 的文档开始。 你还可以查看 Hooks API 参考 和 Hooks常见问题解答。 最后，不要错过介绍页，它解释了我们为什么要添加 Hooks 以及我们将如何开始将它们与类搭配使用 – 而不重写我们的应用程序。","categories":[{"name":"翻译","slug":"翻译","permalink":"http://tcatche.site/categories/%E7%BF%BB%E8%AF%91/"}],"tags":[{"name":"react","slug":"react","permalink":"http://tcatche.site/tags/react/"},{"name":"翻译","slug":"翻译","permalink":"http://tcatche.site/tags/%E7%BF%BB%E8%AF%91/"},{"name":"hooks","slug":"hooks","permalink":"http://tcatche.site/tags/hooks/"}]},{"title":"React Hooks 文档翻译 - 1 - Introducing Hooks（Hooks 介绍）","slug":"react-hooks-intro","date":"2019-03-26T08:23:00.000Z","updated":"2019-04-28T07:55:10.000Z","comments":true,"path":"2019/03/react-hooks-intro/","link":"","permalink":"http://tcatche.site/2019/03/react-hooks-intro/","excerpt":"","text":"翻译自：https://reactjs.org/docs/hooks-intro.html Hooks 是 React 16.8 新增的功能。它允许你在不编写类的情况下使用状态和其他 React 特性。 import &#123; useState &#125; from &#x27;react&#x27;;function Example() &#123; // Declare a new state variable, which we&#x27;ll call &quot;count&quot; const [count, setCount] = useState(0); return ( &lt;div&gt; &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt; &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt; Click me &lt;/button&gt; &lt;/div&gt; );&#125; 新函数 useState 就是我们要学习的第一个“Hook”。如果对它还没有概念，不必担心，这个例子只是一个预告！ 你可以在下一节 学习Hooks。 本文将接着解释为什么我们将 Hooks 添加到 React 中，以及它们如何帮助你编写出色的应用程序。 注意 React 16.8.0 是第一个支持 Hooks 的版本。升级时，不要忘记更新所有包，包括 React DOM。React Native 将在下一个稳定版本中支持 Hooks。 Video Introduction（介绍视频）在 React Conf 2018 ，Sophie Alpert 和 Dan Abramov 介绍了 Hooks，随后 Ryan Florence 演示了如何重构应用程序来使用它们。观看视频：(需要科学上网工具，且未翻译) No Breaking Changes（非重大的更改）在继续了解前，需要了解关于 Hooks 的以下几点： 完全可选的。你可以在几个新的组件中尝试 Hooks，而无需重写任何现有代码。如果你现在不愿意尝试它，完全\u001d不必去学习或使用它。 100％向后兼容。 Hooks 不包含任何其它的重大更改。 现在可用。 随着 v16.8.0 的发布，现在可以使用 Hooks。 没有任何从 React 中删除类的计划。 你可以在本页底部阅读有关 Hooks 逐步采用策略的更多信息。 Hooks 不会取代你对React概念的了解。 相反，Hooks 为你已经知道的 React 概念：props，state，context，refs 和 lifecycle 提供了更直接的API。正如我们稍后将展示的，Hooks 还提供了一种新的强大方式来组合它们。 如果你想立即开始学习Hooks，请直接跳到下一页！ 你还可以继续阅读此页面，进一步了解我们为什么要添加Hooks，以及我们如何在不重写应用程序的情况下开始使用它们。 Motivation（动机）Hook 解决了过去五年里我们使用 React 编写和维护数以万计的组件时遇到的很多看似无关的问题，但无论你是在学习 React，还是在使用它，或者是更喜欢使用具有类似组件模型的不同库，你可能会遇到其中的一些问题。 It’s hard to reuse stateful logic between components在组件间公用状态的逻辑很困难 React 没有提供能将可重用行为“附加”到组件的方法（例如，将其连接到一个 store 上）。如果你已经使用了一段时间 React ，你可能熟悉render props 和 高阶组件 等模式，这些模式都试图解决这样的问题。但是这些模式要求你在使用它们时重构组件，这可能会很麻烦并且使代码更难以追踪。如果你从 React DevTools 中查看一个典型的 React 应用程序，你可能会发现一个由多层“生产者”、“消费者”、“高阶组件”、“渲染 props” 和其他抽象层的组件组成的“包装器地狱”。虽然我们可以在 DevTools 中过滤它们，但这指出了一个更深层次的基本问题：React需要提供一个更好的原生的方法来共享状态的逻辑。 使用 Hooks，你可以从组件中提取状态的逻辑，以便可以独立测试并重用。Hooks 允许你在不更改组件层次结构的情况下重用有状态逻辑。这样可以轻松地在许多组件之间或社区间共享 Hooks。 我们将在构建你自己的 Hooks 中进一步讨论。 Complex components become hard to understand复杂的组件变得很难理解 我们经常需要维护一些开始时很简单，最后演变成了有一堆无法管理的状态逻辑和副作用的混乱的组件。组件的每个生命周期方法通常是一些不相关逻辑的混合。例如，组件可能会在 componentDidMount 和 componentDidUpdate 中执行一些数据获取的行为。但是，同一个 componentDidMount 方法可能还包含一些设置事件侦听器的无关逻辑，并在 componentWillUnmount 中被清理。相互关联的一起产生作用的代码被拆分，而完全不相关的代码最终被组合在一个方法中，这使得错误和不一致的引入变得太容易了。 在许多情况下，将这些组件拆分为较小的组件是不可能的，因为状态的逻辑遍布整个组件，而且测试它们也很困难。这就是许多人更喜欢将 React 与单独的状态管理库相结合的原因之一。然而，这样做通常会引入很多的抽象，要求你在不同的文件之间跳转，并使重用组件变得更加困难。 为了解决这个问题，Hooks 允许你根据相关联的部分（例如监听订阅或获取数据）将一个组件拆分为几个较小的函数，，而不是基于生命周期方法将这些相关联的部分强制拆分。你还可以选择使用 reducer 来管理组件的内部状态，以使其更具可预测性。 我们将在使用 Effect Hook 中更多地讨论这个问题。 Classes confuse both people and machines“类”让人和机器都很困惑 我们发现“类”除了使代码重用和代码组织更加困难之外，还可能是学习 React 的一大障碍。你必须了解 this 在 JavaScript 中是如何工作的，这\b与它在大多数语言中的工作方式有很大不同。你必须记住绑定事件处理程序。没有稳定的语法提议，代码非常冗长。人们可以很好地理解 props，state 和自上而下的数据流，但是在艰难地与“类”做斗争。React 中的函数和类组件之间的区别以及何时使用它们，导致即使经验丰富的 React 开发人员之间也存在分歧。 此外，React 已经推出了大约五年了，我们希望确保它在未来五年内保持活跃。正如 Svelte，Angular ，Glimmer 和其他类库所表现的，预编译型组件 具有很大的未来潜力。特别是如果它不限于模板。最近，我们一直在尝试使用 Prepack 进行组件打包，我们已经看到了有希望的早期结果。但是，我们发现类组件可能会产生无意识的模式，导致这些优化回归到较慢的路径。类组件也为今天的工具提出了问题。例如，类不会很好地压缩，并且它们使得热更新加载更加碎片化和不可靠。我们希望提供一种API，使代码更有可能保持在可优化的道路上。 为了解决这些问题，Hooks 允许你在没有类的情况下使用更多 React 的特性。 从概念上讲，React组件一直更接近函数。Hooks 拥抱函数，但不会牺牲 React 的实际精神。Hooks 提供了对命令式方式编程的访问，并且不需要你学习复杂的函数式或响应式编程技术。 Examples Hooks 概览是开始学习 Hooks 的好地方。 Gradual Adoption Strategy逐步采用的策略 太长不看版：没有从 React 中移除类组件的计划 我们知道 React 开发人员专注于发布产品，未必有时间研究每次发布中的新 API。 Hooks 是非常新的，在考虑学习或采用它们之前等待更多示例和教程可能会更好。 你可能听说过为 React 添加新语法的标准非常高。对于好奇的读者，我们已经准备了一个详细的RFC，其中包含更多此动机的细节，并提供有关特定设计决策和相关现有技术的额外视角。 至关重要的是，Hooks 与现有代码并行工作，因此你可以逐步采用它们。 不必急于迁移到 Hooks。我们建议避免任何的“重大改写”，特别是对于现有的复杂类组件。开始“使用 Hooks 思考”需要一点精神上的转变。根据我们的经验，最好先在新的和非关键的组件中练习使用 Hooks，并确保团队中的每个人都对它感到适应。在你尝试 Hooks之后，请随时向我们发送反馈，无论是积极的还是消极的。 我们打算让 Hooks 涵盖所有的现有的类用例，但我们将在可预见的未来继续支持类组件。 在Facebook，我们有数万个组件都是使用类编写的，我们绝对没有计划重写它们。相反，我们开始在新代码中使用 Hooks 与类并排使用。 Frequently Asked Questions我们准备了一个 Hooks FAQ 页面，它回答了关于 Hooks 最常见的问题 Next Steps在本文末尾，你应该大致了解 Hooks 正在解决的问题，但可能很多细节都不清楚。别担心！让我们进入下一页， 通过示例开始学习 Hooks。","categories":[{"name":"翻译","slug":"翻译","permalink":"http://tcatche.site/categories/%E7%BF%BB%E8%AF%91/"}],"tags":[{"name":"react","slug":"react","permalink":"http://tcatche.site/tags/react/"},{"name":"翻译","slug":"翻译","permalink":"http://tcatche.site/tags/%E7%BF%BB%E8%AF%91/"},{"name":"hooks","slug":"hooks","permalink":"http://tcatche.site/tags/hooks/"}]},{"title":"常用的高阶函数之控制执行次数","slug":"function-program-common-function-run-time","date":"2018-12-04T06:41:00.000Z","updated":"2019-03-13T06:44:02.000Z","comments":true,"path":"2018/12/function-program-common-function-run-time/","link":"","permalink":"http://tcatche.site/2018/12/function-program-common-function-run-time/","excerpt":"","text":"控制次数其实主要从两方面着手，一方面是简单的限制函数的执行次数，而另一方面可以缓存函数的执行结果。 限制函数的执行次数对于有些场景下可能需要控制执行次数，比如设置错误重试次数5次，比如表单提交函数只允许执行一次防止重复提交。 function limit(fn, limit, context) &#123; let current = 0; return function(...args) &#123; if (current &gt;= limit) &#123; return -1; // 或者返回其它有意义的内容 &#125; current += 1; let ctx = context || this; return fn.apply(ctx, args); &#125;&#125;function foo(id) &#123; console.log(id);&#125;foo(1); // log 1foo(2); // log 2foo(3); // log 3foo = limit(foo, 1); // 限制只执行一次foo(4); // log 4foo(5); // do nothingfoo(6); // do nothing 缓存函数的执行结果对于一些执行成本非常高的操作或者会被反复调用的操作，可以通过缓存，限制其执行次数。 function memorize(func, context) &#123; let cache = &#123;&#125;; return function(...args) &#123; let address = args.length + args.join(&quot;,&quot;); if (cache[address] === undefined) &#123; cache[address] = func.apply(context || this, args); &#125; return cache[address]; &#125;;&#125;;// 使用斐波那契数列测试let count = 0;let fibonacci = n =&gt; &#123; count ++; return n &lt; 2 ? n : fibonacci(n - 1) + fibonacci(n - 2);&#125;for (let i = 0; i &lt; 10; i ++) &#123;2fibonacci(i);&#125;console.log(count); // 276fibonacci = memorize(fibonacci);count = 0;for (let i = 0; i &lt; 10; i ++) &#123;2fibonacci(i)&#125;console.log(count); // 10","categories":[{"name":"js","slug":"js","permalink":"http://tcatche.site/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"http://tcatche.site/tags/js/"},{"name":"高阶函数","slug":"高阶函数","permalink":"http://tcatche.site/tags/%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0/"}]},{"title":"常用的高阶函数之控制执行顺序","slug":"function-program-common-function-timeline","date":"2018-12-03T06:36:00.000Z","updated":"2019-03-13T06:39:02.000Z","comments":true,"path":"2018/12/function-program-common-function-timeline/","link":"","permalink":"http://tcatche.site/2018/12/function-program-common-function-timeline/","excerpt":"","text":"在日常开发，经常会有要求异步函数的执行结果按顺序执行，看下面的例子： let asyncF = (i, callback) =&gt; &#123;2// 随机延迟若干事件触发回调 let lateTime = Math.random() * 10; setTimeout(() =&gt; &#123;callback(i)&#125;, lateTime);&#125;for (var i = 0; i &lt; 5; i ++) &#123; asyncF(i, console.log); // 结果完全是随机的，一个可能的结果是0，1，4，3，2&#125; 这个例子模拟了一系列的异步调用，它们的执行时间不确定，所以完全无法预测多次调用的结果，对于这类操作通常有2种解决方案： 缓存所有结果，然后按顺序执行如果每个发出的请求返回内容都很有用，而且需要保持一定的顺序，可以使用这种方案。 function sequenceAll(func) &#123;2// 每次函数调用的唯一 id，调用后 id + 1 let callUid = 0; // 上次成功调用了 callback 的 id，用于和当前函数的 id 作比较， // 确定是否需要忽略当前的调用。 let nextCallId = 0; let taskQueue = []; // 运行被缓存的数据 const runnerNext = (runId) =&gt; &#123; if (taskQueue[runId]) &#123; taskQueue[runId](); // 运行下一个已被缓存的数据 runnerNext(runId + 1); &#125; &#125; return function(...args) &#123; let currCallId = callUid; callUid += 1; taskQueue.push(undefined); // 要求 func 接收的最后一个参数是一个回调函数，如果不是的话需要先改造成这样的形式 const callback = args.pop(); return func(...args, function(...iargs) &#123; // 如果回调为当前的任务，则执行 if (currCallId === nextCallId) &#123; if (callback &amp;&amp; typeof callback === &#x27;function&#x27;) &#123; callback(...iargs); &#125; nextCallId += 1; runnerNext(nextCallId); // 否则，放入回调队列，等待正确的顺序被调用 &#125; else &#123; taskQueue[currCallId] = () =&gt; &#123; callback(...iargs); nextCallId += 1; &#125;; &#125; &#125;); &#125;&#125;//示例let asyncFSeq = sequenceAll(asyncF);for (var i = 0; i &lt; 50; i ++) &#123; asyncFSeq(i, console.log); // 结果必然是 0 1 2 3 4&#125; 直接执行，忽略不合时序的结果如果在执行异步操作拿到结果准备回调后发现已经有晚于其发出的异步操作的回调已经被执行，name 忽略本函数的调用结果。 function sequenceIgnore(func) &#123;2// 每次函数调用的唯一 id，调用后 id + 1 let callUid = 0; // 上次成功调用了 callback 的 id，用于和当前函数的 id 作比较， // 确定是否需要忽略当前的调用。 let lastCallId = 0; return function(...args) &#123; let currCallId = callUid; callUid += 1; const callback = args.pop() // 要求 func 接收的最后一个参数是一个回调函数，如果不是的话需要先改造成这样的形式 return func(...args, function(...args) &#123; if (currCallId &lt; lastCallId) &#123; return; &#125; lastCallId = currCallId; if (callback &amp;&amp; typeof callback === &#x27;function&#x27;) &#123; callback(...iargs); &#125; &#125;); &#125;&#125;//示例const asyncFSeq = sequenceIgnore(asyncF);// 此时，结果虽然也是随机的，但是每次执行的结果必然是逐个递增的，// 后发出的异步操作不会被先发出的操作覆盖，即最后一个必然为 4for (var i = 0; i &lt; 5; i ++) &#123; asyncFSeq(i, console.log); // 结果也是随机的，一个可能的输出 0 3 4&#125; 这种处理方法更适合于处理只需要最晚发出的执行结果的操作。比如根据用户输入内容实时发出请求进行模糊匹配，这个时候呈现给用户的自然是与用户最后输入的文本匹配的结果是最好的处理方案。","categories":[{"name":"js","slug":"js","permalink":"http://tcatche.site/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"http://tcatche.site/tags/js/"},{"name":"高阶函数","slug":"高阶函数","permalink":"http://tcatche.site/tags/%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0/"}]},{"title":"React.momo","slug":"react-momo","date":"2018-11-20T11:55:00.000Z","updated":"2018-11-20T12:00:22.000Z","comments":true,"path":"2018/11/react-momo/","link":"","permalink":"http://tcatche.site/2018/11/react-momo/","excerpt":"","text":"概述如果你经常使用 PureComponent 或 shouldComponentUpdate 进行性能优化的时候，那么一定对纯函数组件（SFC 组件）缺失这样的功能而感觉不爽，甚至有时候不得不对有些复杂的组件进行一层包装，包装成类组件。 现在，React 官方终于提供了对这个功能的支持。在 React v16.6.0 新引入了一个高阶组件 React.momo，它的作用类似于 React.PureComponent 但是是作用在纯函数组件（SFC 组件）上的。 const MyComponent = React.memo(function MyComponent(props) &#123; /* 只有在 props 改变的时候才会重新渲染 */&#125;); 也就是说，在 props 没有改变的情况下，Reactc将跳过重新渲染组件，而是重用最近一次的渲染结果。 自定义比较函数当然，与 React.PureComponent 一样，在默认情况下，它只会浅比较 props 对象中的复杂对象。 如果要更加准确的控制比较的结果，还可以提供自定义的比较函数作为 React.momo 的第二个参数。 function MyComponent(props) &#123; /* render using props */&#125;function areEqual(prevProps, nextProps) &#123; /* return true if passing nextProps to render would return the same result as passing prevProps to render, otherwise return false */&#125;export default React.memo(MyComponent, areEqual); 注意，这个自定义的比较函数和 shouldComponentUpdate() 对返回结果的处理正好相反，也就是说两次的 props 相同的时候返回 true，不同则返回 false。返回 true 会阻止更新，使用上次渲染的结果，而返回 false 则重新渲染。 需要注意的是，根据官方文档，这个函数仅仅被定义为进行性能优化，不要出于业务逻辑的需要使用它来阻止更新，否则可能造成一些问题。 This method only exists as a performance optimization. Do not rely on it to “prevent” a render, as this can lead to bugs. 自己实现知道了怎么用，以及它的原理，也可以来写一下实现： 使用类包装这是最简单的一种方式，通过将函数式组件包装成为类组件： const momo = (sfcRender, compareFunc) =&gt; &#123; if (compareFunc) &#123; return class extends React.Component &#123; shouldComponentUpdate(prevProps, nextProps) &#123; // 这里行为要相反 return !compareFunc(prevProps, nextProps); &#125; render() &#123; return sfcRender(this.props); &#125; &#125; &#125; return class extends React.PureComponent &#123; render() &#123; return sfcRender(this.props); &#125; &#125;&#125; 使用函数缓存另一种实现方式是将相关数据缓存到函数上。 const momo = (sfcRender, compareFunc) =&gt; &#123; sfcRender.__prevResult = null; sfcRender.__prevProps = null; sfcRender.__isFirstRender = true; return function(nextProps) &#123; if (sfcRender.__isFirstRender) &#123; sfcRender.__isFirstRender = false; sfcRender.__prevResult = sfcRender(nextProps); sfcRender.__prevProps = nextProps; return sfcRender.__prevResult; &#125; const isCustomeSame = compareFunc &amp;&amp; compareFunc(sfcRender.__prevProps, nextProps); const isShadowSame = !compareFunc &amp;&amp; nextProps === sfcRender.__prevProps; sfcRender.__prevProps = nextProps; if (!isCustomeSame &amp;&amp; !isShadowSame) &#123; sfcRender.__prevResult = sfcRender(nextProps); &#125; return sfcRender.__prevResult; &#125;;&#125; 注意，这两种实现仅供参考。这两种方式如果使用在单个的组件上，则其行为一致。但是，当应用到多个组件上时，具有较大的行为差异。第一种方式由于每次在使用的时候都生成了一个新的示例，所以仅在每次父组件更新时，才会触发比较判断是否更新。第二种方式由于是函数的实现方式，所以当首次渲染渲染多个包装过的函数式组件时，即进行判断。 TODO:React 源码实现方式","categories":[{"name":"js","slug":"js","permalink":"http://tcatche.site/categories/js/"}],"tags":[{"name":"react","slug":"react","permalink":"http://tcatche.site/tags/react/"},{"name":"shouldComponentUpdate","slug":"shouldComponentUpdate","permalink":"http://tcatche.site/tags/shouldComponentUpdate/"}]},{"title":"CSS 计数器：counter","slug":"css-counter","date":"2018-11-14T07:14:00.000Z","updated":"2018-11-14T09:36:46.000Z","comments":true,"path":"2018/11/css-counter/","link":"","permalink":"http://tcatche.site/2018/11/css-counter/","excerpt":"","text":"之前在实现代码行号的时候发现 CSS 有个很方便的功能“计数器”，可以很方便的生成代码行号以及章节号，本文介绍一些这些功能。 css 计数器有三部分组成： counter-reset、counter-increment 两个属性和函数 counter()/counters()。下面介绍一下它们的使用。 counter-reset使用计数器前需要使用 counter-reset 声明一个或多个计数器： counter-reset: counter-name [initValue] [counter-name2 [initValue2]] …[counter-nameN [initValueN]]; 参数： counter-name 不能为 none、 unset、 inherit 和 initial 否则会被忽略。 initValue 必须为整数，默认值为 0，可以省略。 示例： /* Set counter-name to 0 */counter-reset: counter-name;/* Set counter-name to -1 */counter-reset: counter-name -1;/* Set counter1 to 1, and counter2 to 4 */counter-reset: counter1 1 counter2 4;/* Sets the chapter and page counters to 0 and the section counter to 1. */counter-reset: chapter section 1 page; counter-incrementcounter-increment 可以增加或者减小一个或者多个计数器的值： counter-increment: counter-name [changeValue] [counter-name2 [changeValue2]] …[counter-nameN [changeValueN]]; 参数： counter-increment 不能为 none、 unset、 inherit 和 initial 否则会被忽略。 changeValue 必须为整数，可以为整数或者负数，如果为负数则减小计数器的值。 示例： /* Increment counter-name by 1 */counter-increment: counter-name;/* Decrement counter-name by 1 */counter-increment: counter-name -1;/* Increment counter1 by 1, and decrement counter2 by 4 */counter-increment: counter 1 counter2 -4;/* Increases the value of the chapter and page counters by 1 and the section counter by 2. */counter-increment: chapter section 2 page; counter()/counters()计数器的值可以通过设置 content 属性值为 counter()/counters() 展示： content: [‘prefix’]counter(section, [style])[‘suffix’];content: [‘prefix’]counters(section, [‘join-string’], [style])[‘suffix’]; counter() 函数有两种使用形式：counter(name) 或 counter(name, style)。生成的文本是指定伪元素范围内由指定的字符串（prefix、string、suffix 参数）连接起来计数器的值。 counters() 函数也有两种形式：counter(name, string) 或 counters(name, string, style)。生成的文本是指定的伪元素的范围内的所有指定名称计数器的值, 从最外层到最内层, 由指定的字符串（prefix、string、suffix 参数）连接起来。 其中 style 支持 list-style 的取值。 具体使用示例看下一节。 使用示例计数器主要有以下使用场景： 显示行号See the Pen 计数器-行号 by tcatche (@tcatche) on CodePen. 显示层级的章节号See the Pen 多个计数器嵌套 by tcatche (@tcatche) on CodePen. 更改计数器的样式See the Pen 章节 by tcatche (@tcatche) on CodePen. 参考 MDN: Using CSS counters MDN: list-style Can I use counter ?","categories":[{"name":"css","slug":"css","permalink":"http://tcatche.site/categories/css/"}],"tags":[{"name":"counter","slug":"counter","permalink":"http://tcatche.site/tags/counter/"},{"name":"计数器","slug":"计数器","permalink":"http://tcatche.site/tags/%E8%AE%A1%E6%95%B0%E5%99%A8/"},{"name":"list-style","slug":"list-style","permalink":"http://tcatche.site/tags/list-style/"},{"name":"content","slug":"content","permalink":"http://tcatche.site/tags/content/"}]},{"title":"React - Render Props(使用 props 渲染内容)","slug":"react-use-render-props-for-cross-cutting-concerns","date":"2018-10-19T06:22:00.000Z","updated":"2020-07-22T02:19:40.202Z","comments":true,"path":"2018/10/react-use-render-props-for-cross-cutting-concerns/","link":"","permalink":"http://tcatche.site/2018/10/react-use-render-props-for-cross-cutting-concerns/","excerpt":"","text":"翻译自 React Docs: Render Props The term “render prop” refers to a technique for sharing code between React components using a prop whose value is a function. 术语 “render prop” 指的是使用其值为函数的 prop 在 React 组件之间共享代码的技术。 A component with a render prop takes a function that returns a React element and calls it instead of implementing its own render logic. 具有 render prop 的组件接受一个函数，该函数返回一个React元素并调用它而不是自己实现渲染逻辑。 &lt;DataProvider render=&#123;data =&gt; ( &lt;h1&gt;Hello &#123;data.target&#125;&lt;/h1&gt;)&#125;/&gt; Libraries that use render props include React Router and Downshift. 使用 render props 的库有 React Router 和 Downshift。 In this document, we’ll discuss why render props are useful, and how to write your own. 本文，我们将讨论为什么 render props 很有用，以及如何编写。 Use Render Props for Cross-Cutting Concerns（使用 render props 来解决横切关注点）Components are the primary unit of code reuse in React, but it’s not always obvious how to share the state or behavior that one component encapsulates to other components that need that same state. 组件是 React 中代码重用的主要单元，但是将一个组件封装的状态或行为共享给其它组件并容易。 For example, the following component tracks the mouse position in a web app: 例如，下面这个组件跟踪 Web 应用程序中的鼠标位置： class MouseTracker extends React.Component &#123; constructor(props) &#123; super(props); this.handleMouseMove = this.handleMouseMove.bind(this); this.state = &#123; x: 0, y: 0 &#125;; &#125; handleMouseMove(event) &#123; this.setState(&#123; x: event.clientX, y: event.clientY &#125;); &#125; render() &#123; return ( &lt;div style=&#123; &#123; height: &#x27;100%&#x27; &#125; &#125; onMouseMove=&#123;this.handleMouseMove&#125;&gt; &lt;h1&gt;Move the mouse around!&lt;/h1&gt; &lt;p&gt;The current mouse position is (&#123;this.state.x&#125;, &#123;this.state.y&#125;)&lt;/p&gt; &lt;/div&gt; ); &#125;&#125; As the cursor moves around the screen, the component displays its (x, y) coordinates in a &lt;p&gt;. 当光标在屏幕上移动时，组件在 &lt;p&gt; 中显示其（x，y）坐标。 Now the question is: How can we reuse this behavior in another component? In other words, if another component needs to know about the cursor position, can we encapsulate that behavior so that we can easily share it with that component? 现在问题是：我们如何在另一个组件中重用此行为？换句话说，如果另一个组件需要知道光标位置，我们是否可以封装该行为，以便我们可以轻松地与其它组件共享此行为？ Since components are the basic unit of code reuse in React, let’s try refactoring the code a bit to use a &lt;Mouse&gt; component that encapsulates the behavior we need to reuse elsewhere. 由于组件是 React 中代码重用的基本单元，让我们试着重构代码，使用 &lt;Mouse&gt; 组件来封装我们需要在其他地方重用的行为。 // The &lt;Mouse&gt; component encapsulates the behavior we need...// &lt;Mouse&gt; 组件封装了我们需要的行为class Mouse extends React.Component &#123; constructor(props) &#123; super(props); this.handleMouseMove = this.handleMouseMove.bind(this); this.state = &#123; x: 0, y: 0 &#125;; &#125; handleMouseMove(event) &#123; this.setState(&#123; x: event.clientX, y: event.clientY &#125;); &#125; render() &#123; return ( &lt;div style=&#123; &#123; height: &#x27;100%&#x27; &#125; &#125; onMouseMove=&#123;this.handleMouseMove&#125;&gt; &#123;/* ...but how do we render something other than a &lt;p&gt;? 但是怎样渲染其他内容而不仅仅是渲染一个 &lt;p&gt; 元素？*/&#125; &lt;p&gt;The current mouse position is (&#123;this.state.x&#125;, &#123;this.state.y&#125;)&lt;/p&gt; &lt;/div&gt; ); &#125;&#125;class MouseTracker extends React.Component &#123; render() &#123; return ( &lt;div&gt; &lt;h1&gt;Move the mouse around!&lt;/h1&gt; &lt;Mouse /&gt; &lt;/div&gt; ); &#125;&#125; Now the &lt;Mouse&gt; component encapsulates all behavior associated with listening for mousemove events and storing the (x, y) position of the cursor, but it’s not yet truly reusable. 现在，&lt;Mouse&gt; 组件封装了侦听 mousemove 事件，存储了与光标的位置（x，y）相关的所有行为，但它还不能真正重用。 For example, let’s say we have a &lt;Cat&gt; component that renders the image of a cat chasing the mouse around the screen. We might use a &lt;Cat mouse=&#123; &#123; x, y &#125; &#125;&gt; prop to tell the component the coordinates of the mouse so it knows where to position the image on the screen. 例如，假设我们有一个 &lt;Cat&gt; 组件，它可以呈现猫在屏幕上追逐鼠标的图像。我们可能会使用 &lt;Cat mouse = &#123; &#123;x，y&#125; &#125;&gt; prop 来告诉组件鼠标的坐标，以便知道将图像放在屏幕上的位置。 As a first pass, you might try rendering the &lt;Cat&gt;inside &lt;Mouse&gt;’s render method, like this: 第一版的代码，你可能尝试在 &lt;Mouse&gt; 的 render 方法中渲染 &lt;Cat&gt;： class Cat extends React.Component &#123; render() &#123; const mouse = this.props.mouse; return ( &lt;img src=&quot;/cat.jpg&quot; style=&#123; &#123; position: &#x27;absolute&#x27;, left: mouse.x, top: mouse.y &#125; &#125; /&gt; ); &#125;&#125;class MouseWithCat extends React.Component &#123; constructor(props) &#123; super(props); this.handleMouseMove = this.handleMouseMove.bind(this); this.state = &#123; x: 0, y: 0 &#125;; &#125; handleMouseMove(event) &#123; this.setState(&#123; x: event.clientX, y: event.clientY &#125;); &#125; render() &#123; return ( &lt;div style=&#123; &#123; height: &#x27;100%&#x27; &#125; &#125; onMouseMove=&#123;this.handleMouseMove&#125;&gt; &#123;/* We could just swap out the &lt;p&gt; for a &lt;Cat&gt; here ... but then we would need to create a separate &lt;MouseWithSomethingElse&gt; component every time we need to use it, so &lt;MouseWithCat&gt; isn&#x27;t really reusable yet. 我们只需要把这里的 &lt;p&gt; 换成 &lt;Cat&gt; here ... but then 但是这样的话，每次我们需要这种行为都需要重新创建一个 &lt;MouseWithSomethingElse&gt; 组件，很明显这样仍然没有实现更好地复用 */&#125; &lt;Cat mouse=&#123;this.state&#125; /&gt; &lt;/div&gt; ); &#125;&#125;class MouseTracker extends React.Component &#123; render() &#123; return ( &lt;div&gt; &lt;h1&gt;Move the mouse around!&lt;/h1&gt; &lt;MouseWithCat /&gt; &lt;/div&gt; ); &#125;&#125; This approach will work for our specific use case, but we haven’t achieved the objective of truly encapsulating the behavior in a reusable way. Now, every time we want the mouse position for a different use case, we have to create a new component (i.e. essentially another &lt;MouseWithCat&gt;) that renders something specifically for that use case. 这种方法适用于我们的特定用例，但还没有达到真正可重用的封装行为的目标。现在，每当我们想要在不同的用例中使用鼠标位置时，我们必须创建一个新的组件专门渲染此用例（其本质上是另一个 &lt;MouseWithCat&gt;）。 Here’s where the render prop comes in: Instead of hard-coding a &lt;Cat&gt; inside a &lt;Mouse&gt; component, and effectively changing its rendered output, we can provide &lt;Mouse&gt; with a function prop that it uses to dynamically determine what to render–a render prop. 这就是 render props 的用武之地：我们可以为 &lt;Mouse&gt; 提供一个函数类型的 prop，它可以动态地确定要渲染的内容，而不是硬编码写在 &lt;Mouse&gt; 组件中的 &lt;Cat&gt;，直接改变 &lt;Mouse&gt; 的渲染内容。 class Cat extends React.Component &#123; render() &#123; const mouse = this.props.mouse; return ( &lt;img src=&quot;/cat.jpg&quot; style=&#123; &#123; position: &#x27;absolute&#x27;, left: mouse.x, top: mouse.y &#125; &#125; /&gt; ); &#125;&#125;class Mouse extends React.Component &#123; constructor(props) &#123; super(props); this.handleMouseMove = this.handleMouseMove.bind(this); this.state = &#123; x: 0, y: 0 &#125;; &#125; handleMouseMove(event) &#123; this.setState(&#123; x: event.clientX, y: event.clientY &#125;); &#125; render() &#123; return ( &lt;div style=&#123; &#123; height: &#x27;100%&#x27; &#125; &#125; onMouseMove=&#123;this.handleMouseMove&#125;&gt; &#123;/* Instead of providing a static representation of what &lt;Mouse&gt; renders, use the `render` prop to dynamically determine what to render. 与提供静态的渲染内容相比较，使用 `render` prop 来决定要渲染的内容更好 */&#125; &#123;this.props.render(this.state)&#125; &lt;/div&gt; ); &#125;&#125;class MouseTracker extends React.Component &#123; render() &#123; return ( &lt;div&gt; &lt;h1&gt;Move the mouse around!&lt;/h1&gt; &lt;Mouse render=&#123;mouse =&gt; ( &lt;Cat mouse=&#123;mouse&#125; /&gt; )&#125;/&gt; &lt;/div&gt; ); &#125;&#125; Now, instead of effectively cloning the &lt;Mouse&gt; component and hard-coding something else in its render method to solve for a specific use case, we provide a render prop that &lt;Mouse&gt; can use to dynamically determine what it renders. 现在，我们通过提供了一个名为 render 的 prop, &lt;Mouse&gt; 组件用它来确定它需要动态地渲染的内容，而不是克隆 &lt;Mouse&gt; 组件并在其render方法中对其渲染的内容进行硬编码。 More concretely, a render prop is a function prop that a component uses to know what to render. 更具体地说，render props 是组件用来知道渲染什么内容的函数 prop。 This technique makes the behavior that we need to share extremely portable. To get that behavior, render a &lt;Mouse&gt; with a render prop that tells it what to render with the current (x, y) of the cursor. 这种技术使我们共享行为非常便携。要获得该行为，只需要使用一个 render prop 渲染 &lt;Mouse&gt;，该 prop 知道如何使用光标的当前（x，y）渲染内容。 One interesting thing to note about render props is that you can implement most higher-order components (HOC) using a regular component with a render prop. For example, if you would prefer to have a withMouse HOC instead of a &lt;Mouse&gt; component, you could easily create one using a regular &lt;Mouse&gt; with a render prop: 关于 render props 的一个有趣的事情是， 你可以使用具有 render props 的常规组件来实现大多数的 高阶组件 （HOC）。例如，如果你希望使用一个 withMouse 的 HOC 而不是 &lt;Mouse&gt; 组件，你可以使用 render prop 轻松创建一个 &lt;Mouse&gt;： // If you really want a HOC for some reason, you can easily// create one using a regular component with a render prop!// 如果你因为某些原因想要实现一个高阶组件，你可以很容易的使用一个接收// render props 的常规的组件来创建一个function withMouse(Component) &#123; return class extends React.Component &#123; render() &#123; return ( &lt;Mouse render=&#123;mouse =&gt; ( &lt;Component &#123;...this.props&#125; mouse=&#123;mouse&#125; /&gt; )&#125;/&gt; ); &#125; &#125;&#125; So using a render prop makes it possible to use either pattern. 因此，使用渲染道具不影响使用其它模式。 Using Props Other Than render（可以使用任意的 props，而不仅仅名为 render 的 prop）It’s important to remember that just because the pattern is called “render props” you don’t have to use a prop named render to use this pattern. In fact, any prop that is a function that a component uses to know what to render is technically a “render prop”. 你需要知道的重要的一点是，这种模式被称为 “render props”，而非你必须使用名为 render 的 prop 来使用此模式。实际上，任意 的被组件用来渲染其内容的函数的 prop 在技术上都是 “render props”。 Although the examples above use render, we could just as easily use the children prop! 虽然上面的例子使用 render 属性，但也可以很很容易地使用 children props！ &lt;Mouse children=&#123;mouse =&gt; ( &lt;p&gt;The mouse position is &#123;mouse.x&#125;, &#123;mouse.y&#125;&lt;/p&gt;)&#125;/&gt; And remember, the children prop doesn’t actually need to be named in the list of “attributes” in your JSX element. Instead, you can put it directly inside the element! 请记住， children prop 不需要在JSX元素的“属性”列表中命名。相反地，你可以把它直接放在元素中！ &lt;Mouse&gt; &#123;mouse =&gt; ( &lt;p&gt;The mouse position is &#123;mouse.x&#125;, &#123;mouse.y&#125;&lt;/p&gt; )&#125;&lt;/Mouse&gt; You’ll see this technique used in the react-motion API. 你能在 react-motion API中看到此技术。 Since this technique is a little unusual, you’ll probably want to explicitly state that children should be a function in your propTypes when designing an API like this. 由于这种技术不常见，因此在设计像这样的 API 时，你最好明确在 propTypes 声明 children 应该是一个函数类型。 Mouse.propTypes = &#123; children: PropTypes.func.isRequired&#125;; Caveats(注意事项)Be careful when using Render Props with React.PureComponent（将 Render Props 与React.PureComponent 一起使用时要小心）Using a render prop can negate the advantage that comes from using React.PureComponent if you create the function inside a render method. This is because the shallow prop comparison will always return false for new props, and each render in this case will generate a new value for the render prop. 如果在 render 方法中创建函数，则使用 render prop 可以会忽视使用 React.PureComponent 所带来的好处。这是因为React.PureComponent 对 props 的浅比较将始终为每次渲染新生成的函数的比较结果返回 false，在这种情况下每次渲染将为 render props 生成新值。 For example, continuing with our &lt;Mouse&gt; component from above, if Mouse were to extend React.PureComponent instead of React.Component, our example would look like this: 例如，对于上面的 &lt;Mouse&gt; 组件，如果 Mouse 要扩展 React.PureComponent 而不是React.Component，我们的示例将如下所示： class Mouse extends React.PureComponent &#123; // Same implementation as above...&#125;class MouseTracker extends React.Component &#123; render() &#123; return ( &lt;div&gt; &lt;h1&gt;Move the mouse around!&lt;/h1&gt; &#123;/* This is bad! The value of the `render` prop will be different on each render. 这很糟糕，`render` prop 的值在每次渲染的时候都会是一个不同的值 */&#125; &lt;Mouse render=&#123;mouse =&gt; ( &lt;Cat mouse=&#123;mouse&#125; /&gt; )&#125;/&gt; &lt;/div&gt; ); &#125;&#125; In this example, each time &lt;MouseTracker&gt; renders, it generates a new function as the value of the &lt;Mouse render&gt; prop, thus negating the effect of &lt;Mouse&gt; extending React.PureComponent in the first place! 在这个例子中，每次 &lt;MouseTracker&gt; 渲染时，它都会生成一个新函数作为 &lt;Mouse render&gt; 的 prop的值，从而使最初 &lt;Mouse&gt; 扩展自 React.PureComponent 的优化效果失效！ To get around this problem, you can sometimes define the prop as an instance method, like so: 要解决此问题， render props 可以将 prop 定义为实例方法，如下所示： class MouseTracker extends React.Component &#123; // Defined as an instance method, `this.renderTheCat` always // refers to *same* function when we use it in render // 定义为实例方法，`this.renderTheCat` 在渲染师将会一直引用同一个方法 renderTheCat(mouse) &#123; return &lt;Cat mouse=&#123;mouse&#125; /&gt;; &#125; render() &#123; return ( &lt;div&gt; &lt;h1&gt;Move the mouse around!&lt;/h1&gt; &lt;Mouse render=&#123;this.renderTheCat&#125; /&gt; &lt;/div&gt; ); &#125;&#125; In cases where you cannot define the prop statically (e.g. because you need to close over the component’s props and/or state) &lt;Mouse&gt; should extend React.Component instead. 如果 render props 无法是静态定义prop（例如，因为 render props 需要关闭组件的 props 和/或状态），那么，&lt;Mouse&gt; 应该扩展 React.Component。","categories":[{"name":"翻译","slug":"翻译","permalink":"http://tcatche.site/categories/%E7%BF%BB%E8%AF%91/"}],"tags":[{"name":"react","slug":"react","permalink":"http://tcatche.site/tags/react/"},{"name":"翻译","slug":"翻译","permalink":"http://tcatche.site/tags/%E7%BF%BB%E8%AF%91/"}]},{"title":"You Probably Don't Need Derived State(也许，你并不需要派生 state)","slug":"react-you-probably-dont-need-derived-state","date":"2018-10-18T12:14:00.000Z","updated":"2018-11-20T08:59:52.000Z","comments":true,"path":"2018/10/react-you-probably-dont-need-derived-state/","link":"","permalink":"http://tcatche.site/2018/10/react-you-probably-dont-need-derived-state/","excerpt":"","text":"翻译自： React Docs: You Probably Don’t Need Derived State React 16.4 included a bugfix for getDerivedStateFromProps which caused some existing bugs in React components to reproduce more consistently. If this release exposed a case where your application was using an anti-pattern and didn’t work properly after the fix, we’re sorry for the churn. In this post, we will explain some common anti-patterns with derived state and our preferred alternatives. React 16.4 包含了 getDerivedStateFromProps 的错误修正，这导致了 React 组件中的一些现有错误更加一致地出现。如果你的应用程序使用了反模式，在 Bugs 修复后无法正常工作，我们很抱歉。在这篇文章中，我们将解释一些常见的使用了派生状态的反模式以及我们推荐的首选替代方案。 For a long time, the lifecycle componentWillReceiveProps was the only way to update state in response to a change in props without an additional render. In version 16.3, we introduced a replacement lifecycle, getDerivedStateFromProps to solve the same use cases in a safer way. At the same time, we’ve realized that people have many misconceptions about how to use both methods, and we’ve found anti-patterns that result in subtle and confusing bugs. The getDerivedStateFromProps bugfix in 16.4 makes derived state more predictable, so the results of misusing it are easier to notice. 长期以来， componentWillReceiveProps 生命周期方法是唯一能够根据 props 的改变更新 state，且没有额外渲染过程的方法。在版本 16.3 中，我们引入了替换的生命周期 getDerivedStateFromProps 以更安全的方式解决这样的用例。与此同时，我们意识到人们对如何使用这两种方法存在许多误解，并且我们发现反模式会导致细微而混乱的错误。在 16.4 中的 Bug 修正 使派生状态更加可预测 ，这也使得滥用它的结果更容易被注意到。 Note All of the anti-patterns described in this post apply to both the older componentWillReceiveProps and the newer getDerivedStateFromProps. 本文中描述的所有反模式都适用于旧的 componentWillReceiveProps 和新的getDerivedStateFromProps 方法。 This blog post will cover the following topics: 本文主要包含以下主题： When to use derived state（什么时候使用派生状态） Common bugs when using derived state（使用派生状态常见的 Bugs） Anti-pattern: Unconditionally copying props to state（反模式：当 props 变化时擦除 state） Anti-pattern: Erasing state when props change（反模式：当 props 变化时擦除 state） Preferred solutions(首选解决方案) What about memoization?（什么是 memoization） When to Use Derived State（什么时候使用派生状态）getDerivedStateFromProps exists for only one purpose. It enables a component to update its internal state as the result of changes in props. Our previous blog post provided some examples, like recording the current scroll direction based on a changing offset prop or loading external data specified by a source prop. getDerivedStateFromProps 仅被设计用于一个目的：组件能够根据 props 的改变 更新其内部维护的 state。我们之前的博客文章提供了一些示例，例如 根据传入的 offset props 的变化更新滚动的方向 和 根据 props 指定的数据源加载外部数据。 We did not provide many examples, because as a general rule, derived state should be used sparingly. All problems with derived state that we have seen can be ultimately reduced to either (1) unconditionally updating state from props or (2) updating state whenever props and state don’t match. (We’ll go over both in more detail below.) 我们没有提供很多示例，因为一般来说，派生状态应该被谨慎的使用。我们所看到的派生状态的所有问题最终可以简化为（1）无条件地从根据 props 更新 state 或（2）即使 props 变化和 state 不匹配也更新状态。（我们将在下面详细介绍这两点。） If you’re using derived state to memoize some computation based only on the current props, you don’t need derived state. See What about memoization? below. 如果你使用的派生状态仅需要根据当前 props 记录计算结果，则不需要派生状态。请参阅后面的 What about memoization? 一节。 If you’re updating derived state unconditionally or updating it whenever props and state don’t match, your component likely resets its state too frequently. Read on for more details. 如果你无条件地更新派生状态不管 props 和 state 是否匹配，则组件可能会过于频繁地重置其状态。继续往下阅读以了解更多。 Common Bugs When Using Derived State（使用派生状态常见的 Bugs）The terms “controlled” and “uncontrolled” usually refer to form inputs, but they can also describe where any component’s data lives. Data passed in as props can be thought of as controlled (because the parent component controls that data). Data that exists only in internal state can be thought of as uncontrolled (because the parent can’t directly change it). 术语 “受控” 和 “不受控制” 通常用于表单输入的元素，但它们也可以被用来描述组件的数据存在位置。作为 props 被传入组件的数据可以被认为是受控的（因为父组件控制该数据）。仅存在于组件内部 state 中的数据可以被认为是不受控制的（因为父级不能直接更改它）。 The most common mistake with derived state is mixing these two; when a derived state value is also updated by setState calls, there isn’t a single source of truth for the data. The external data loading example mentioned above may sound similar, but it’s different in a few important ways. In the loading example, there is a clear source of truth for both the “source” prop and the “loading” state. When the source prop changes, the loading state should always be overridden. Conversely, the state is overridden only when the prop changes and is otherwise managed by the component. 派生 state 最常见的错误是混合这两个点，即派生 state 的值也会被 setState 的调用更新，即数据没有单一的事实来源。上面提到的 外部数据加载示例 看起来与之很相似，但是有几个很重要的不同点。在 “外部数据加载示例 ” 的示例中，“source” props 和 “loading” state 这两个字段都有明确的来源。当 “source” props 改变时，“loading” state 始终应被复写。而且，“loading” state 只有在 “source” props 改变时才被修改，而不是由组件管理 “loading” state 的变化。 Problems arise when any of these constraints are changed. This typically comes in two forms. Let’s take a look at both. 当上面提到的约束被改变时，就会出现问题。通常有两种形式的错误。我们来看看。 Anti-pattern: Unconditionally copying props to state（反模式：无条件的使用 props 更新状态）A common misconception is that getDerivedStateFromProps and componentWillReceiveProps are only called when props “change”. These lifecycles are called any time a parent component rerenders, regardless of whether the props are “different” from before. Because of this, it has always been unsafe to unconditionally override state using either of these lifecycles. Doing so will cause state updates to be lost. 一个常见的误解是，仅当 props “更改” 时，才会调用 getDerivedStateFromProps 和componentWillReceiveProps。实际上，这两个生命周期方法都会在父组件重新渲染时被调用，无论 props 是否和之前不同。因此，始终在这两个生命周期方法中无条件地覆盖 state 是不安全的。这样做会导致状态更新丢失。 Let’s consider an example to demonstrate the problem. Here is a EmailInput component that “mirrors” an email prop in state: 让我们看一个例子来证明这个问题。这里有一个 EmailInput 组件，用于“克隆” email props 到 state 中： class EmailInput extends Component &#123; state = &#123; email: this.props.email &#125;; render() &#123; return &lt;input onChange=&#123;this.handleChange&#125; value=&#123;this.state.email&#125; /&gt;; &#125; handleChange = event =&gt; &#123; this.setState(&#123; email: event.target.value &#125;); &#125;; componentWillReceiveProps(nextProps) &#123; // This will erase any local state updates! // Do not do this. // 这会擦除本地修改的 state ，不要这样做 this.setState(&#123; email: nextProps.email &#125;); &#125;&#125; At first, this component might look okay. State is initialized to the value specified by props and updated when we type into the &lt;input&gt;. But if our component’s parent rerenders, anything we’ve typed into the &lt;input&gt; will be lost! (See this demo for an example.) This holds true even if we were to compare nextProps.email !== this.state.email before resetting. 最开始，这个组件可能看起来没问题。State 被初始化为 props 指定的值，并当我们在 &lt;input&gt; 中输入内容时改变。但是如果组件的父级重新渲染，那么我们输入到 &lt;input&gt; 中的任何内容都将丢失！（查看此演示）即使我们在设置 state 之前比较了 nextProps.email !== this.state.email 也是如此。 In this simple example, adding shouldComponentUpdate to rerender only when the email prop has changed could fix this. However in practice, components usually accept multiple props; another prop changing would still cause a rerender and improper reset. Function and object props are also often created inline, making it hard to implement a shouldComponentUpdate that reliably returns true only when a material change has happened. Here is a demo that shows that happening. As a result, shouldComponentUpdate is best used as a performance optimization, not to ensure correctness of derived state. 在这个例子中，添加 shouldComponentUpdate 在 email props 改变时才重新渲染可以解决上面提到的问题。然而实际上，组件通常接受多个 props ，另一个 prop 的改变仍然会导致组件的重新渲染和不正确的重置 state。函数和对象的 props 也经常被内联的创建，这使得实现一个只有发生 props 更改时才能可靠地返回 true 的 shouldComponentUpdate 很难。这个演示展示了 state 更新被 props 的改变重置。因此， shouldComponentUpdate 最好用来进行性能优化，而不是确保派生 state 的正确性。 Hopefully it’s clear by now why it is a bad idea to unconditionally copy props to state. Before reviewing possible solutions, let’s look at a related problematic pattern: what if we were to only update the state when the email prop changes? 希望你现在很清楚为什么无条件地将 props 复制到 state 是一个坏主意。在回顾可能的解决方案之前，我们来看看一个相关的问题模式：如果我们只是在 email prop 更改时更新 state 会怎样？ Anti-pattern: Erasing state when props change（反模式：当 props 变化时擦除 state）Continuing the example above, we could avoid accidentally erasing state by only updating it when props.email changes: 继续上面的例子，我们可以通过仅在 props.email 更变化时更新它，避免意外地删除 state： class EmailInput extends Component &#123; state = &#123; email: this.props.email &#125;; componentWillReceiveProps(nextProps) &#123; // Any time props.email changes, update state. if (nextProps.email !== this.props.email) &#123; this.setState(&#123; email: nextProps.email &#125;); &#125; &#125; // ...&#125; Note Even though the example above shows componentWillReceiveProps, the same anti-pattern applies to getDerivedStateFromProps. 尽管上面的示例使用了 componentWillReceiveProps，但相同的反模式也适用于getDerivedStateFromProps。 We’ve just made a big improvement. Now our component will erase what we’ve typed only when the props actually change. 我们刚刚做了很大的改进。现在我们的组件将只有在 props 实际发生改变时才会删除我们输入的内容。 There is still a subtle problem. Imagine a password manager app using the above input component. When navigating between details for two accounts with the same email, the input would fail to reset. This is because the prop value passed to the component would be the same for both accounts! This would be a surprise to the user, as an unsaved change to one account would appear to affect other accounts that happened to share the same email. (See demo here.) 还有一个小问题。想象一个使用上述输入组件的密码管理器。当在使用了同一个邮件的两个帐户的详细信息之间导航时，输入的内容将无法被重置。这是因为传递给组件的 props 对于两个帐户都是相同的！这对用户来说很惊奇，因为对一个帐户的未保存更改似乎会影响碰巧使用同一电子邮件的其他帐户（查看这里的演示）。 This design is fundamentally flawed, but it’s also an easy mistake to make. (I’ve made it myself!) Fortunately there are two alternatives that work better. The key to both is that for any piece of data, you need to pick a single component that owns it as the source of truth, and avoid duplicating it in other components. Let’s take a look at each of the alternatives. 这种设计存在根本缺陷，但这也是一个容易犯的错误（我自己也犯错了）。幸运的是，有两种选择更好。它们的关键是，对于任何数据，你需要选择一个组件作为数据的事实来源，并避免在其他组件中重复修改它。我们来看看每个替代方案。 preferred-solutions(首选解决方案)Recommendation: Fully controlled component(建议：完全控制组件)One way to avoid the problems mentioned above is to remove state from our component entirely. If the email address only exists as a prop, then we don’t have to worry about conflicts with state. We could even convert EmailInput to a lighter-weight function component: 避免上述问题的一种方法是完全从组件中删除状态。如果 email 仅做为 props 存在，那么我们不必担心与 state 的冲突。我们甚至可以将 EmailInput 转换为更轻量级的函数式组件： function EmailInput(props) &#123; return &lt;input onChange=&#123;props.onChange&#125; value=&#123;props.email&#125; /&gt;;&#125; This approach simplifies the implementation of our component, but if we still want to store a draft value, the parent form component will now need to do that manually. (Click here to see a demo of this pattern.) 这种方法简化了组件的实现，但如果我们仍想存储中间编辑的草稿值，则父表单组件现在需要手动执行（点击此处查看此模式的演示）。 Recommendation: Fully uncontrolled component with a key（建议：带 key 的完全不受控的组件）Another alternative would be for our component to fully own the “draft” email state. In that case, our component could still accept a prop for the initial value, but it would ignore subsequent changes to that prop: 另一种选择是我们的组件完全拥有 email state 的 “草稿” 值。在这种情况下，我们的组件仍然可以接受一个 初始值 的 prop，但它会忽略该 prop 的后续变化： class EmailInput extends Component &#123; state = &#123; email: this.props.defaultEmail &#125;; handleChange = event =&gt; &#123; this.setState(&#123; email: event.target.value &#125;); &#125;; render() &#123; return &lt;input onChange=&#123;this.handleChange&#125; value=&#123;this.state.email&#125; /&gt;; &#125;&#125; In order to reset the value when moving to a different item (as in our password manager scenario), we can use the special React attribute called key. When a key changes, React will create a new component instance rather than update the current one. Keys are usually used for dynamic lists but are also useful here. In our case, we could use the user ID to recreate the email input any time a new user is selected: 为了在移动到不同的项目时重置值（如在我们的密码管理器场景中），我们可以使用一个名为 key 的特殊 React 属性。当 key 更改时，React 将 创建一个新的组件实例，而不是 更新 当前的组件实例。Keys 通常被用于动态列表，但在此处也很有用。在我们的例子中，我们可以在选择新用户时使用用户 ID 重新创建EmailInput： &lt;EmailInput defaultEmail=&#123;this.props.user.email&#125; key=&#123;this.props.user.id&#125;/&gt; Each time the ID changes, the EmailInput will be recreated and its state will be reset to the latest defaultEmail value. (Click here to see a demo of this pattern.) With this approach, you don’t have to add key to every input. It might make more sense to put a key on the whole form instead. Every time the key changes, all components within the form will be recreated with a freshly initialized state. 每次 ID 更改时，都会重新创建 EmailInput，并将其状态重置为最新的 defaultEmail值（单击此处查看此模式的演示）。使用此方法，你不必为每个输入添加 key。将 key 放在整个表单上可能更有意义。每次 key 更改时，表单中的所有组件都将以新初始化状态重新创建。 In most cases, this is the best way to handle state that needs to be reset. 在大多数情况下，这是处理需要重置的状态的最佳方法。 Note While this may sound slow, the performance difference is usually insignificant. Using a key can even be faster if the components have heavy logic that runs on updates since diffing gets bypassed for that subtree. 虽然这可能听起来很慢，但性能差异通常是微不足道的。如果组件具有繁重的更新逻辑，则使用 key 甚至可以更快，因为该子树可能会绕过了差异比较。 Alternative 1: Reset uncontrolled component with an ID prop（备选 1：使用 ID prop 重置不受控组件）If key doesn’t work for some reason (perhaps the component is very expensive to initialize), a workable but cumbersome solution would be to watch for changes to “userID” in getDerivedStateFromProps: 如果 key 由于某种原因不起作用（可能组件的初始化代价非常昂贵），一个可行但很麻烦的解决方案是在 getDerivedStateFromProps 中监视 userID 的更改： class EmailInput extends Component &#123; state = &#123; email: this.props.defaultEmail, prevPropsUserID: this.props.userID &#125;; static getDerivedStateFromProps(props, state) &#123; // Any time the current user changes, // Reset any parts of state that are tied to that user. // In this simple example, that&#x27;s just the email. if (props.userID !== state.prevPropsUserID) &#123; return &#123; prevPropsUserID: props.userID, email: props.defaultEmail &#125;; &#125; return null; &#125; // ...&#125; This also provides the flexibility to only reset parts of our component’s internal state if we so choose. (Click here to see a demo of this pattern.) 如果愿意，这还可以灵活地仅重置组件内部状态的一部分（点击此处查看此模式的演示）。 Note Even though the example above shows getDerivedStateFromProps, the same technique can be used with componentWillReceiveProps. 尽管上面的示例使用了 getDerivedStateFromProps作为演示，但是 componentWillReceiveProps 也可以使用同样的模式。 Alternative 2: Reset uncontrolled component with an instance method（备选 2：使用实例方法重置不受控组件）More rarely, you may need to reset state even if there’s no appropriate ID to use as key. One solution is to reset the key to a random value or autoincrementing number each time you want to reset. One other viable alternative is to expose an instance method to imperatively reset the internal state: 更少见的是，即使没有适当的 ID 用作key，你也可以重置状态。一种解决方案是每次要重置时将key重置为随机值或自动递增数字。另一个可行的替代方法是使用实例方法以强制重置内部状态： class EmailInput extends Component &#123; state = &#123; email: this.props.defaultEmail &#125;; resetEmailForNewUser(newEmail) &#123; this.setState(&#123; email: newEmail &#125;); &#125; // ...&#125; The parent form component could then use a ref to call this method. (Click here to see a demo of this pattern.) 然后，父表单组件可以使用ref 来调用此方法 （ 点击此处查看此模式的演示）。 Refs can be useful in certain cases like this one, but generally we recommend you use them sparingly. Even in the demo, this imperative method is nonideal because two renders will occur instead of one. Refs 在某些情况下非常有用，但通常我们建议你谨慎使用它们。即使在演示中，这种命令式方法也是不理想的，因为会出现两次渲染而不是一次。 Recap（概括）To recap, when designing a component, it is important to decide whether its data will be controlled or uncontrolled. 总而言之，在设计组件时，确定其数据是受控还是不受控是很重要的。 Instead of trying to “mirror” a prop value in state, make the component controlled, and consolidate the two diverging values in the state of some parent component. For example, rather than a child accepting a “committed” props.value and tracking a “draft” state.value, have the parent manage both state.draftValue and state.committedValue and control the child’s value directly. This makes the data flow more explicit and predictable. 与试图 “拷贝” prop 的值到 state相比，让组件变成受控组件是更好地想法，并在某个父组件的 state 中合并两个不同的值。例如，不让子孙组件接受 “已提交”状态的 props.value 同时跟踪“草稿状态的” state.value，而是让父组件管理 state.draftValue 和 state.committedValue 并直接控制其子孙组件的值。这会使数据流更加明确和可预测。 For uncontrolled components, if you’re trying to reset state when a particular prop (usually an ID) changes, you have a few options: 对于不受控的组件，如果你需要再特定 props（通常是 ID）发生变化时重置其状态，则可以选择以下几种方法： Recomendation: To reset all internal state, use the key attribute. 推荐：要重置所有内部状态，请使用 key 属性。 Alternative 1: To reset only certain state fields, watch for changes in a special property (e.g. props.userID). 备选 1：要仅重置某些状态字段，请注意特殊属性（例如 props.userID ）中的变化。 Alternative 2: You can also consider fall back to an imperative instance method using refs. 备选 2：你还可以考虑使用 refs 回退到调用命令式的实例方法。 What about memoization?（什么是 memoization）We’ve also seen derived state used to ensure an expensive value used in render is recomputed only when the inputs change. This technique is known as memoization. 我们还看到派生 state 用于确保在输入改变时重新计算渲染中使用的昂贵值。这种技术称为memoization。 Using derived state for memoization isn’t necessarily bad, but it’s usually not the best solution. There is inherent complexity in managing derived state, and this complexity increases with each additional property. For example, if we add a second derived field to our component state then our implementation would need to separately track changes to both. 使用派生的 state 进行 memoization 并不一定是坏事，但它通常不是最佳解决方案。管理派生 state 存在固有的复杂性，并且这种复杂性随着每个附加属性而增加。例如，如果我们向组件的 state 添加第二个派生字段，那么我们需要单独跟踪对两者的更改。 Let’s look at an example of one component that takes one prop—a list of items—and renders the items that match a search query entered by the user. We could use derived state to store the filtered list: 让我们看一个组件的示例，该组件接收一个 prop ，一个项目列表 ，并呈现与用户输入的搜索查询匹配的项目。我们可以使用派生 state 来存储过滤后的列表： class Example extends Component &#123; state = &#123; filterText: &quot;&quot;, &#125;; // ******************************************************* // NOTE: this example is NOT the recommended approach. // See the examples below for our recommendations instead. // 注意，这个示例是不推荐的方法，下一个示例是我们推荐使用方法 // ******************************************************* static getDerivedStateFromProps(props, state) &#123; // Re-run the filter whenever the list array or filter text change. // 每当 list 数组和过滤文本改变时都需要重新运行过滤器 // Note we need to store prevPropsList and prevFilterText to detect changes. // 注意到我们需要存储之前的 prevPropsList 和 prevFilterText 用于探测改变 if ( props.list !== state.prevPropsList || state.prevFilterText !== state.filterText ) &#123; return &#123; prevPropsList: props.list, prevFilterText: state.filterText, filteredList: props.list.filter(item =&gt; item.text.includes(state.filterText)) &#125;; &#125; return null; &#125; handleChange = event =&gt; &#123; this.setState(&#123; filterText: event.target.value &#125;); &#125;; render() &#123; return ( &lt;Fragment&gt; &lt;input onChange=&#123;this.handleChange&#125; value=&#123;this.state.filterText&#125; /&gt; &lt;ul&gt;&#123;this.state.filteredList.map(item =&gt; &lt;li key=&#123;item.id&#125;&gt;&#123;item.text&#125;&lt;/li&gt;)&#125;&lt;/ul&gt; &lt;/Fragment&gt; ); &#125;&#125; This implementation avoids recalculating filteredList more often than necessary. But it is more complicated than it needs to be, because it has to separately track and detect changes in both props and state in order to properly update the filtered list. In this example, we could simplify things by using PureComponent and moving the filter operation into the render method: 这种实现需要更频繁地重新计算过滤列表。它比我们的需求更复杂，因为它必须单独跟踪和检测 props 和 state 的变化，以便正确更新过滤后的列表。在这个例子中，我们可以通过使用 PureComponent 并将过滤器操作移动到 render 方法来简化操作： // PureComponents only rerender if at least one state or prop value changes.// PureComponents仅在至少一个 state 或道 prop 值发生变化时才会重新渲染。// Change is determined by doing a shallow comparison of state and prop keys.// 通过对 state 和 prop 进行浅层比较来确定更改。//class Example extends PureComponent &#123; // State only needs to hold the current filter text value: state = &#123; filterText: &quot;&quot; &#125;; handleChange = event =&gt; &#123; this.setState(&#123; filterText: event.target.value &#125;); &#125;; render() &#123; // The render method on this PureComponent is called only if // props.list or state.filterText has changed. // PureComponent 的渲染方法只会在 props.list 或 state.filterText 改变时被调用 const filteredList = this.props.list.filter( item =&gt; item.text.includes(this.state.filterText) ) return ( &lt;Fragment&gt; &lt;input onChange=&#123;this.handleChange&#125; value=&#123;this.state.filterText&#125; /&gt; &lt;ul&gt;&#123;filteredList.map(item =&gt; &lt;li key=&#123;item.id&#125;&gt;&#123;item.text&#125;&lt;/li&gt;)&#125;&lt;/ul&gt; &lt;/Fragment&gt; ); &#125;&#125; The above approach is much cleaner and simpler than the derived state version. Occasionally, this won’t be good enough—filtering may be slow for large lists, and PureComponent won’t prevent rerenders if another prop were to change. To address both of these concerns, we could add a memoization helper to avoid unnecessarily re-filtering our list: 上述方法比派生的 state 版本的代码更清晰，更简单。这仍然不够好——对于大型列表来说可能会很慢，如果另一个 prop 发生变化，PureComponent 也不会阻止重新渲染。为了解决这两个问题，我们可以添加一个 memoization 工具，以避免不必要地重复运行过滤列表的操作： import memoize from &quot;memoize-one&quot;;class Example extends Component &#123; // State only needs to hold the current filter text value: state = &#123; filterText: &quot;&quot; &#125;; // Re-run the filter whenever the list array or filter text changes: filter = memoize( (list, filterText) =&gt; list.filter(item =&gt; item.text.includes(filterText)) ); handleChange = event =&gt; &#123; this.setState(&#123; filterText: event.target.value &#125;); &#125;; render() &#123; // Calculate the latest filtered list. If these arguments haven&#x27;t changed // since the last render, `memoize-one` will reuse the last return value. const filteredList = this.filter(this.props.list, this.state.filterText); return ( &lt;Fragment&gt; &lt;input onChange=&#123;this.handleChange&#125; value=&#123;this.state.filterText&#125; /&gt; &lt;ul&gt;&#123;filteredList.map(item =&gt; &lt;li key=&#123;item.id&#125;&gt;&#123;item.text&#125;&lt;/li&gt;)&#125;&lt;/ul&gt; &lt;/Fragment&gt; ); &#125;&#125; This is much simpler and performs just as well as the derived state version! 这更简单，并且与派生的 state 版本的代码一样好！ When using memoization, remember a couple of constraints: 使用 memoization 时，请记住几个约束： In most cases, you’ll want to attach the memoized function to a component instance. This prevents multiple instances of a component from resetting each other’s memoized keys. 在大多数情况下，你需要将 memoized 函数附加到组件实例。这可以防止组件的多个实例彼此重置影响其他实例。 Typically you’ll want to use a memoization helper with a limited cache size in order to prevent memory leaks over time. (In the example above, we used memoize-one because it only caches the most recent arguments and result.) 通常，你需要使用有限制的缓存 的 memoization 工具，以防止内存泄漏。（在上面的例子中，我们使用了 memoize-one ，因为它只缓存了最新的参数和结果。） None of the implementations shown in this section will work if props.list is recreated each time the parent component renders. But in most cases, this setup is appropriate. 如果每次父组件渲染时都重新创建 props.list，则本节中的任何实现都不起作用。但在大多数情况下，这种设置是合适的。 In closing（结束语）In real world applications, components often contain a mix of controlled and uncontrolled behaviors. This is okay! If each value has a clear source of truth, you can avoid the anti-patterns mentioned above. 在实际应用中，组件通常包含受控和不受控的行为。这没关系！如果每个值都有明确的真正来源，你可以避免上面提到的反模式。 It is also worth re-iterating that getDerivedStateFromProps (and derived state in general) is an advanced feature and should be used sparingly because of this complexity. If your use case falls outside of these patterns, please share it with us on GitHub or Twitter! 值得重新考虑的是，getDerivedStateFromProps（以及一般的派生状态）是一种高级功能，因为其复杂性应该谨慎使用。如果你的用例不在这些模式范围之内，请在 GitHub 或 Twitter 上与我们分享！","categories":[{"name":"翻译","slug":"翻译","permalink":"http://tcatche.site/categories/%E7%BF%BB%E8%AF%91/"}],"tags":[{"name":"react","slug":"react","permalink":"http://tcatche.site/tags/react/"},{"name":"翻译","slug":"翻译","permalink":"http://tcatche.site/tags/%E7%BF%BB%E8%AF%91/"}]},{"title":"React Error Boundaries(错误边界)","slug":"react-error-boundaries","date":"2018-10-18T07:56:00.000Z","updated":"2018-10-18T07:59:58.000Z","comments":true,"path":"2018/10/react-error-boundaries/","link":"","permalink":"http://tcatche.site/2018/10/react-error-boundaries/","excerpt":"","text":"过去，组件内部的 JavaScript 错误经常会破坏 React 的内部状态，并导致它在下一次渲染时发生奇奇怪怪的错误。这些错误通常总是由应用程序代码中的早期错误引起，但在之前版本的 React 没有提供在组件中优雅地处理它们的方法。 针对“部分 UI 的错误不应当导致整个应用的崩溃” 这个理念，React16 引入了一个新的概念 “Error Boundaries（ 错误边界）”。Error Boundaries 是一个特殊的 React 组件， 它用来捕获发生在子组件树的 js 错误，并输出这些错误，显示一个回调的 UI，避免一个组件的一个错误导致整个组件树的崩溃。 在学习它之前，我们先要了解一下它的不适用场景： 哪些地方可以使用 Error Boundaries首先我们要知道，它目前不能捕获这些类型的错误： 事件处理器（Event handlers） 异步代码中的错误，比如 setTimeout 或 requestAnimationFrame 。 服务端渲染（Server side rendering）。 它自身代码抛出的异常。 它可以用来处理的错误： 它可以捕获发生在组件的 render 方法和生命周期方法，以及其子孙组件的 render 方法和生命周期方法所抛出的错误。 使用它也是一个 React 组件，使用方法与其他组件差别不大，区别在于，它需要定义一个新的生命周期方法 componentDidCatch(error, info) : class ErrorBoundary extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; hasError: false &#125;; &#125; componentDidCatch(error, info) &#123; // Display fallback UI this.setState(&#123; hasError: true &#125;); // You can also log the error to an error reporting service logErrorToMyService(error, info); &#125; render() &#123; if (this.state.hasError) &#123; // You can render any custom fallback UI return &lt;h1&gt;Something went wrong.&lt;/h1&gt;; &#125; return this.props.children; &#125;&#125;// use it&lt;ErrorBoundary&gt; &lt;MyWidget /&gt;&lt;/ErrorBoundary&gt; 需要注意的是，在 React16 中，如果有组件发生应该被 Error Boundaries 捕获的错误，而未被任何的 Error Boundaries 所捕获，将会导致整个 React 组件树的卸载。React 官方文档是这样说明其理念的： We debated this decision, but in our experience it is worse to leave corrupted UI in place than to completely remove it. For example, in a product like Messenger leaving the broken UI visible could lead to somebody sending a message to the wrong person. Similarly, it is worse for a payments app to display a wrong amount than to render nothing. 我们讨论了这个决定，根据我们的经验，将发生错误的 UI 留在原地比完全删除它会更糟糕。例如，在像 Messenger 这样的产品中，遗留的发生错误 UI 可能会导致某人向错误的人发送消息。同样，支付 App 显示错误的金额比不提供任何内容的结果更糟糕。 为什么不处理Event Handlers 内的错误与 render 方法和生命周期方法不同，事件处理程序在组件渲染期间不会执行。因此，即使这类错误发生，React 仍然知道应该在屏幕上显示什么，这类错误不需要 Error Boundaries 来处理，使用 try/ catch 处理即可。 参考 React Docs: Error Boundaries","categories":[{"name":"js","slug":"js","permalink":"http://tcatche.site/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"http://tcatche.site/tags/js/"},{"name":"react","slug":"react","permalink":"http://tcatche.site/tags/react/"},{"name":"error","slug":"error","permalink":"http://tcatche.site/tags/error/"}]},{"title":"link 标签的预加载相关属性的简单介绍","slug":"brief_introduction_to_resource-preload","date":"2018-09-10T12:31:00.000Z","updated":"2018-09-10T12:34:32.000Z","comments":true,"path":"2018/09/brief_introduction_to_resource-preload/","link":"","permalink":"http://tcatche.site/2018/09/brief_introduction_to_resource-preload/","excerpt":"","text":"我们知道，浏览器在解析文档的时候如果遇到引入的外部资源，需要下载外部资源，如果有些外部资源比较大，可能会需要一个较长的下载时间，而资源预加载技术就是为了部分解决这样的问题的。 资源预加载顾名思义，就是预测将来可能需要的一些资源，并在当前对这些资源进行预先加载的技术。 很明显，资源预加载对优化当前页面的加载速度并没有什么用处，但是却可以优化用户进行下一次跳转的加载速度。资源预加载主要是通过 link 标签提供的几个不同的 rel 的属性值，进行不同程度的预加载，主要由以下几种不同的策略：dns-prefetch、preconnect、prefetch、preload、prerender。 DNS 预查询：dns-prefetch提示浏览器应该预先进行 DNS 查询，这意味着当真正需要加载相关资源的时候已经预先完成了 DNS 查询，可以跳过这一步，直接向资源发起请求了。 示例： &lt;link rel=&quot;dns-prefetch&quot; href=&quot;//example.com&quot;&gt; 这个比较适用于在网站的主页，强制对整个网站频繁引用的域名进行预解析，这将提高整体站点性能。比如，淘宝就在自己的页面对所有可能用的域名进行了 dns 预查询： &lt;link rel=&quot;dns-prefetch&quot; href=&quot;//g.alicdn.com&quot; /&gt;&lt;link rel=&quot;dns-prefetch&quot; href=&quot;//img.alicdn.com&quot; /&gt;&lt;link rel=&quot;dns-prefetch&quot; href=&quot;//tce.alicdn.com&quot; /&gt;&lt;link rel=&quot;dns-prefetch&quot; href=&quot;//gm.mmstat.com&quot; /&gt;&lt;link ref=&quot;dns-prefetch&quot; href=&quot;//tce.taobao.com&quot; /&gt;&lt;link rel=&quot;dns-prefetch&quot; href=&quot;//log.mmstat.com&quot; /&gt;&lt;link rel=&quot;dns-prefetch&quot; href=&quot;//tui.taobao.com&quot; /&gt;&lt;link rel=&quot;dns-prefetch&quot; href=&quot;//ald.taobao.com&quot; /&gt;&lt;link rel=&quot;dns-prefetch&quot; href=&quot;//gw.alicdn.com&quot; /&gt;&lt;link rel=&quot;dns-prefetch&quot; href=&quot;//atanx.alicdn.com&quot;/&gt;&lt;link rel=&quot;dns-prefetch&quot; href=&quot;//dfhs.tanx.com&quot;/&gt;&lt;link rel=&quot;dns-prefetch&quot; href=&quot;//ecpm.tanx.com&quot; /&gt;&lt;link rel=&quot;dns-prefetch&quot; href=&quot;//res.mmstat.com&quot; /&gt; 如果想要关闭 dns 预加载功能，可以使用 meta 标签： &lt;meta http-equiv=&quot;x-dns-prefetch-control&quot; content=&quot;off&quot;&gt; 预连接：preconnect浏览器建立连接，一般要经过 DNS 查找，TCP 三次握手和TLS协商（https），这些过程都是需要相当的耗时的，dns-prefetch 预先进行了 dns 查找的步骤，而 preconnet 则进一步提前进行了握手的过程，当真正需要加载资源时，不需要再建立连接了，可以直接开始请求数据。 示例： &lt;link rel=&quot;preconnect&quot; href=&quot;//example.com&quot;&gt; prefetch通知浏览器进行预加载资源常见的资源包括图片、脚本、样式、HTML等，当用户跳转到其他页面时，可以减少资源的加载时间。但是注意，具体加载时间和是否加载是由浏览器决定的。 示例： &lt;link rel=&quot;prefetch&quot; href=&quot;//example.com&quot;&gt; 注意，资源虽然加载了但是并不会被解析，脚本也不会被执行。 此时，link 标签可以接受一个 as 属性，它指定了文件内容的类型，表示资源请求的优先级，。 preloadpreload 和 prefetch 类似，通知浏览器预先下载当前页面所需的资源。 示例： &lt;link rel=&quot;preload&quot; href=&quot;//example.com&quot;&gt; 预渲染：prerender这个属性更进一步的，建议浏览器提前获取指定链接的资源，并且它还在预先在屏幕外渲染内容，以便在需要的时候可以快速呈现出来。 示例： &lt;link rel=&quot;prerender&quot; href=&quot;//example.com&quot;&gt; 需要知道的是，chrome 地址栏实际上就进行了 prerender 的操作。 如果想要知道你的页面是否被预渲染，Page Visibility API 提供了探测你的网站是否正在被 prerender 的方法。 更多预渲染相关的知识只是可以查看 Chrome Prerendering 浏览器兼容 can i use..DNS-prefetch can i use..preconnect can i use..preload can i use..prefetch can i use..prerender 参考 MDN: X-DNS-Prefetch-Control Chrome Prerendering","categories":[{"name":"js","slug":"js","permalink":"http://tcatche.site/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"http://tcatche.site/tags/js/"},{"name":"rel","slug":"rel","permalink":"http://tcatche.site/tags/rel/"},{"name":"优化","slug":"优化","permalink":"http://tcatche.site/tags/%E4%BC%98%E5%8C%96/"}]},{"title":"script 标签上的 async 与 defer","slug":"defer-and-async-in-script-tag","date":"2018-09-04T12:04:00.000Z","updated":"2018-11-11T08:27:54.000Z","comments":true,"path":"2018/09/defer-and-async-in-script-tag/","link":"","permalink":"http://tcatche.site/2018/09/defer-and-async-in-script-tag/","excerpt":"","text":"我们知道，html 在解析过程中，如果遇到外部的脚本，会暂停当前页面的解析过程，而是去下载这个引入的外部脚本，然后执行这个外部脚本，这样无疑会导致当前的页面的渲染被阻塞，这也是为什么建议将脚本文件的加载放在文档的最后。 script 标签新增加了两个布尔属性 defer 和 async 用于控制脚本的加载和解析，这两个属性的目的都是为了保证引入的外部的脚本不会阻塞当前页面的渲染过程。 &lt;script async src=&quot;script.js&quot;&gt;&lt;/script&gt;&lt;script defer src=&quot;script.js&quot;&gt;&lt;/script&gt; 其中： defer 指定了脚本在页面在渲染过程中并行加载，但是直到文档解析完成后， DOMContentLoaded 事件触发前执行，效果类似于把 script 标签放在了文档的底部（&lt;/body&gt;前）。 async 指定了脚本在页面在渲染过程中并行加载，但是和 defer 不同的是，当脚本加载完完成后会立即执行，此时如果页面的还未渲染完成，则渲染过程会被打断。 注意：动态插入的脚本 (如使用 document.createElement) 默认是异步执行的（async=true），如果想要其同步执行，需要加上 async=false。 相同点与不同点这两个属性有以下共同点： 它们在加载的时候不会阻塞当前页面的渲染过程。 它们只对引入的外部脚本生效，对内联脚本不生效。 它们是页面渲染中并行加载脚本的，在脚本加载过程中不会打断页面的渲染过程。 document.write 会被忽略，并在控制台上输出类似于这样的错误信息 &quot;A call to &quot;document.write()&quot; from an asynchronously-loaded external script was ignored&quot;。 它们的区别在于： 如果有多个 defer 脚本，defer 脚本的执行是按照 defer 脚本的书写顺序执行的。如果有多个 async 脚本，async 脚本的执行时按照 async 脚本的加载完成的先后顺序执行的，也就是说先加载完的脚本先执行。 defer 脚本不会大段渲染过程，而 async 脚本会打断渲染过程。 两个属性同时使用的时候会忽略 defer 采用 async 模式。 defer 会在DOMContentLoaded 事件触发前执行，而 async 则会在 load 事件之前执行，但并不能确保与 DOMContentLoaded 的执行先后顺序。 如下图，其实已经明显说明了它们的差异： 总结使用这两个属性，可以将脚本的加载放到页面的前面，以便尽可能快的加载完脚本，但是也要根据情况判断使用哪个属性，不能生搬硬套： 比如，如果浏览器不支持这两个属性，放到页面前面加载反而起了负优化的作用。 比如，如果有多个项目依赖的脚本，使用 async 异步加载可能会导致错误，使用 defer 比较好。但是并不是说 async 就没有应用场景了， async 适用于加载不依赖 DOM 的脚本，或者一些独立的小文件，此时我们并不关心文件的执行位置，只需要保证尽快加载完毕，比如加载 GA。 兼容性 can i use defer can i use async","categories":[{"name":"js","slug":"js","permalink":"http://tcatche.site/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"http://tcatche.site/tags/js/"},{"name":"性能","slug":"性能","permalink":"http://tcatche.site/tags/%E6%80%A7%E8%83%BD/"},{"name":"async","slug":"async","permalink":"http://tcatche.site/tags/async/"},{"name":"defer","slug":"defer","permalink":"http://tcatche.site/tags/defer/"}]},{"title":"字符串的重复和补全的新函数","slug":"string-repeate-padstart-padend","date":"2018-08-22T03:28:00.000Z","updated":"2018-08-22T03:32:20.000Z","comments":true,"path":"2018/08/string-repeate-padstart-padend/","link":"","permalink":"http://tcatche.site/2018/08/string-repeate-padstart-padend/","excerpt":"","text":"字符串的重复，追加补全也是常用的操作， ES 的新标准也为字符串添加了几个支持这样操作的函数，提供了操作的方便，之前一直没注意到这几个方法，这里做一个补充。 repeat将源字符串重复多次后返回 string.repeat(count); count 指定字符串重复次数，重复次数不能小于0，如果是小数，会先取整数部分处理。 如果重复次数为小于等于-1的负数（-0.? 会先被取整数部分处理，所以不会报错）或者为 infinity 或者超过字符串的最大长度会抛出 [RangeError](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Errors/Negative_repetition_count) 异常。 示例： `abc`.repeat(2); // &quot;abcabc&quot;`abc`.repeat(2.1); // &quot;abcabc&quot;`abc`.repeat(2.9); // &quot;abcabc&quot;`abc`.repeat(0); // &quot;&quot;`abc`.repeat(-1); // Uncaught RangeError: Invalid count value`abc`.repeat(-0.9); // &quot;&quot; 如果浏览器不支持此方法，可以使用如下的 Polyfill： if (!String.prototype.repeat) &#123; String.prototype.repeat = function(count) &#123; &#x27;use strict&#x27;; if (this == null) &#123; throw new TypeError(&#x27;can\\&#x27;t convert &#x27; + this + &#x27; to object&#x27;); &#125; var str = &#x27;&#x27; + this; count = +count; if (count != count) &#123; count = 0; &#125; if (count &lt; 0) &#123; throw new RangeError(&#x27;repeat count must be non-negative&#x27;); &#125; if (count == Infinity) &#123; throw new RangeError(&#x27;repeat count must be less than infinity&#x27;); &#125; count = Math.floor(count); if (str.length == 0 || count == 0) &#123; return &#x27;&#x27;; &#125; // 确保 count 是一个 31 位的整数。这样我们就可以使用如下优化的算法。 // 当前（2014年8月），绝大多数浏览器都不能支持 1 &lt;&lt; 28 长的字符串，所以： if (str.length * count &gt;= 1 &lt;&lt; 28) &#123; throw new RangeError(&#x27;repeat count must not overflow maximum string size&#x27;); &#125; var rpt = &#x27;&#x27;; for (;;) &#123; if ((count &amp; 1) == 1) &#123; rpt += str; &#125; count &gt;&gt;&gt;= 1; if (count == 0) &#123; break; &#125; str += str; &#125; return rpt; &#125;&#125; padStart, padEnd这两个方法提供了很方便的字符串长度补全，如果字符串的长度达不到指定的长度要求，两个函数分别会在字符串的开头或者结束位置补加上指定字符串，以使字符串达到指定长度。 string.padStart(targetLength [, padString]) staring.padEnd(targetLength [, padString]) targetLength 字符串的目标长度，如果字符串的长度大于这个长度，则返回字符串自身，不作任何操作。 padString 默认为’ ‘，要填充的字符串，如果长度不足则重复此字符串，如果长度超出则截断此字符串。 示例： &#x27;111&#x27;.padStart(10); // &quot; 111&quot;&#x27;111&#x27;.padStart(10, &#x27;abc&#x27;); // &quot;abcabca111&quot;&#x27;11111111&#x27;.padStart(10, &#x27;abc&#x27;); // &quot;ab11111111&quot;&#x27;11111111&#x27;.padStart(3, &#x27;abc&#x27;); // &quot;11111111&quot;&#x27;111&#x27;.padEnd(10); // &quot;111 &quot;&#x27;111&#x27;.padEnd(10, &#x27;abc&#x27;); // &quot;111abcabca&quot;&#x27;11111111&#x27;.padEnd(10, &#x27;abc&#x27;); // &quot;11111111ab&quot;&#x27;11111111&#x27;.padEnd(3, &#x27;abc&#x27;); // &quot;11111111&quot; 如果浏览器不支持此方法，可以使用如下的 Polyfill： // https://github.com/uxitten/polyfill/blob/master/string.polyfill.js// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/padStartif (!String.prototype.padStart) &#123; String.prototype.padStart = function padStart(targetLength,padString) &#123; targetLength = targetLength&gt;&gt;0; //floor if number or convert non-number to 0; padString = String((typeof padString !== &#x27;undefined&#x27; ? padString : &#x27;&#x27;)); if (this.length &gt; targetLength) &#123; return String(this); &#125; else &#123; targetLength = targetLength-this.length; if (targetLength &gt; padString.length) &#123; padString += padString.repeat(targetLength/padString.length); //append to original to ensure we are longer than needed &#125; return padString.slice(0,targetLength) + String(this); &#125; &#125;;&#125; padEnd 操作类似，只不过字符串追加的位置不同，不再补充。不过 polyfill 使用了 string.repeat，所以可能还需要支持 string.repeat 函数。 参考 MDN-repeat MDN-padStart","categories":[{"name":"js","slug":"js","permalink":"http://tcatche.site/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"http://tcatche.site/tags/js/"},{"name":" es6+","slug":"es6","permalink":"http://tcatche.site/tags/es6/"}]},{"title":"JS 中的 this","slug":"about_the_this_point","date":"2018-08-08T08:01:00.000Z","updated":"2018-08-08T08:03:08.000Z","comments":true,"path":"2018/08/about_the_this_point/","link":"","permalink":"http://tcatche.site/2018/08/about_the_this_point/","excerpt":"","text":"JS 中的 this 是一个很容易让人迷糊的概念，本文主要总结了各种情况下的 this 指向。 全局环境中的 this全局环境中的 this 总是指向全局对象 window 上的。 this.a1 = 10;var a2 = 20;console.log(a1); // 10console.log(this.a2); // 20 非箭头函数中的this需要记住一点：在一个函数上下文中，函数中的 this 始终是由函数的调用者提供，若不存在调用者，则非严格模式下 this 指向全局顶级对象（浏览器中为 window 对象），而严格模式下 this 为 undefined。接下来看几个例子： var person = &#123; name: &quot;Jack&quot;, greet: function() &#123; console.log(&quot;Hello, &quot; + this.name); &#125;&#125;;person.greet(); // &quot;Hello, Jack&quot; 很明显，函数的调用者是 person，所以 this 指向 person。 看起来很简单，再看个例子试试： var name = &#x27;Global window&#x27;var personJack = &#123; name: &quot;Jack&quot;, greet: function() &#123; console.log(&quot;Hello, &quot; + this.name); &#125;&#125;;var greet = personJack.greet;var personMack = &#123; name: &quot;Mack&quot;, greet: greet&#125;greet(); // 输出 &quot;Hello, Global window&quot;personMack.greet();// 输出 &quot;Hello, Jack&quot;// 输出// &quot;Hello, Global window&quot;// greet 的调用者为 personJack，所以 this.name 指向 personJack.name&quot;Hello, Jack&quot; 注意，判断函数中 this 的指向，是在执行的时候决定的，而语句 greet() 在执行时，greet 函数并没有调用者，所以，this 指向全局对象 window，所以输出 window.name。 而语句 personMack.greet() 在执行时，greet 的调用者为 personJack，所以 this.name 指向 personJack.name。 再看另一个例子： var name = &#x27;Global&#x27;;var person = &#123; name: &#x27;Person&#x27;, full: &#123; name: &#x27;Person Full&#x27;, getName: function() &#123; return this.name; &#125; &#125;,&#125;;console.log(person.full.getName()); // Person Full 很明显，这次 getName 的调用者是 person.full ，this 指向它。 严格模式（use strict）下的 this在上一节中提到，如果函数的调用者不存在，函数中的 this 则指向全局变量 window，这样无疑在有些情况下会出现难以检查的错误： var name = &#x27;global&#x27;;var obj = &#123; name: &#x27;object&#x27;, getName() &#123; console.log(this.name); &#125;&#125;var getName = obj.getName();getName(); // global 在上面的例子中，由于 window 对象恰好存在一个 name 属性，所以也不会报错。但是，如果代码规格比较大，定位错误无疑是非常困难的。 使用严格模式，如果函数不存在调用者，this 将会指向 undefined 而不再是全局对象 window 了: &#x27;use strict&#x27;var name = &#x27;global&#x27;;var obj = &#123; name: &#x27;object&#x27;, getName() &#123; console.log(this.name); &#125;&#125;var getName = obj.getName;getName(); // Uncaught TypeError: Cannot read property &#x27;name&#x27; of undefined 此时会抛出错误，很容易定位到错误的位置。 关于严格模式的更多细节，请查看 MDN 箭头函数中的this箭头函数中的 this 指向其在 声明时所在的最近的一个非箭头函数 的 this 。并且箭头函数的 this 指向在箭头函数声明后是不会且不能改变的。 function a() &#123; return () =&gt; &#123; return () =&gt; &#123; console.log(this) &#125; &#125;&#125;a()()(); // window 在上面的例子中，最内层箭头函数声明时，最近的非箭头函数是 f(a) 而 f(a) 在执行时没有调用者，this 指向全局变量 window，所以箭头函数的 this 也指向全局变量 window。 如果改变 f(a) 中 this 的指向呢： var obj = &#123; b: b,&#125;obj.a()()(); // obja.bind(window)()()(); // Windowa.bind(obj)()()(); // obj 前面提到“箭头函数的 this 指向在箭头函数声明后是不会且不能改变”，这和上面的例子并不冲突。也就是说箭头函数的指向在声明阶段就已经确定了，比如在上面的例子，箭头函数中的 this 在声明的时候就确定指向了 f(a) 中的 this，但是 f(a) 中的 this 指向的目标可能是在执行阶段才确定的，再看个例子： function b() &#123; var self = this; return () =&gt; &#123; return () =&gt; &#123; console.log(this) console.log(this === self) &#125; &#125;&#125;var obj = &#123; b: b,&#125;obj.b()()(); // obj trueb.bind(window)()()(); // Window trueb.bind(obj)()()(); // obj true 从上面的例子可以看出，箭头函数中的 this 始终指向 f(a) 中的 this。 参数为函数时的 this这种情况看起来很绕，实际上掌握了上面几点后就很简单，看下面的例子： var obj = &#123; data: [1, 2, 3], getDouble: function() &#123; return this.data.map(function(item) &#123; console.log(this); return item * 2 &#125;); &#125;, getTreble: function() &#123; return this.data.map(item =&gt; &#123; console.log(this); return item * 3; &#125;); &#125;&#125;obj.getDouble(); // log windowobj.getTreble(); // log obj 在调用 obj.getEven() 时，需要了解 map 内部是如何执行的,下面是 map 的一个 polyfill： if (Array.prototype.map === undefined) &#123; Array.prototype.map = function(fn) &#123; var rv = []; for(var i=0, l=this.length; i&lt;l; i++) rv.push(fn(this[i])); return rv; &#125;;&#125; 从代码中可以看出，函数在调用时并没有调用者，因此 this 指向 window。而 getTreble 中参数为箭头函数，this 指向和其调用方式没有关系，都指向 obj。 bind、call、apply这三个函数都是用于改变函数中 this 的指向，具体概念及接口不再说明，这里只举一个例子： var obj = &#123; print() &#123; console.log(this); &#125;&#125;var a = obj.print;var b = obj.print.bind(obj);a(); // windowb(); // obj 还有一个场景，如果想要我们的匿名函数能够访问到指定对象，就可以使用 bind，看下面的例子： var a = 10;var obj = &#123; a: 20, getA: function() &#123; setTimeout(function() &#123; console.log(this.a) &#125;.bind(this), 0) &#125;, getB: function() &#123; setTimeout(function() &#123; console.log(this.a) &#125;, 1000) &#125;&#125;obj.getA() // 10obj.getB() // 20","categories":[{"name":"js","slug":"js","permalink":"http://tcatche.site/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"http://tcatche.site/tags/js/"},{"name":"this","slug":"this","permalink":"http://tcatche.site/tags/this/"}]},{"title":"Javascript 原生创建和修改 DOM 节点的方法","slug":"dom_native_elements_and_node_modify","date":"2018-03-13T09:32:00.000Z","updated":"2018-08-02T09:23:06.000Z","comments":true,"path":"2018/03/dom_native_elements_and_node_modify/","link":"","permalink":"http://tcatche.site/2018/03/dom_native_elements_and_node_modify/","excerpt":"","text":"本文总结了常用的 js 进行 DOM 修改的操作，主要总结节点的创建、修改和元素属性的管理的一些相关的操作。 节点创建常用的和节点创建有关的接口主要有：document.createElement、document.createTextNode 、document.createDocumentFragment 、 document.createAttribute 、document.adoptNode 、document.importNode 、node.cloneNode。 document.createElementdocument.createElement(tagName) 这是我们最常用的一个方法了，创建由标签名称（tagName）指定的 HTML 元素，如果标签名称不是一个有效的 HTML 元素，不会报错，会创建一个 HTMLUnknownElement对象。 HTML 对大小写不敏感，所以使用大写或者小写的标签名称都可以，但是注意，标签中不能包含尖括号 &lt;&gt; ，否则会报错。 var newDiv = document.createElement(&#x27;div&#x27;);// orvar newDiv = document.createElement(&#x27;DIV&#x27;);document.createElement(&#x27;&lt;div&gt;&#x27;);// Uncaught DOMException: Failed to execute &#x27;createElement&#x27; on &#x27;Document&#x27;: The tag name provided (&#x27;&lt;div&gt;&#x27;) is not a valid name. 注意，通过 createElement 创建的元素，并未添加到 HTML 文档中，需要调用 appendChild 等节点修改方法将其添加到 HTML 文档树中。后几节创建的其他类型的节点也是如此，后文不再对此进行说明。 document.createTextNodedocument.createTextNode(text) 创建一个文本节点，参数（text）为文本节点的内容。 这个方法返回的节点，被浏览器当作文本渲染，而不是当作 HTML 代码渲染，因此会对 HTML 代码进行转义，可以用来展示用户的输入，避免 XSS 攻击： function escapeUserInput(str) &#123; var div = document.createElement(&#x27;div&#x27;); div.appendChild(document.createTextNode(str)); return div.innerHTML;&#125;var userInput = &#x27;&lt;p&gt;危险内容&lt;/p&gt;&#x27;;var template = &#x27;&lt;div&gt;&#x27; + escapeUserInput(userInput) + &#x27;&lt;/div&gt;&#x27;// 此时被转义，危险内容不再危险&lt;div&gt;&amp;lt;p&amp;gt;危险内容&amp;lt;/p&amp;gt;&lt;/div&gt; 但是，该方法不对单引号和双引号转义，因此用来为属性赋值的时候，仍然会被 XSS 攻击： var userInput = &#x27;&quot; onmouseover=&quot;console.log(\\&#x27;危险操作\\&#x27;)&quot; &quot;&#x27;;var template = &#x27;&lt;div color=&quot;&#x27; + escapeUserInput(userInput) + &#x27;&quot;&gt;user set color&lt;/div&gt;&#x27;// 被注入一个 onmouseover 操作&lt;div color=&quot;&quot; onmouseover=&quot;console.log(&#x27;危险操作&#x27;)&quot; &quot;&quot;&gt;user set color&lt;/div&gt; document.createDocumentFragmentdocument.createDocumentFragment() 方法创建一个新的 DocumentFragment 对象。 DocumentFragments 存在于内存中，并不在 DOM 树存在，将元素插入到文档片段也不会引起回流。因此创建文档片段，并将复杂的 DOM 结构附加到文档片段中，然后将文档片段附加到 DOM 树，可以优化性能。 var ul = document.getElementById(&#x27;list&#x27;);var domfrag = document.createDocumentFragment();for (var i = 0; i &lt; 100; i ++) &#123; var li = document.createElement(&#x27;li&#x27;); li.textContent = i; domfrag.appendChild(li);&#125;ul.appendChild(domfrag); document.createAttributedocument.createAttribute(attrName) 方法创建并返回一个新的属性节点。这个方法不是很常用用，因为添加属性通常用 node.setAttribute 即可： var node = document.getElementById(&#x27;div&#x27;);var attr = document.createAttribute(&#x27;attr&#x27;);attr.nodeValue = &#x27;value&#x27;;node.setAttributeNode(attr);// 等价于node.setAttribute(&#x27;attr&#x27;, &#x27;value&#x27;); document.adoptNodedocument.adoptNode(externalNode) 从其他的 document 中获取一个节点（externalNode），并将该节点以及它的所有子节点从原文档删除, 并且它的 ownerDocument 属性会变成当前的 document。之后你可以把这个节点插入到当前文档中，不常用，了解即可。 // 该函数用来从本文档的第一个 iframe 中获取第一个 element 元素，// 并插入到当前文档树中function getEle()&#123; var iframe = document.getElementsByTagName(&quot;iframe&quot;)[0], ele = iframe.contentWindow.document.body.firstElementChild; if(ele)&#123; document.body.appendChild(document.adoptNode(ele)) &#125;else&#123; alert(&quot;没有更多元素了&quot;) &#125;&#125;document.getElementById(&quot;move&quot;).onclick = getEle 注意，该方法在同一 document 下的不同两个元素中也可以使用，可以实现从左边栏列表中选取某些元素加载到右边栏的功能。 注意，如果节点资源来自不同的源的时候，调用 adoptNode 可能会失败。 有些情况下，将外部文档的节点插入当前文档之前,你需要使用 document.importNode() 从外部文档导入源节点，了解更多细节。 document.importNodedocument.importNode(externalNode, deep) 这个接口也不常用，作用是拷贝外部文档的一个节点（externalNode）。deep 表明是否要导入节点的后代节点，默认为 false 不导入后代节点。 var iframe = document.getElementsByTagName(&quot;iframe&quot;)[0];var oldNode = iframe.contentDocument.getElementById(&quot;myNode&quot;);var newNode = document.importNode(oldNode, true);document.getElementById(&quot;container&quot;).appendChild(newNode); 注意，这个方法仅拷贝节点，此时，节点存在于内存中，还需要插入当前文档中才能显示。 node.cloneNodenode.cloneNode(deep) 方法返回该节点的一个副本，deep 可选，表明是否采用深度克隆，如果为 true，则该节点的所有后代节点也都会被克隆，否则，只克隆该节点本身。 注意，克隆节点会克隆节点的所有属性，但是绑定的事件呢？我们来看一下： 首先看一下使用内联方式直接写在 HTML 标签上的 onevent 事件： &lt;div id=&quot;old&quot;&gt; &lt;p id=&quot;clone&quot; onclick=&quot;console.log(&#x27;click clone&#x27;)&quot;&gt;clone me.&lt;/p&gt;&lt;/div&gt;&lt;div id=&quot;new&quot;&gt;&lt;/div&gt;// cloneNodevar p = document.getElementById(&#x27;clone&#x27;);var newDiv = document.getElementById(&#x27;new&#x27;);newDiv.appendChild(p.cloneNode(true));// test// 点击 #old &gt; #clone&#x27;click clone&#x27;// 点击 #new &gt; #clone&#x27;click clone&#x27;// on-event 属性绑定的事件保留 结果显示，使用内联方式写在 HTML 上的事件是可以的，接下来看一下绑定在节点对象上的 on-event 事件： &lt;div id=&quot;old&quot;&gt; &lt;p id=&quot;clone&quot;&gt;clone me.&lt;/p&gt;&lt;/div&gt;&lt;div id=&quot;new&quot;&gt;&lt;/div&gt;// cloneNodevar p = document.getElementById(&#x27;clone&#x27;);var newDiv = document.getElementById(&#x27;new&#x27;);p.onclick = function() &#123; console.log(&#x27;click clone&#x27;)&#125;;newDiv.appendChild(p.cloneNode(true));// test// 点击 #old &gt; #clone&#x27;click clone&#x27;// 点击 #new &gt; #clone// do nothing// 绑定在对象上的 on-event 事件没有克隆 从测试结果来看，使用 js 绑定在节点对象上的 on-event 事件在克隆的副本并不包含事件处理程序。 接下来再看一下使用 addEventListener 方法添加在这个节点上的事件监听函数： &lt;div id=&quot;old&quot;&gt; &lt;p id=&quot;clone&quot; class=&quot;clone&quot;&gt;clone me.&lt;/p&gt;&lt;/div&gt;&lt;div id=&quot;new&quot;&gt;&lt;/div&gt;// cloneNodevar p = document.getElementById(&#x27;move&#x27;);p.addEventListener(&#x27;click&#x27;, function() &#123; console.log(&#x27;click clone&#x27;);&#125;)var newDiv = document.getElementById(&#x27;new&#x27;);newDiv.appendChild(p.cloneNode(true));// test// 点击 #old &gt; #clone&#x27;click clone&#x27;// 点击 #new &gt; #clone// do nothing// addEventListener 绑定在对象上的事件没有克隆 也就是说，副本节点只能绑定使用内联方式绑定的事件处理函数。 注意，这个拷贝的节点并不在文档中，需要自行添加到文档中。同时拷贝的节点有可能会导致节点的的 id 属性重复，最好修改新节点的 id，而 name 属性也可能重复，自行决定是否需要修改。 节点修改和节点内容修改有关的接口主要有 node.appendChild、 node.insertBefore、 node.removeChild、 node.replaceChild 这四个接口。 node.appendChildparentNode.appendChild(child) 方法将一个节点（child）添加到指定父节点（parentNode）的子节点列表的末尾。本方法返回值为要插入的这个节点。 // 创建一个新的段落p元素,然后添加到body的最尾部var p = document.createElement(&#x27;p&#x27;);document.body.appendChild(p);// p 节点为 body 元素的最后一个子节点 注意，如果被插入的节点已经存在文档树中，则节点会被从原先的位置移除，并插入到新的位置，当然，被移动元素被绑定的事件也会被同步过去： // html&lt;div id=&quot;old&quot;&gt;&lt;p id=&quot;move&quot;&gt;&lt;/p&gt;&lt;/div&gt;&lt;div id=&quot;new&quot;&gt;&lt;/div&gt;var p = document.getElementById(&#x27;move&#x27;);var newDiv = document.getElementById(&#x27;new&#x27;);newDiv.appendChild(p);// new html&lt;div id=&quot;old&quot;&gt;&lt;/div&gt;&lt;div id=&quot;new&quot;&gt;&lt;p id=&quot;move&quot;&gt;move me.&lt;/p&gt;&lt;/div&gt; 如果要保留原来的这个子节点的位置，则可以用 Node.cloneNode 方法复制出一个节点的副本，然后再插入到新位置： // html&lt;div id=&quot;old&quot;&gt;&lt;p id=&quot;move&quot;&gt;&lt;/p&gt;&lt;/div&gt;&lt;div id=&quot;new&quot;&gt;&lt;/div&gt;var p = document.getElementById(&#x27;move&#x27;);var newDiv = document.getElementById(&#x27;new&#x27;);newDiv.appendChild(p.cloneNode(true));// new html&lt;div id=&quot;old&quot;&gt;&lt;p id=&quot;move&quot;&gt;move me.&lt;/p&gt;&lt;/div&gt;&lt;div id=&quot;new&quot;&gt;&lt;p id=&quot;move&quot;&gt;move me.&lt;/p&gt;&lt;/div&gt; 这个方法只能将某个子节点插入到同一个文档的其他位置，如果你想跨文档插入，需要先调用 document.importNode 方法。 还有，如果 appendChild 方法的参数是 DocumentFragment 节点，那么插入的是 DocumentFragment 的所有子节点，而不是 DocumentFragment 节点本身。此时，返回值是一个空的 DocumentFragment 节点。 node.insertBeforeparentNode.insertBefore(child, referenceNode) 方法将一个节点（child）插入作为父节点（parentNode）的一个子节点，并且位置在参考节点（referenceNode）之前。 如果第二个参数 referenceNode 为 null，则插入位置为父节点的末尾： parentNode.insertBefore(node, null);// 等价于parentNode.appendChild(node); 注意，第二个参数为 null 时不能省略，否则会抛出异常： Uncaught TypeError: Failed to execute &#x27;insertBefore&#x27; on &#x27;Node&#x27;: 2 arguments required, but only 1 present. 使用这个方法可以模拟 prependChild，产生类似于 appendChild ，但是将节点插入作为指定父节点的第一个子节点： Node.prototype.prependChild = function(node) &#123; return this.insertBefore(node, this.firstChild);&#125;// html&lt;div id=&quot;div&quot;&gt;&lt;p&gt;原来的第一个子节点&lt;/p&gt;&lt;/div&gt;var div = document.getElementById(&#x27;div&#x27;);var p = document.createElement(&#x27;p&#x27;);p.innerText = &#x27;第一个子节点&#x27;;div.prependChild(p);// new html&lt;div id=&quot;div&quot;&gt;&lt;p&gt;第一个子节点&lt;/p&gt;&lt;p&gt;原来的第一个子节点&lt;/p&gt;&lt;/div&gt; 使用这个方法还可以模拟 insertAfter，将节点要插在父节点的某个子节点后面： Node.prototype.insertAfter = function(node, referenceNode) &#123; return this.insertBefore(node, referenceNode.nextSibling);&#125; 和 appendChild 类似，如果插入的节点是文档中已经存在的节点，则会移动该节点到指定位置，并且保留其绑定的事件。 node.removeChildparentNode.removeChild(child) 删除指定父节点（parentNode）的一个子节点（child），并返回被删除的节点。 注意，这个方法是要在被删除的节点的父节点上调用的，而不是在被删除节点上调用的，如果参数节点不是当前节点的子节点，removeChild 方法将报错： // 通过 parentNode 属性直接删除自身var node = document.getElementById(&#x27;deleteDiv&#x27;);if (node.parentNode) &#123; node.parentNode.removeChild(node);&#125;// 也可以封装以下作为一个方法直接使用:Node.prototype.remove = function(node) &#123; if (node.parentNode) &#123; return node.parentNode.removeChild(node); &#125; throw new Error(&#x27;Can not delete.&#x27;);&#125;node.remove(); 使用这个方法也可以很简单的模拟 removeAllChild ： Node.prototype.removeAllChild = function() &#123; var deleteNode = [] while (this.firstChild) &#123; deleteNode.push(this.removeChild(this.firstChild)); &#125; return deleteNode;&#125; 被移除的这个子节点仍然存在于内存中，只是不在当前文档的 DOM 中，仍然还可以被添加回文档中。但是如果不使用一个变量保存这个节点的引用，被删除的节点将不可达，会在某次垃圾回收被清除。 node.replaceChildparentNode.replaceChild(newChild, oldChild) 方法用指定的节点（newChild）替换当前节点（parentNode）的一个子节点（oldChild），并返回被替换的节点（oldChild）。 &lt;div&gt; &lt;span id=&quot;childSpan&quot;&gt;foo bar&lt;/span&gt;&lt;/div&gt;// 创建一个空的span元素节点// 没有id,没有任何属性和内容var sp1 = document.createElement(&quot;span&quot;);// 添加一个id属性,值为&#x27;newSpan&#x27;，并添加文本内容sp1.setAttribute(&quot;id&quot;, &quot;newSpan&quot;);sp1.innerText = &quot;新的span元素的内容.&quot;;// 获得被替换节点和其父节点的引用.var sp2 = document.getElementById(&quot;childSpan&quot;);var parentDiv = sp2.parentNode;// 用新的span元素sp1来替换掉sp2parentDiv.replaceChild(sp1, sp2);// 结果:&lt;div&gt; &lt;span id=&quot;newSpan&quot;&gt;新的span元素的内容.&lt;/span&gt;&lt;/div&gt; 元素修改元素是节点的一种，除了拥有上一节节点修改的一些方法外，元素还继承了 ParentNode 和 ChildNode 两个接口，因此拥有一些额外的修改方法：继承自 ParentNode 的 ParentNode.append、 ParentNode.prepend 和继承自 ChildNode 的 ChildNode.before 、 ChildNode.after、 ChildNode.remove、 ChildNode.replaceWith 这几个方法。 但是要注意的是，ParentNode 和 ChildNode 这两个都是原始接口，只能在实现了它的对象上使用。如果当前节点是父节点，就会继承 ParentNode 接口。由于只有元素节点（Element）、文档节点（Document）和文档片段节点（DocumentFragment）拥有子节点，因此只有这三类节点会继承 ParentNode 接口。如果一个节点有父节点，那么该节点就继承了 ChildNode 接口。 还要注意的是，这些方法目前都是实验性方法，浏览器的支持度还不太够，未来也可能发生变动，请谨慎使用。 append 和 ParentNode.prependparentNode.append((Node/String) ...nodes) 方法为指定节点的最后一个子节点之后插入一组节点。 和 node.appendChild 方法类似，不同点在于： append 方法允许添加 string 做为参数，并将其包装为文本节点，而 appendChild 方法只能接受 Node 对象作为参数。 append 方法允许添加多个参数，而 appendChild 方法只能接受一个节点。 append 方法没有返回值，而 appendChild 方法返回被添加的节点。 parentNode.prepend(...[Node/String]) 方法为指定节点的第一个子节点之后插入一组节点，其他内容和 append 方法类似，不再说明。 // old html&lt;div id=&quot;div&quot;&gt;&lt;/div&gt;var div = document.getElementById(&#x27;div&#x27;);var p = document.createElement(&quot;p&quot;);var span = document.createElement(&quot;span&quot;);div.append(p);div.append(&quot; End!&quot;);div.prepend(&quot;Begin:&quot;);div.prepend(span);// new html&lt;div id=&quot;div&quot;&gt;&lt;span&gt;&lt;/span&gt;Begin:&lt;p&gt;&lt;/p&gt; End!&lt;/div&gt; 使用 appendChild 和 insertBefore 可以很容易实现如下的 Polyfill： function getDocFrag() &#123; var argArr = Array.prototype.slice.call(arguments), docFrag = document.createDocumentFragment(); argArr.forEach(function (argItem) &#123; var isNode = argItem instanceof Node; docFrag.appendChild(isNode ? argItem : document.createTextNode(String(argItem))); &#125;); return docFrag&#125;(function (arr) &#123; arr.forEach(function (item) &#123; item.append = item.append || function () &#123; this.appendChild(getDocFrag(arguments)); &#125;; item.prepend = item.prepend || function () &#123; this.insertBefore(docFrag, this.firstChild); &#125;; &#125;);&#125;)([Element.prototype, Document.prototype, DocumentFragment.prototype]); ChildNode.before 和 ChildNode.afterchildNode.before(...[Node/String]) 方法在指定节点的前面插入一组节点，childNode.after(...[Node/String]) 方法在指定节点的后面插入一组节点，其他内容和 parentNode.append 方法类似，不再说明。 childNode.replaceWith((Node/String) ...nodes) 用指定节点（nodes），替换当前节点（childNode）。 使用 insertBefore 可以很容易实现如下的 Polyfill： (function (arr) &#123; arr.forEach(function (item) &#123; item.before || function() &#123; this.parentNode.insertBefore(getDocFrag(arguments), this); &#125; item.after || function() &#123; this.parentNode.insertBefore(getDocFrag(arguments), this.nextSibling); &#125; &#125;);&#125;)([Element.prototype, CharacterData.prototype, DocumentType.prototype]); Element.insertAdjacentHTML、 Element.insertAdjacentText如果习惯了使用 jQuery ，就一定会对 jQuery 中的可以直接在参数中使用\u001eHtml 的方式很是喜欢（比如 $(ele).append(&#39;&lt;div&gt;content&lt;/div&gt;&#39;)），而原生的 DOM 也有支持直参数为 Html 的方法。 Element.insertAdjacentHTML(position, text)Element.insertAdjacentText(position, text) position: 这个参数指定了元素的插入位置，取值为以下4种： ‘beforebegin’: 元素自身的前面，效果类似于 childNode.before(ele)。 ‘afterbegin’: 插入元素内部的第一个 子节点 之前，效果类似于 ParentNode.prepend(ele)。 ‘beforeend’: 插入元素内部的最后一个 子节点 之后，效果类似于 ParentNode.append(ele)。 ‘afterend’: 元素自身的后面，效果类似于 childNode.after(ele)。 text: 要插入的文本或者html字符串。 // origin html&lt;div id=&quot;outer&quot;&gt; &lt;div&gt;&lt;/div&gt;&lt;/div&gt;const outer = document.getElementById(&#x27;outer&#x27;);outer.insertAdjacentText(&#x27;beforebegin&#x27;, &#x27;beforebegin 被插入这里&#x27;);outer.insertAdjacentText(&#x27;afterbegin&#x27;, &#x27;afterbegin 被插入这里&#x27;);outer.insertAdjacentText(&#x27;beforeend&#x27;, &#x27;beforeend 被插入这里&#x27;);outer.insertAdjacentText(&#x27;afterend&#x27;, &#x27;afterend 被插入这里&#x27;);// after inserted.beforebegin 被插入这里&lt;div id=&quot;outer&quot;&gt; beforebegin 被插入这里 &lt;div&gt;&lt;/div&gt; beforebegin 被插入这里&lt;/div&gt;beforebegin 被插入这里 两个方法的区别在于 insertAdjacentHTML 方法会将字符串解析为 html，而 insertAdjacentText 不会做解析，因此在不需要解析的情况下（如添加纯文本）使用 insertAdjacentText 性能会更好。 ChildNode.removechildNode.remove() 方法把它从它所属的 DOM 树中删除，没有返回值，所以在删除前，需要先保留引用： // old html&lt;div&gt;&lt;div id=&quot;div&quot;&gt;&lt;/div&gt;&lt;/div&gt;var div = document.getElementById(&#x27;div&#x27;)div.remove();// new html&lt;div&gt;&lt;/div&gt; 使用 removeChild 可以很容易实现如下的 Polyfill： (function (arr) &#123; arr.forEach(function (item) &#123; item.remove = item.remove || function() &#123; this.parentNode.removeChild(this); &#125; &#125;);&#125;)([Element.prototype, CharacterData.prototype, DocumentType.prototype]); ChildNode.replaceWithchildNode.replaceWith((Node/String) ...nodes) 用指定节点（nodes），替换当前节点（childNode）。 使用 replaceChild 可以很容易实现如下的 Polyfill： (function (arr) &#123; arr.forEach(function (item) &#123; item.replaceWith = item.replaceWith || function() &#123; this.parentNode.replaceChild(getDocFrag(arguments), this); &#125; &#125;);&#125;)([Element.prototype, CharacterData.prototype, DocumentType.prototype]); 元素属性操作这些操作仅针对节点类型为 Element 的节点，即元素。 读取属性读取属性可以使用 element.getAttribute(attrName)。如果指定的属性不存在，则返回 null 。（旧版本的浏览器可能会返回空字符串&quot;&quot;） 修改属性修改属性可以使用 element.setAttribute(attrName, attrValue)。 如果此属性已经存在，则更新该值， 否则，将添加一个新的属性用指定的名称和值。 删除属性删除属性可以使用 element.removeAttribute(attrName)。尝试删除不存在的属性并不会引发异常。 注意，当不需要某个属性的时候，优先使用 removeAttribute，而非使用 setAttribute 将属性值设置为 null。 检查属性是否存在检查属性可以使用 element.hasAttribute(attrName)。 修改元素节点对象的属性值当然，可能你已经见过这种操作元素属性的方法： // 修改属性var form = document.getElementById(&#x27;form&#x27;);form.action = &#x27;/submit&#x27;;form.method = &#x27;POST&#x27;;// 读取属性console.log(p.name) 这种方法通过修改元素节点对象的属性值来修改元素的属性，但是有一定的局限性： 1.有些 HTML 的属性名是 Javascript 的保留字，比如 for、class，所以使用的时候必须更改： ele.htmlFor = &quot;someValue&quot;; ele.className = &quot;someValue&quot;;// 等价于ele.setAttribute(&#x27;for&#x27;, &#x27;someValue&#x27;)ele.setAttribute(&#x27;class&#x27;, &#x27;someValue&#x27;) 2.getAttribute 获取的 HTML 属性值都是字符串，而这种方法有时会对某些属性的值进行类型转换，比如，将字符串的 true/false 转为布尔类型，将 onClick 的值转为函数类型。 3.这种方法无法删除属性，即使用 delete 运算符不生效（自定义属性 data-[attr-name]* 是可以删除的）。 4.这种方法对非 HTML 支持的标准属性不生效，尽管这种非标准属性是不建议使用的： // html&lt;div id=&quot;test&quot; test=&quot;true&quot;&gt;&lt;/div&gt;// 读取非标准属性var div = document.getElementById(&#x27;test&#x27;);console.log(div.test); // undefinedconsole.log(div.getAttribute(&#x27;test&#x27;)); // &quot;true&quot;// 修改非标准属性div.test = &quot;false&quot;;console.log(div.getAttribute(&#x27;test&#x27;)); // &quot;true&quot; 标准的自定义属性 data-[attr-name] 则使用 ele.dataset.attrName。 5.元素的属性名大小写不敏感，而 JavaScript 对象的属性名大小写敏感的，并且当属性名包括多个单词，会对属性名进行驼峰拼写法转换： &lt;button onclick=&quot;doSthing&quot;&gt;&lt;/button&gt;button.onClick = doSthing; 优先使用上面提到的四个属性操作的方法进行属性的修改。 获取元素的全部属性Element.attributes 属性返回该元素所有属性节点的一个实时集合。 实时 指的是元素属性的任意变化都会反映在这个属性上： // html&lt;div id=&quot;test&quot; name=&quot;test1&quot;&gt;&lt;/div&gt;var div = document.getElementById(&#x27;test&#x27;);var attrs = div.attributes;console.log(attrs[1].value); // test1div.setAttribute(&#x27;name&#x27;, &#x27;test2&#x27;);console.log(attrs[1].value); // test2 集合是一个类数组结构，大概是这个样子的： // html&lt;div id=&quot;test&quot; name=&quot;test1&quot;&gt;&lt;/div&gt;console.log(attrs);&#123; 0: Attr(id), 1: Attr(name), length: 2, id: Attr(id), name: Attr(name),&#125; 集合的常用操作： // 获取id属性的属性名：attrs.id.nameattrs.id.nodeNameattrs[0].nameattrs[0].nodeName// 获取id属性的属性值：attrs.id.valueattrs[0].value","categories":[{"name":"js","slug":"js","permalink":"http://tcatche.site/categories/js/"}],"tags":[{"name":"DOM","slug":"DOM","permalink":"http://tcatche.site/tags/DOM/"},{"name":"node","slug":"node","permalink":"http://tcatche.site/tags/node/"},{"name":"element","slug":"element","permalink":"http://tcatche.site/tags/element/"},{"name":"HTML","slug":"HTML","permalink":"http://tcatche.site/tags/HTML/"}]},{"title":"Evolving Patterns in React - React 中的模式演化","slug":"evolving-patterns-in-react","date":"2018-03-07T02:48:00.000Z","updated":"2018-08-01T10:41:24.000Z","comments":true,"path":"2018/03/evolving-patterns-in-react/","link":"","permalink":"http://tcatche.site/2018/03/evolving-patterns-in-react/","excerpt":"","text":"翻译自：Evolving Patterns in React Let’s take a closer look at some of the patterns that are emerging in the React ecosystem. These patterns improve readability, code clarity, and push your code towards composition and reusability. 让我们仔细看看出现在 React 生态系统中的一些模式。这些模式可提高你的代码的可读性和清晰度，更加的可组合性和可复用性。 I started working with React roughly about 3 years ago. At that time, there were no established practices from which to learn in order to leverage its capabilities. 大约3年前我开始使用 React 工作，那个时候，还没有一个成熟的可以参考的模式。 It took about 2 years for the community to settle around a few ideas. We shifted from React.createClass to the ES6 class and pure functional components. We dropped mixins and we simplified our APIs. 社区花了大约2年的时间才解决一些想法。我们从 React.createClass 转移到 ES6 类和纯函数组件。我们放弃了mixin，并简化了 API Now as the community is larger than ever, we’re starting to see a couple of nice patterns evolving. 现在，社区比以往更大，我们开始看到一些不错的模式 演变 出来。 In order to understand these patterns you need a basic understanding of the React concepts and its ecosystem. Please note, however, that I will not cover them in this article. 为了理解这些模式，你需要对 React 的概念及其生态系统有一个基本的了解。请注意，我不会在这篇文章中介绍它们。 So let’s begin! Conditional Render（条件渲染）I’ve seen the following scenario in a lot of projects. 我在很多项目都看到过以下场景。 When people think of React and JSX, they still think in terms of HTML and JavaScript. 当人们想到 React 和 JSX 时，他们心里仍然把它们当做 HTML 和 JavaScript。 So the natural step is to separate the conditional logic from the actual return code. 所以自然而然的，会把条件逻辑与实际的返回代码 分开。 const condition = true;const App = () =&gt; &#123; const innerContent = condition ? ( &lt;div&gt; &lt;h2&gt;Show me&lt;/h2&gt; &lt;p&gt;Description&lt;/p&gt; &lt;/div&gt; ) : null; return ( &lt;div&gt; &lt;h1&gt;This is always visible&lt;/h1&gt; &#123; innerContent &#125; &lt;/div&gt; );&#125;; This tends to get out of control, with multiple ternaries at the beginning of each render function. You constantly have to jump inside the function to understand when a certain element is rendered or not. 在每个 render 函数的开始处有多个三元运算符，这往往会失去控制。你必须不断地跳到函数内部来理解某个元素何时被渲染。 As an alternative, try the following pattern, where you benefit from the execution model of the language. 相反，可以尝试以下模式替代，从语言的执行模型中受益。 const condition = true;const App = () =&gt; ( &lt;div&gt; &lt;h1&gt;This is always visible&lt;/h1&gt; &#123; condition &amp;&amp; ( &lt;div&gt; &lt;h2&gt;Show me&lt;/h2&gt; &lt;p&gt;Description&lt;/p&gt; &lt;/div&gt; ) &#125; &lt;/div&gt;); If condition is false, the second operand of the &amp;&amp; operator is not evaluated. If it is true, the second operand —or the JSX we wish to render is returned. 如果 condition 为 false，则 &amp;&amp; 运算符的第二个操作数不会被运算。如果它为 true，则返回第二个操作数或我们想要呈现的JSX。 This allows us to mix UI logic with the actual UI elements in a declarative way! 这使我们能够以 声明 的方式将 UI 逻辑与实际的 UI 元素 混合 在一起！ Treat JSX like it’s an integral part of your code! After all, it’s just JavaScript. 将 JSX 视为代码的一部分！毕竟，它就是 JavaScript。 Passing Down Props（向下传递 Props）When your application grows, you have smaller components that act as containers for other components. 当你的应用程序增长时，会有更小的组件作为其他组件的容器。 As this happens, you need to pass down a good chunk of props through a component. The component doesn’t need them, but its children do. 这时，你需要通过组件传递大量 props。该组件不需要它们，但它的子组件可能需要。 A good way of bypassing this is to use props destructuring together with JSX spread, as you can see here: 一个好的绕过它方法就是对传递给 JSX 的属性使用 属性解构，如下： const Details = ( &#123; name, language &#125; ) =&gt; ( &lt;div&gt; &lt;p&gt;&#123; name &#125; works with &#123; language &#125;&lt;/p&gt; &lt;/div&gt;);const Layout = ( &#123; title, ...props &#125; ) =&gt; ( &lt;div&gt; &lt;h1&gt;&#123; title &#125;&lt;/h1&gt; &lt;Details &#123; ...props &#125; /&gt; &lt;/div&gt;);const App = () =&gt; ( &lt;Layout title=&quot;I&#x27;m here to stay&quot; language=&quot;JavaScript&quot; name=&quot;Alex&quot; /&gt;); So now, you can change the props needed for Details and be sure that those props are not referenced in multiple components. 所以现在，你可以改变 Details 所需要的 Props ，并确保那些 props 没有在其他组件中被多余的引用。 Destructuring Props（解构 Props）An app changes over time, and so do your components. A component you wrote two years ago might be stateful, but now it can be transformed into a stateless one. The other way around also happens a lot of times! 随着时间的推移，你的应用程序和组件也会变化。你两年前写的一个组件可能是有状态的，但现在它可以转化为无状态组件。反之，也会发生！ Since we talked about props destructuring, here’s a good trick I use to make my life easier on the long run. You can destructure your props in a similar manner for both types of components, as you can see below: 之前，我们讨论了属性解构，从长远来看，这是一个让我的生活更轻松的好方法。你可以按照类似的方式为两种不同类型的组件解构属性，如下所示： const Details = ( &#123; name, language &#125; ) =&gt; ( &lt;div&gt; &lt;p&gt;&#123; name &#125; works with &#123; language &#125;&lt;/p&gt; &lt;/div&gt;);class Details extends React.Component &#123; render() &#123; const &#123; name, language &#125; = this.props; return ( &lt;div&gt; &lt;p&gt;&#123; name &#125; works with &#123; language &#125;&lt;/p&gt; &lt;/div&gt; ) &#125;&#125; Notice that lines 2–4 and 11–13 are identical. Transforming components is much easier using this pattern. Also, you limit the usage of this inside the component. 注意第 2-4 行和第 11-13 行是 等价 的。使用这种模式可以更轻松地转换组件。此外，还可以限制组件内部 this 的使用。 Provider Pattern(Provider 模式)We looked at an example where props need to be sent down through another component. But what if you have to send it down 15 components? 前面，我们看了一个例子，Props 需要通过另一个组件传递。但是如果你不得不将它传递给 15 个组件呢？ Enter React Context! This is not necessarily the most recommended feature of React, but it gets the job done when needed. 查看 React Context！这不一定是 React 最推荐的功能，但它可以在需要时完成工作。 It was recently announced that the Context is getting a new API, which implements the provider pattern out of the box. 最近 React 宣布 Context 正在更新一个新的 API，它实现了开箱即用的 provider 模式。 If you are using things like React Redux or Apollo, you might be familiar with the pattern. 如果你正在使用的 React Redux 或 Apollo，你可能会非常熟悉这种模式。 Seeing how it works with today’s API will help you understand the new API as well. You can play around with the following sandbox. 我们来看看它如何与现有的 API 协同工作，这将有助于你理解新的 Context API。你可以在 sandbox 中运行它。 import React from &#x27;react&#x27;;import &#123; render &#125; from &#x27;react-dom&#x27;;import PropTypes from &#x27;prop-types&#x27;;class MousePositionProvider extends React.Component &#123; constructor() &#123; super(); this.state = &#123; &#125;; this.onMouseMove = this.onMouseMove.bind( this ); &#125; getChildContext() &#123; return &#123; posX: this.state.posX, posY: this.state.posY &#125;; &#125; componentDidMount() &#123; window.addEventListener( &quot;mousemove&quot;, this.onMouseMove ); &#125; onMouseMove( e ) &#123; this.setState(&#123; posX: e.clientX, posY: e.clientY &#125;); &#125; render() &#123; return this.props.children &#125;&#125;MousePositionProvider.childContextTypes = &#123; posX: PropTypes.number, posY: PropTypes.number&#125;;class MousePositionConsumer extends React.Component &#123; render() &#123; return ( &lt;div&gt;Your position is ( &#123;this.context.posX&#125;,&#123;this.context.posY&#125; )&lt;/div&gt; ) &#125;&#125;MousePositionConsumer.contextTypes = &#123; posX: PropTypes.number, posY: PropTypes.number&#125;;const App = () =&gt; ( &lt;MousePositionProvider&gt; &lt;div&gt; &lt;MousePositionConsumer /&gt; &lt;MousePositionConsumer /&gt; &lt;/div&gt; &lt;/MousePositionProvider&gt;);render(&lt;App /&gt;, document.getElementById(&#x27;root&#x27;)); The top level component——called Provider——sets some values on the context. The child components——called Consumers——will grab those values from the context. 顶级组件（Provider），在 Context 中设置了一些值。子组件（Consumers），从 Context 中获取这些值。 The current context syntax is a bit strange, but the upcoming version is implementing this exact pattern. 目前的 Context 的语法有点奇怪，但即将推出的新版本正在按照这种模式实现。 High Order Components（高阶组件）Let’s talk about reusability. Together with dropping the old React.createElement() factory, the React team also dropped the support for mixins. They were, at some point, the standard way of composing components through plain object composition. 我们来谈谈可重用性。像被丢弃的旧的 React.createElement() 工厂方法一样，React 团队也放弃了对 mixins 的支持。在某种程度上来说，复合组件的标准方式是通过简单对象的组合。 High Order Components—HOCs from now on—went out to fill the need for reusing behavior across multiple components. 高阶组件 - 现在开始的 HOC - 能够满足跨多个组件重用行为的需求。 A HOC is a function that takes an input component and returns an enhanced/modified version of that component. You will find HOCs under different names, but I like to think of them as decorators. HOC 是一个接收输入组件并返回该组件的 增强或修改 版本的函数。你会发现 HOC 有不同的名称，但我喜欢把它们看作 装饰器。 If you are using Redux, you will recognize that the connect function is a HOC—takes your component and adds a bunch of props to it. 如果你使用 Redux，你会发现 connect 函数就是一个 HOC –接收你的组件，并为它添加一堆 Props。 Let’s implement a basic HOC that can add props to existing components. 我们来实现一个基本的 HOC，它可以为现有的组件添加额外的属性。 const withProps = ( newProps ) =&gt; ( WrappedComponent ) =&gt; &#123; const ModifiedComponent = ( ownProps ) =&gt; ( // the modified version of the component &lt;WrappedComponent &#123; ...ownProps &#125; &#123; ...newProps &#125; /&gt; // original props + new props ); return ModifiedComponent;&#125;;const Details = ( &#123; name, title, language &#125; ) =&gt; ( &lt;div&gt; &lt;h1&gt;&#123; title &#125;&lt;/h1&gt; &lt;p&gt;&#123; name &#125; works with &#123; language &#125;&lt;/p&gt; &lt;/div&gt;);const newProps = &#123; name: &quot;Alex&quot; &#125;; // this is added by the hocconst ModifiedDetails = withProps( newProps )( Details ); // hoc is curried for readabilityconst App = () =&gt; ( &lt;ModifiedDetails title=&quot;I&#x27;m here to stay&quot; language=&quot;JavaScript&quot; /&gt;); If you like functional programming, you will love working with high order components. Recompose is a great package that gives you all these nice utility HOCs like withProps, withContext, lifecycle, and so on. 如果你喜欢函数式编程，你将会喜欢使用高阶组件。Recompose 是一个很好的软件包，可以为你提供所有这些好用的HOC，例如withProps, withContext, lifecycle 等等。 Let’s have a look at a very useful example of reusing functionality. 让我们来看一个很有用的 功能复用 的例子。 function withAuthentication(WrappedComponent) &#123; const ModifiedComponent = (props) =&gt; &#123; if (!props.isAuthenticated) &#123; return &lt;Redirect to=&quot;/login&quot; /&gt;; &#125; return (&lt;WrappedComponent &#123; ...props &#125; /&gt;); &#125;; const mapStateToProps = (state) =&gt; (&#123; isAuthenticated: state.session.isAuthenticated &#125;); return connect(mapStateToProps)(ModifiedComponent);&#125; You can use withAuthentication when you want to render sensitive content inside a route. That content will only be available to logged-in users. 当你想要在一个路由内展示敏感的内容时，你可以使用 withAuthentication ，该内容将只对登录的用户可用。 This is a cross-cutting concern of your application implemented in a single place and reusable across the entire app. 这是一个cross-cutting concern，实现一次，并可以整个应用程序中重用。 However, there is a downside to HOCs. Each HOC will introduce an additional React Component in your DOM/vDOM structure. This can lead to potential performance problems as your application scales. 但是，HOC 有一个缺点。每个 HOC 将在你的 DOM/vDOM 结构中引入一个额外的 React 组件。随着应用程序的扩展，这可能会导致潜在的性能问题。 Some additional problems with HOCs are summarized in this great article by Michael Jackson. He advocates replacing HOCs with the pattern we’ll be talking about next. Michael Jackson 在这篇不错的文章中总结了 HOC 的一些其他问题，他主张用我们接下来要讨论的模式来取代 HOC。 Render PropsWhile it is true that render props and HOCs are interchangeable, I don’t favor one over another. Both patterns are used to improve reusability and code clarity. 尽管 render props 和 HOCs 是可以互换的，但我并不赞成使用一个替换另一个，这两种模式都用于提高代码可复用性和清晰度。 The idea is that you yield the control of your render function to another component that then passes you back the control through a function prop. 这个想法是，你将渲染函数的控制权转让给另一个组件，然后另一个组件通过函数的 prop 传回给你。 Some people prefer to use a dynamic prop for this, some just use **this.props.children**. 有些人只是使用 **this.props.children**，而有些人更喜欢使用动态的 prop。 I know, it’s still very confusing, but let’s see a simple example. 这样听起来仍然很混乱，我们来看一个简单的例子： class ScrollPosition extends React.Component &#123; constructor() &#123; super(); this.state = &#123; position: 0 &#125;; this.updatePosition = this.updatePosition.bind(this); &#125; componentDidMount() &#123; window.addEventListener( &quot;scroll&quot;, this.updatePosition ); &#125; updatePosition() &#123; this.setState( &#123; position: window.pageYOffset &#125; ) &#125; render() &#123; return this.props.children( this.state.position ) &#125;&#125;const App = () =&gt; ( &lt;div&gt; &lt;ScrollPosition&gt; &#123; ( position ) =&gt; ( &lt;div&gt; &lt;h1&gt;Hello World&lt;/h1&gt; &lt;p&gt;You are at &#123; position &#125;&lt;/p&gt; &lt;/div&gt; ) &#125; &lt;/ScrollPosition&gt; &lt;/div&gt;); Here we are using children as the render prop. Inside the &lt;ScrollPosition&gt; component we will send a function which receives the position as a parameter. 我们在这里使用 children 作为渲染道具。在 &lt;ScrollPosition&gt; 组件中，我们将传递一个接收 position 作为参数的函数。 Render props can be used in situations where you need some reusable logic inside the component and you don’t want to wrap your component in a HOC. 渲染道具可用于在组件内部需要一些可重用逻辑，并且你不希望将组件包装在 HOC 中的情况。 React-Motion is one of the libraries that offer some great examples of using render props. React-Motion是一个提供了很好的使用了 render props 例子的库。 Finally, let’s look at how we can integrate async flows with render props. Here’s a nice example of creating a reusable Fetch component. 最后，我们来看看我们如何将 异步 流程与 render props 进行整合。这是一个很好的创建可重用的 Fetch 组件的例子。 I’m sharing a sandbox link so you can play with it and see the results. 我分享一个 sandbox 链接，以便你可以使用它并查看运行结果。 点击查看可运行示例 import React from &#x27;react&#x27;;import &#123; render &#125; from &#x27;react-dom&#x27;;class Fetch extends React.Component &#123; constructor() &#123; super(); this.state = &#123; content: &quot;&quot; &#125; &#125; componentDidMount() &#123; this.setState(&#123; content: this.props.loading() &#125;) fetch(this.props.url) .then(res =&gt; res.json()) .then( res =&gt; this.setState(&#123; content: this.props.done(res) &#125;), res =&gt; this.setState(&#123; content: this.props.error() &#125;) ) &#125; render() &#123; return this.state.content; &#125;&#125;const App = () =&gt; ( &lt;Fetch url=&quot;https://www.booknomads.com/api/v0/isbn/9789029538237&quot; loading=&#123;() =&gt; ( &lt;div&gt;Loading ... &lt;/div&gt; )&#125; done=&#123;(book) =&gt; ( &lt;div&gt;You asked for: &#123; book.Authors[0].Name &#125; - &#123;book.Title&#125;&lt;/div&gt; )&#125; error=&#123;() =&gt; ( &lt;div&gt;Error fetching content&lt;/div&gt; )&#125; /&gt;);render(&lt;App /&gt;, document.getElementById(&#x27;root&#x27;)); You can have multiple render props for the same component. With this pattern, you have endless possibilities of composing and reusing functionality. 你可以为同一个组件提供多个可渲染的 props。有了这种模式，你可以无限制地编写和重用功能。 What patterns do you use? Which of them would fit in this article? Drop me a message bellow or write your thoughts on Twitter. 你使用过什么样的模式？有哪一个适合这篇文章？给我发一封消息，或在 Twitter 上写下你的想法。 If you found this article useful, help me share it with the community!","categories":[{"name":"翻译","slug":"翻译","permalink":"http://tcatche.site/categories/%E7%BF%BB%E8%AF%91/"}],"tags":[{"name":"js","slug":"js","permalink":"http://tcatche.site/tags/js/"},{"name":"react","slug":"react","permalink":"http://tcatche.site/tags/react/"},{"name":"翻译","slug":"翻译","permalink":"http://tcatche.site/tags/%E7%BF%BB%E8%AF%91/"}]},{"title":"Javascript 原生查询 DOM 节点或元素的方法","slug":"dom_native_elements_and_node_query","date":"2018-02-06T02:40:00.000Z","updated":"2018-08-01T10:41:24.000Z","comments":true,"path":"2018/02/dom_native_elements_and_node_query/","link":"","permalink":"http://tcatche.site/2018/02/dom_native_elements_and_node_query/","excerpt":"","text":"最近在重新学习基础知识，本文对常用的 js 进行 DOM 查询的操作进行整理。 基本查询本节主要介绍在文档中通过 id、class、name、css选择器直接进行查询的方式。 id 选择器使用 document.getElementById，根据 id 返回元素，返回值是 Element，如果不存在，则返回 null。 这个接口很简单，只有几点需要注意： 字母 d 小写，这里容易出错。 元素的 id 是大小写敏感的。 如果存在多个 id 一致（这样是不规范的），则返回第一个查找到的元素。 该方法不会搜索不在文档中的元素，当创建了一个新元素，必须插入文档中才能被查询到。 类选择器使用 document.getElementsByClassName，根据 class 查找元素，返回值是 HTMLCollection，如果不存在，则返回 null。 这个函数也很简单，看几个例子： 获取所有 class 中同时包括 ‘red’ 和 ‘test’ 的元素： // 空格隔开多个 classdocument.getElementsByClassName(&#x27;red test&#x27;);// 类似于 jQuery 的$(&#x27;.red.test&#x27;); 在 id 为 ‘main’ 的元素的子节点中，获取所有 class 为’test’的元素 document.getElementById(&#x27;main&#x27;).getElementsByClassName(&#x27;test&#x27;);// 类似于 jQuery 的$(&#x27;#main .test&#x27;); HTMLCollection 是一个类数组对象，可以通过 call、apply 使用数组的一些方法，下面是一个查找所有 class 属性为 ‘test’ 的 div 元素的例子: var testElements = document.getElementsByClassName(&#x27;test&#x27;);var testDivs = Array.prototype.filter.call(testElements, function(testElement)&#123; return testElement.nodeName === &#x27;DIV&#x27;;&#125;);// 也可以使用下文的 css 选择器查询var testDivs = document.querySelectorAll(&#x27;div.test&#x27;); 标签选择器使用 document.getElementsByTagName，根据标签名查找元素，返回值是 HTMLCollection（ W3C 规范说明这些元素是 HTMLCollection，然而这个方法在 WebKit 内核的浏览器中返回一个 NodeList），如果不存在，则返回 null。 该方法类似于 document.getElementsByClassName 不再详细说明。 name 选择器document.getElementsByName 根据元素的 name 属性来查找元素，返回值是 NodeList，如果不存在，则返回 null。 对于不存在 name 属性的 HTML 元素，如果为其设置 name 属性，则该元素也能被选择到，最常见的比如 div 元素。 注意，这个选择器在不同浏览器的效果是不同的，比如在 IE 和 Opera 浏览器下，这个方法也会返回 id 属性为这个值的元素。在使用的时候，应该小心使用，尽量保证 name 不和其他元素的 id 一致。 css 选择器常用的选择器如 id、class、属性选择器 都可以使用 document.querySelector 或 document.querySelectorAll 进行查找，如果没有找到匹配的元素，则返回 null。他们的区别在于 document.querySelector 返回第一个匹配选择器的元素，而 document.querySelectorAll 返回所有匹配的元素（NodeList）。 这个接口使用深度优先的先序遍历文档的节点进行查找： &lt;div&gt; &lt;div class=&quot;test&quot;&gt;first find.&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;test&quot;&gt;second find.&lt;/div&gt;document.querySelectorAll(&quot;.test&quot;).forEach(function(item) &#123; console.log(item.innerText);&#125;)// &quot;first find.&quot;// &quot;second find.&quot; 参数也可以是一系列逗号分隔的多个 css 选择器字符串，搜索的元素顺序和选择器的顺序无关： &lt;div class=&quot;test1&quot;&gt;test1.&lt;/div&gt;&lt;div class=&quot;test2&quot;&gt;test2.&lt;/div&gt;document.querySelectorAll(&quot;.test1, .test2&quot;).forEach(function(item) &#123; console.log(item.innerText);&#125;)// &quot;test1.&quot;// &quot;test2.&quot; 该方法也可以用在元素上： &lt;div class=&quot;test&quot;&gt;&lt;div class=&quot;test1&quot;&gt;test.test1&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;test1&quot;&gt;root.test1&lt;/div&gt;var ele = document.querySelector(&#x27;.test&#x27;);console.log(ele.querySelector(&#x27;.test1&#x27;).innerText);// &quot;test.test1&quot; 但是，在查看 Selectors API 规范 的时候注意到: Even though the method is invoked on an element, selectors are still evaluated in the context of the entire document. 这段话的意思是说，即使在元素上调用函数，选择器仍然是在整个文档的上下文环境进行选择，如下示例： &lt;div class=&quot;test&quot;&gt;&lt;div class=&quot;test1&quot;&gt;test.test1&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;test1&quot;&gt;root.test1&lt;/div&gt;var ele = document.querySelector(&#x27;.test&#x27;);console.log(ele.querySelector(&#x27;body .test1&#x27;).innerText);// &quot;test.test1&quot; 选择器 body .test1 并不在 test 的上下文环境中，但是仍然选中了，它的运行模式更像在整个文档中选择，然后过滤出属于该元素子元素的内容，这样做无疑性能很差。 如果指定的选择器不合法，会抛出 SYNTAX_ERR 异常，所以对于不确定的选择器，需要使用 try...catch 处理异常: try &#123; document.querySelectorAll(&quot;##&quot;)&#125; catch(err) &#123; console.log(&#x27;error selector.&#x27;)&#125;// &quot;error selector.&quot; 注意，本方法返回的 NodeList 是静态的，也即不会随着文档树的变化而更新，而其他接口（如 document.getElementsByName、document.getElementsByClassName） 返回的 HTMLCollection 和 NodeList 都是动态的，内容会随着元素的更新而更新。 使用 CSS 伪类不会返回任何元素。最后再说一次，这个 api 性能不怎么好，如果条件允许，优先使用上面提到的选择器。 Element.matches(selector)如果元素匹配被指定的选择器字符串(selector)，matches 方法返回 true， 否则返回 false。 有一些浏览器使用前缀, 在非标准名称 matchesSelector() 下实现了这个方法，因此可以实现这个 Polyfill： if (!Element.prototype.matches) &#123; Element.prototype.matches = Element.prototype.matchesSelector || Element.prototype.mozMatchesSelector || Element.prototype.msMatchesSelector || Element.prototype.oMatchesSelector || Element.prototype.webkitMatchesSelector || function(s) &#123; return [].indexOf.call(document.querySelectorAll(s), this) !== -1; &#125;;&#125; 关系查询除了上面的基本查询，还存在一些常用的比如查找父元素，查找兄弟元素，查找子元素等操作，这一节看一下这些已知某个元素查找其相关操作。 查询子孙元素首先，节点存在的一些属性就可以做到一些基本的查询： childElementCount 返回给定 Node 的子元素数。 children 返回 Node 的子元素，是一个动态更新的 HTMLCollection。 childNodes 返回给定 Node 的子节点，是一个动态更新的 NodeList，与 children 不同点在于，子节点可能会包含文本节点，注释节点等。 firstChild 返回给定 Node 的第一个子节点。 lastChild 返回给定 Node 的最后一个子节点。 一些查询可能使用的方法： node.contains(otherNode) 返回 otherNode 是否是 node 的后代节点或是 node 节点本身 node.hasChildNodes() 返回一个布尔值，表明当前节点是否包含有子节点。 node.isEqualNode(otherNode) 返回一个布尔值，表明两个节点是否相等。当两个节点的类型相同，定义特征相同（对元素来说，即 id，孩子节点的数量等等），属性一致等，这两个节点就是相等的。 node.isSameNode(otherNode) 返回一个布尔值，表明两个节点是否为同一个节点。 接下来我们使用这些属性和函数来实现一些常见的查询操作： 查询第一个或者最后一个子元素前面提到了 firstChild 和 lastChild 返回的结果是 Node 的第一个或者最后一个节点，但是并不能直接使用，因为它们可能返回的是一个被填充的文本节点，比如下面的 示例： &lt;p id=&quot;para-01&quot;&gt; &lt;span&gt;First span&lt;/span&gt; &lt;span&gt;Middle span&lt;/span&gt; &lt;span&gt;Last span&lt;/span&gt;&lt;/p&gt;var p01 = document.getElementById(&#x27;para-01&#x27;);console.log(p01.firstChild.nodeName)console.log(p01.firstChild.nodeType)// &quot;#text&quot;// 3 之所以出现这种情况，是因为在 &lt;p&gt; 标签和 &lt;span&gt; 标签之前，有一个换行符和多个空格充当了一个文本节点。在浏览器中,任意多个的空白符都将导致文本节点的插入，包括一个到多个空格符、换行符、制表符等等。 这种情况下我们获得的元素实际上并不是我们想要的元素，需要稍微改写一下： /** * Determine whether a node&#x27;s text content is entirely whitespace. * * Throughout, whitespace is defined as one of the characters * &quot;\\t&quot; TAB \\u0009 * &quot;\\n&quot; LF \\u000A * &quot;\\r&quot; CR \\u000D * &quot; &quot; SPC \\u0020 * * @param node A node implementing the |CharacterData| interface (i.e., * a |Text|, |Comment|, or |CDATASection| node * @return True if all of the text content of |nod| is whitespace, * otherwise false. * This does not use Javascript&#x27;s &quot;\\s&quot; because that includes non-breaking * spaces (and also some other characters). */function isAllWhiteSpace(node) &#123; // Use ECMA-262 Edition 3 String and RegExp features return !(/[^\\t\\n\\r ]/.test(node.textContent));&#125;/** * Determine if a node should be ignored by the iterator functions. * * @param node An object implementing the DOM1 |Node| interface. * @return true if the node is: * 1) A |Text| node that is all whitespace * 2) A |Comment| node * and otherwise false. */function isIgnorable(node) &#123; var isComment = node.nodeType === 8; // A comment node var isWhiteSpace = node.nodeType === 3 &amp;&amp; isAllWhiteSpace(node); // a text node and all whitespace return isComment || isWhiteSpace;&#125;function getFirstChild(parent) &#123; var res = parent.firstChild; while (res) &#123; if (!isIgnorable(res)) return res; res = res.nextSibling; &#125; return null;&#125;function getLastChild(parent) &#123; var res = parent.lastChild; while (res) &#123; if (!isIgnorable(res)) return res; res = res.previousSibling; &#125; return null;&#125;console.log(getFirstChild(p01).textContent);console.log(getLastChild(p01).textContent);// &quot;&lt;span&gt;First span&lt;/span&gt;&quot;// &quot;&lt;span&gt;Last span&lt;/span&gt;&quot; 以 getFirstChild 为例，判断 firstChild 是否为注释节点，如果是则跳过，然后判断是否是内容为空、为制表符的文本节点，如果是则跳过，判断下一个节点。 当然也可以换个思路：使用 childNodes 获取一个元素的所有子节点，并过滤掉注释节点和内容为空、为制表符的文本节点： function getMeaningNodes(parent) &#123; return [].filter.call(parent.childNodes, function(node) &#123; return !isIgnorable(node); &#125;);&#125;function getFirstChild(parent) &#123; var nodes = getMeaningNodes(parent); return nodes[0] || null;&#125;function getLastChild(parent) &#123; var nodes = getMeaningNodes(parent); return nodes.length &gt; 0 ? nodes[nodes.length - 1] : null;&#125;console.log(getFirstChild(p01).textContent);console.log(getLastChild(p01).textContent);// &quot;&lt;span&gt;First span&lt;/span&gt;&quot;// &quot;&lt;span&gt;Last span&lt;/span&gt;&quot; 当然一些像 jQuery 的类库会忽略掉文本节点，那么直接使用 ele.children 即可，也不需要再过滤 childNodes 了。 查询第 n 个子节点这里我们可以使用上一节的 getMeaningNodes 方法返回的 node 列表直接查询： function getTheNChild(parent, number) &#123; var nodes = getMeaningNodes(parent); return nodes.length &gt; number ? nodes[number] : null;&#125;console.log(getTheNChild(p01, 0).textContent);console.log(getTheNChild(p01, 1).textContent);console.log(getTheNChild(p01, 2).textContent);console.log(getTheNChild(p01, 3).textContent);// &quot;First span&quot;// &quot;Middle span&quot;// &quot;Last span&quot;// null 查找指定类型的子元素或节点可以在元素上使用上面提到的 getElementsByTagName、getElementsByName、getElementsByClassName 以及 querySelector 前面已经详细介绍过，不再详细说明。 查找兄弟元素或节点查找上一个或者下一个兄弟元素或节点和兄弟元素有关的属性和方法如下： nextSibling 返回当前节点的下一个兄弟节点，没有则返回 null。 nextElementSibling 返回当前元素在其父元素的子元素节点中的上一个元素节点，没有则返回 null。 previousSibling 返回当前节点的前一个兄弟节点，没有则返回 null。 previousElementSibling 返回当前元素在其父元素的子元素节点中的后一个元素节点，没有则返回 null。 这四个属性差不多，区别在于节点可能是注释节点和文本节点，而元素可能会忽略一个文本元素，这个看应用场景，比如 jQuery 就会忽略文本元素： // previous$ele.prev();// 等价于ele.previousElementSibling;// next$ele.next();// 等价于ele.nextElementSibling; 查找全部兄弟元素或节点查找兄弟元素可以选择其父节点的全部子元素，并过滤掉自己： // jQuery$ele.siblings();// 等价于function getSiblings(ele) &#123; var children = ele.parentNode.children; return [].filter.call(children, function(child) &#123; return child !== ele; &#125;);&#125; 查找兄弟节点则可以使用父节点的 childNodes 并过滤一下节点，操作和上面类似不再说明。 查找父节点以及祖先节点和父节点以及祖先节点有关的属性有： parentElement 返回指定的节点的父元素节点。如果该元素没有父节点，或者父节点不是一个元素节点，则返回 null。 parentNode 返回指定的节点在 DOM 树中的父节点。一个元素节点的父节点可能是一个元素(Element)节点,也可能是一个文档(Document)节点,或者是个文档片段(DocumentFragment)节点。如果没有父节点，也返回 null。 Document 和 DocumentFragment 节点没有父节点，因此也返回 null。如果当前节点刚刚被建立，还没有被插入到DOM树中，则该节点的 parentNode 属性也返回 null。 匹配特定选择器且离当前元素最近的祖先元素，即 closest 的实现： // jQuery$ele.closest(selectors);// in Chrome 41+ and firefox 35+element.closest(selectors);// polyfillfunction closest(ele, seector) &#123; const matches = ele.matches || ele.webkitMatchesSelector || ele.mozMatchesSelector || ele.msMatchesSelector; if (matches) &#123; while (ele) &#123; if (matches.call(ele, selector)) &#123; return ele; &#125; else &#123; ele = ele.parentElement; &#125; &#125; &#125; return null;&#125; 参考 W3C Selectors API Level 1 MDN Document Whitespace in the DOM","categories":[{"name":"js","slug":"js","permalink":"http://tcatche.site/categories/js/"}],"tags":[{"name":"DOM","slug":"DOM","permalink":"http://tcatche.site/tags/DOM/"},{"name":"query","slug":"query","permalink":"http://tcatche.site/tags/query/"},{"name":"selector","slug":"selector","permalink":"http://tcatche.site/tags/selector/"}]},{"title":"JavaScript 常用事件之鼠标事件","slug":"broswer_common_mouse_event","date":"2018-01-25T07:26:00.000Z","updated":"2021-05-13T06:41:21.085Z","comments":true,"path":"2018/01/broswer_common_mouse_event/","link":"","permalink":"http://tcatche.site/2018/01/broswer_common_mouse_event/","excerpt":"","text":"鼠标事件是目前最常用的事件，与鼠标操作相关的事件主要有： mousedown, mouseup, click, dblclick, contextmenu, mousemove, mouseover, mouseout。 mousedown, mouseup, click用户点击元素触发的事件顺序为： mousedown，用户在该元素按下鼠标按钮； mouseup，用户在此元素上释放按下的鼠标按钮； click，在此元素上检测到一个 mousedown 和一个 mouseup； 注意，有时用户使用鼠标执行某些操作，但并不会触发 click 事件。例如用户在链接上按下鼠标按钮，然后将鼠标从链接上移开，然后释放鼠标按钮，此时只触发了 mousedown 事件。类似地，如果用户按下鼠标按钮，则将鼠标移动到链接上，然后释放鼠标按钮，此时触发了此元素的 mouseup 事件。这两种情况下下都不会触发点击事件。 dblclickdblclick 事件很少使用。即使使用它，也应该确保不要在同一个 HTML 元素上注册 onclick 和 ondblclick 事件处理程序。毕竟，当用户双击元素时，click 事件将发生在 dblclick 之前。 注意，取消点击事件不会影响触发 dblclick 事件。 双击事件会有一个副作用，就是双击文本会选中文本，查看更多 contextmenu和 click 行为类似，区别在于点击鼠标左键触发 click 事件，点击鼠标右键触发该事件。 注意，该事件和 click 事件类似，也能触发 mousedown 和 mouseup 事件，并且这两个事件先于 contextmenu 事件触发。 mouseover、mouseout 与 mouseenter、mouseleave这两组事件是成对出现，并且行为比较相似，放在一起说。 mouseover 和 mouseenter 都是鼠标进入元素的时候触发的，不同点在于，对于如下的结构： &lt;div class=&quot;lv1&quot;&gt; &lt;div class=&quot;lv2&quot;&gt; &lt;div class=&quot;lv3&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 当鼠标进入 lv3 的时候，会触发单一的 mouseover，并且 mouseover 事件会冒泡，从 lv3 -&gt; lv2 -&gt; lv1 -&gt; ... -&gt; root 这个顺序开始冒泡，如果中间事件被阻止冒泡，则后面元素不能触发这个事件；而 mouseenter 事件不会冒泡，不能取消，相反 lv1、lv2、lv3 都会触发各自的 mouseenter 事件，同时，鼠标从其后代元素移动到自身元素不会再次触发此事件。这意味着，由于层次较深，所发送的 mouseenter 事件的数量可能非常多，容易造成重大的性能问题，在这种情况下，最好监听 mouseover 事件。 mouseout 和 mouseleave 都是在鼠标离开元素的时候触发，并且它们的行为分别很类似于 mouseover 和 mouseenter：当指针离开元素或离开其后代之一（即使指针仍在元素内）时，mouseout 将被触发，并且冒泡；当指针已经退出元素及其所有后代时，此元素的所有祖先元素触发各自的 mouseleave 事件。 看个示例： // html&lt;ul id=&quot;test&quot;&gt; &lt;li&gt;item 1&lt;/li&gt; &lt;li&gt;item 2&lt;/li&gt; &lt;li&gt;item 3&lt;/li&gt;&lt;/ul&gt;// jsvar test = document.getElementById(&quot;test&quot;);// this handler will be executed only once when the cursor moves over the unordered listtest.addEventListener(&quot;mouseenter&quot;, function( event ) &#123; console.log(&quot;mouseenter&quot;);&#125;, false);// this handler will be executed every time the cursor is moved over a different list itemtest.addEventListener(&quot;mouseover&quot;, function( event ) &#123; console.log(&quot;mouseover&quot;);&#125;, false);// this handler will be executed only once when the cursor moves out of the unordered listtest.addEventListener(&quot;mouseleave&quot;, function( event ) &#123; console.log(&quot;mouseleave&quot;);&#125;, false);// this handler will be executed every time the cursor is moved over a different list itemtest.addEventListener(&quot;mouseout&quot;, function( event ) &#123; console.log(&quot;mouseout&quot;);&#125;, false); mousemove当在元素上方移动鼠标时，会触发 mousemove 事件。 即使用户将鼠标移动一个像素，也会触发 mousemove 事件。这会非常的影响系统的性能，最好对此事件优化去抖，同时在不使用的时候移除事件的监听，具体查看本文“其他事件 —— resize 和 scroll” 一节。 wheel当鼠标中键滚动时，触发该事件。基本用不到，有兴趣可以去啃一下 W3C 规范 Wheel Events。 select当文本被选中的时候，select 事件会触发。并非每个元素都能触发这个事件，在 Html5 规范里，只能在 input 和 textarea 上触发该事件。 该事件不提供获得选取内容的接口，如果想要获得选取的内容，可以使用 [document/window].getSelection().toString() 区分点击按键鼠标事件的 which 属性区分了点击的哪个按键： event.which == 1: 左键 event.which == 2: 中键 event.which == 3: 右键 注意 通常情况下并不会用到这个属性，因为点击左键触发 click 事件，点击右键触发 contextmenu 事件，但是它们都会触发 mousedown 和 `mouseup 事件，如果使用这两个事件，可能需要注意一下是否需要区分点击的按键。 鼠标按键组合事件鼠标事件同时也会包含按键的相关信息，常用的控制按键包括： altKey： 当鼠标事件触发时，如果 Alt 键被按下，则返回 true； ctrlKey： 当鼠标事件触发时，如果 Ctrl 键被按下，则返回 true； metaKey： Mac 上特殊属性，等价于 Windows 上的 ctrlKey，当在 Mac 上鼠标事件被触发时，如果 Cmd 键被按下，则返回 true ； shiftKey： 当鼠标事件触发时，如果 Shift 键被按下，则返回 true； 使用控制按键，可以组合出更加丰富的鼠标事件，比如下面是一个支持多选的列表，按住 ctrl 点击选项则多选，否则为单选： &lt;ul id=&quot;list&quot;&gt; &lt;li&gt;li1&lt;/li&gt; &lt;li&gt;li2&lt;/li&gt; &lt;li&gt;li3&lt;/li&gt; &lt;li&gt;li4&lt;/li&gt; &lt;li&gt;li5&lt;/li&gt;&lt;/ul&gt;&lt;script&gt;var selected = [];document.getElementById(&#x27;list&#x27;).addEventListener(&#x27;click&#x27;, function(event) &#123; if (event.ctrlKey) &#123; event.target.style.color = &quot;red&quot;; &#125; else &#123; var liEles = document.getElementsByTagName(&#x27;li&#x27;); for (var i = 0; i &lt; liEles.length; i ++) &#123; liEles[i].style.color = &quot;black&quot;; &#125; event.target.style.color = &quot;red&quot;; &#125;&#125;);&lt;/script&gt; 运行结果如下： 不按 ctrl，单点 li1: li1 变红不按 ctrl，单点 li2：li2 变红,li3 为黑色按住 ctrl 点 li3，多选：li2,li3 变红不按 ctrl，单点 li4：li4 变红，其他为黑色 注意，Mac 下不存在 Ctrl 键，需要使用 Cmd 代替，可以很容易使代码支持 Mac： if (event.ctrlKey || event.metaKey) &#123; event.target.style.color = &quot;red&quot;;&#125; 坐标属性这里是鼠标事件中和坐标相关的属性： offsetX/Y： 点击位置相对于所处元素左上角的位置； clientX/Y： 点击位置相对于浏览器内容区域左上角的位置； screenX/Y： 点击位置相对于屏幕左上角的位置； pageX/Y： 点击位置相对整张页面左上角的位置，pageX/Y 与 clientX/Y 一般情况下会相同，只有出现滚动条时才不一样。 这几个坐标值也没有什么难度，就是很容易混淆，可以现用现查，不再详细说明。 应用：滑动选择器之前项目有个需求，需要滑动选择内容，项目要求鼠标在点击单元格开始选择，然后在多个单元格上滑动，直到按键松开选择结束，这实际上就是 mousedown/mouseover/mouseup 这三个事件的综合应用，这里来看一下如何实现： 首先初始化选择区域: function DragSelector(container) &#123; this._container = $(container);&#125;DragSelector.prototype.init = function(row, column, afterSelected) &#123; this._row = row; this._column = column; var index = 0; for (var i = 0; i &lt; row; i ++) &#123; var ulHtml = &#x27;&lt;ul&gt;&#x27;; for (var j = 0; j &lt; column; j ++) &#123; ulHtml += &#x27;&lt;li data-value=&quot;&#x27; + index + &#x27;&quot;&gt;&lt;/li&gt;&#x27;; index ++; &#125; ulHtml += &#x27;&lt;/ul&gt;&#x27;; this._container.append(ulHtml); &#125; this._afterSelected = afterSelected; return this.bind();&#125;DragSelector.prototype.bind = function() &#123; var self = this; self._selected = []; // bind events&#125;; 然后是重点，绑定事件，这个可以分解为多个任务： 1.使用 mousedown 处理点击后开始选择： // self.draging 标识开始选择，将$(this._container).on(&#x27;mousedown&#x27;, &#x27;li&#x27;, function() &#123; if (!self.draging) &#123; self._draging = true; self._selected.push($(this).data(&#x27;value&#x27;)); $(this).addClass(&#x27;selected&#x27;); &#125;&#125;) 2.使用 mouseover 处理滑动到元素后开始选择： $(this._container).on(&#x27;mouseover&#x27;, &#x27;li&#x27;, function() &#123; if (self._draging) &#123; self._selected.push($(this).data(&#x27;value&#x27;)); $(this).addClass(&#x27;selected&#x27;); &#125;&#125;); 3.使用 mouseup 处理按键松开后结束选择： $(this._container).on(&#x27;mouseup&#x27;, &#x27;li&#x27;, function() &#123; if (self._draging) &#123; self._draging = false; self._afterSelected(self._selected); $(this).addClass(&#x27;selected&#x27;); &#125;&#125;); 这样就是一个简略的滑动选择器，当然没有进行复杂的处理，比如数据去重，比如反选等操作，仅做简单演示。 See the Pen NXZNeV by tcatche (@tcatche) on CodePen. 参考 Events - click No selection on mousedown select","categories":[{"name":"js","slug":"js","permalink":"http://tcatche.site/categories/js/"}],"tags":[{"name":"dom","slug":"dom","permalink":"http://tcatche.site/tags/dom/"},{"name":"bom","slug":"bom","permalink":"http://tcatche.site/tags/bom/"},{"name":"event","slug":"event","permalink":"http://tcatche.site/tags/event/"},{"name":"事件","slug":"事件","permalink":"http://tcatche.site/tags/%E4%BA%8B%E4%BB%B6/"}]},{"title":"JavaScript 常用事件之表单事件","slug":"broswer_common_form_event","date":"2018-01-24T06:55:00.000Z","updated":"2018-08-01T10:41:24.000Z","comments":true,"path":"2018/01/broswer_common_form_event/","link":"","permalink":"http://tcatche.site/2018/01/broswer_common_form_event/","excerpt":"","text":"和表单元素相关的事件有：change、input、compositionstart/compositionupdate/compositionend、focusin/focus、focusout/blur、submit。 changechange 事件可以被 &lt;input&gt;、&lt;textarea&gt;、&lt;select&gt;、checkbox/radio 元素触发,. 注意，对于文本输入内容的改变，也就是说在文本域（input、textarea）输入内容时候，该事件不会触发，直到当文本元素失去焦点 时，触发该事件。 对于 &lt;select&gt;、checkbox/radio 则只要发生变化就能正常触发该事件。 input这个事件和上一个事件相似也是处理表单元素的变化：当 &lt;input&gt;、&lt;textarea&gt;、&lt;select&gt; 元素的值更改时，input 事件会同步的触发。 如果想要处理 &lt;input&gt;、&lt;textarea&gt; 的每个修改，那么这个事件是最好的： &lt;!-- 每次修改，并不会弹出对话框，直到该元素失去焦点才弹出 --&gt;&lt;input type=&quot;text&quot; onchange=&quot;alert(this.value)&quot; /&gt;&lt;!-- 每次修改，即弹出对话框，并且弹出动作发生在元素改变之前 --&gt;&lt;input type=&quot;text&quot; oninput=&quot;alert(this.value)&quot; /&gt; 而对于 checkbox/radio 元素，当用户单击控件时，input 事件不会触发，因为 value 属性没有更改。 &lt;!-- 每次修改，并不会弹出对话框，直到该元素失去焦点才弹出 --&gt;&lt;input type=&quot;checkbox&quot; onchange=&quot;alert(&#x27;Everytime click, This will alert current value：&#x27; + this.value)&quot; /&gt;&lt;!-- 每次修改，即弹出对话框，并且弹出动作发生在元素改变之前 --&gt;&lt;input type=&quot;checkbox&quot; oninput=&quot;alert(&#x27;This will never alert!!!&#x27;)&quot; /&gt; 一些键盘事件如 keyup、keypress 也可以用来监控文本的改变，但是键盘事件对于控制键，比如 Ctrl、 Shift 等也会触发。 注意：这个事件的 Cancelable 值为 false。因此无法取消，event.preventDefault() 不起作用。 compositionstart、compositionupdate、compositionend当我们在使用 input 或者 keyup 事件监控用户的输入的时候，当用户的输入语言是中文的时候，会出现一些问题，比如用户输入“事件”，如果我们监控了 input 事件，则实际上会导致了多次触发事件，比如下面这个例子： 用户使用中文输入法输入 “shijian” 并选中 “事件” 词语，控制台会打印以下结果： ele.addEventListener(&#x27;input&#x27;, function (e) &#123; console.log(value);&#125;);// s// sh// shi// shij// shiji// shijia// shijian// 事件 如果我们根据用户的输入实时向服务端查询数据，则发出了多个无效查询，这堆拼音并不是我们想要查询的内容，我们想要处理的输入文本是“事件”，这个时候，这几个事件就派上了用场。 首先看一下这三个事件在 MDN 的描述： compositionstart：事件触发于一段内容的输入之前（类似于 keydown 事件，但是该事件仅在若干可见字符的输入之前，而这些可见字符的输入可能需要一连串的键盘操作、语音识别或者点击输入法的备选词。 compositionupdate：事件触发于内容被输入到一段文字的时候（此时类似于 input 事件，这些可见字符的输入可能需要一连串的键盘操作、语音识别或者点击输入法的备选词）。 compositionend：事件触发于一段文字的输入之后。 再来看一下事件触发顺序： ele.addEventListener(&#x27;keydown&#x27;, function (e) &#123; console.log(&#x27;keydown&#x27;);&#125;);ele.addEventListener(&#x27;keyup&#x27;, function (e) &#123; console.log(&#x27;keyup&#x27;);&#125;);ele.addEventListener(&#x27;compositionstart&#x27;, function (e) &#123; console.log(&#x27;compositionstart&#x27;);&#125;);ele.addEventListener(&#x27;compositionupdate&#x27;, function (e) &#123; console.log(&#x27;compositionupdate&#x27;);&#125;);ele.addEventListener(&#x27;compositionend&#x27;, function (e) &#123; console.log(&#x27;compositionend&#x27;);&#125;);ele.addEventListener(&#x27;input&#x27;, function (e) &#123; console.log(&#x27;input&#x27;);&#125;);// 当开始输入中文的时候，触发一次 compositionstart：// keydown// compositionstart// compositionupdate// input// keyup// 输入中间字符，循环开始// keydown// compositionupdate// input// keyup// 输入最后一个字符，循环结束，注意 compositionend 事件是在 input 之后 keyup 之前触发。// keydown// compositionupdate// input// compositionend// keyup 知道了这些内容，这样我们就可以这样解决上面的问题： function inputListener(ele, callback) &#123; let inputing = false; elem.addEventListener(&#x27;compositionstart&#x27;, function (e) &#123; inputing = true; &#125;); elem.addEventListener(&#x27;compositionend&#x27;, function (e) &#123; inputing = false; // compositionend 事件在 input 事件之后触发，所以需要在此调用事件处理用户输入 // 如果是处理 keyup 事件，由于 keyup 事件在 compositionend 之后触发，则不要调用 callback callback(e); &#125;); elem.addEventListener(&#x27;input&#x27;, function (e) &#123; if (inputing) return; callback(e); &#125;);&#125;inputListener(ele, function (e) &#123; console.log(value);&#125;);// 使用中文输入法输入 “shijian” 并选中 “事件” 词语，控制台会打印以下结果// 事件 focusin、focus 与 focusout、blur当元素获得焦点的时候可以触发 focusin、focus，两者不同之处在于 focusin 事件冒泡 focus 事件不冒泡，而同理，元素失去焦点的时候可以触发 focusout、blur，两者不同之处在于 focusout 事件冒泡 blur 事件不冒泡。 注意，并不是所有元素都支持这几个事件的。 submit执行提交表单的行为触发的事件。 触发表单事件有三种方式： 点击 &lt;input type=&quot;submit&quot;&gt;、 &lt;input type=&quot;image&quot;&gt; (type=&quot;image&quot; 是图形的提交按钮) 在表单域按(input,textarea 等) Enter 键 调用 form.submit() 使用 event.preventDefault() 可以阻止数据被提交。 注意，在表单元素使用 Enter 提交表单的时候，会触发提交按钮的上的一个点击事件，尽管并没有发生点击： &lt;form&gt; &lt;input type=&quot;text&quot; value=&quot;Focus here and press enter.&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;Submit&quot; onclick=&quot;alert(&#x27;click event triggered&#x27;)&quot;&gt;&lt;/form&gt;","categories":[{"name":"js","slug":"js","permalink":"http://tcatche.site/categories/js/"}],"tags":[{"name":"dom","slug":"dom","permalink":"http://tcatche.site/tags/dom/"},{"name":"bom","slug":"bom","permalink":"http://tcatche.site/tags/bom/"},{"name":"event","slug":"event","permalink":"http://tcatche.site/tags/event/"},{"name":"事件","slug":"事件","permalink":"http://tcatche.site/tags/%E4%BA%8B%E4%BB%B6/"}]},{"title":"React - Reconciliation","slug":"react-reconciliation","date":"2018-01-11T09:26:00.000Z","updated":"2021-05-12T02:29:54.344Z","comments":true,"path":"2018/01/react-reconciliation/","link":"","permalink":"http://tcatche.site/2018/01/react-reconciliation/","excerpt":"","text":"原文：Reconciliation React provides a declarative API so that you don’t have to worry about exactly what changes on every update. This makes writing applications a lot easier, but it might not be obvious how this is implemented within React. This article explains the choices we made in React’s “diffing” algorithm so that component updates are predictable while being fast enough for high-performance apps. React 提供了声明式 API，所以，你不用考虑每次更新都更改了哪些内容。这让你开发应用更加容易，但会使你并不了解 React 内部是如何实现它的。本文解释了我们在 React 的“差异化”算法中做出的选择，以便组件的更新可预测，同时让高性能应用程序也足够快。 动机(Motivation)When you use React, at a single point in time you can think of the render() function as creating a tree of React elements. On the next state or props update, that render() function will return a different tree of React elements. React then needs to figure out how to efficiently update the UI to match the most recent tree. 当你使用 React 时，你可以认为 render() 函数创建了一个 React 元素的树。在下一次状态或属性更新的时候， render() 函数将返回一个不同的 React 元素树。然后 React 需要解决如何有效地更新 UI 以使其匹配最新的元素树。 There are some generic solutions to this algorithmic problem of generating the minimum number of operations to transform one tree into another. However, the state of the art algorithms have a complexity in the order of O(n3) where n is the number of elements in the tree. 目前有一些通用的方案，可以解决用最少的操作步骤将一棵元素树转换为另一棵元素树的这样的算法问题。然而，最先进的算法 也具有O(n3)的复杂度，其中 n 是树中元素的数量。 If we used this in React, displaying 1000 elements would require in the order of one billion comparisons. This is far too expensive. Instead, React implements a heuristic O(n) algorithm based on two assumptions: 1.Two elements of different types will produce different trees.2.The developer can hint at which child elements may be stable across different renders with a key prop. 如果我们在 React 中使用它，则显示 1000 个元素将需要进行 10 亿次比较，这个代价太贵了。相反，基于以下两个假设，实现了启发式的复杂度为 O(n) 的算法： 1.两种不同类型的元素会产生不同的树。2.开发人员可以通过关键属性 key 暗示哪些子元素可以在不同的渲染中保持稳定。 In practice, these assumptions are valid for almost all practical use cases. 实际上，这两个假设对于几乎所有的实践中都是有效的。 Diffing算法(The Diffing Algorithm)When diffing two trees, React first compares the two root elements. The behavior is different depending on the types of the root elements. 在比较两棵树时，React 首先比较它们两个的根元素。根据根元素的类型而有不同行为。 不同类型的元素(Elements Of Different Types)Whenever the root elements have different types, React will tear down the old tree and build the new tree from scratch. Going from &lt;a&gt;&lt;/a&gt; to &lt;img&gt;, or from &lt;Article&gt; to &lt;Comment&gt;, or from &lt;Button&gt; to &lt;div&gt; - any of those will lead to a full rebuild. 每当根元素具有不同的类型时，React 将会销毁旧树并从头开始构建新的树。从 &lt;a&gt; 到 &lt;img&gt;，或从 &lt;Article&gt; 到 &lt;Comment&gt;，或从 &lt;Button&gt; 到 &lt;div&gt; —— 这些都将导致元素完全重建。 When tearing down a tree, old DOM nodes are destroyed. Component instances receive componentWillUnmount(). When building up a new tree, new DOM nodes are inserted into the DOM. Component instances receive componentWillMount() and then componentDidMount(). Any state associated with the old tree is lost. 当销毁旧树时，旧的 DOM 节点被销毁。组件实例执行 componentWillUnmount()。在构建新树时，将新的 DOM 节点插入到 DOM 中。组件实例执行 componentWillMount()，然后执行 componentDidMount()。任何与旧树相关的状态都将丢失。 Any components below the root will also get unmounted and have their state destroyed. For example, when diffing: 根节点下的任何组件也将被卸载，并将其状态（state）销毁。例如，当比较： &lt;div&gt; &lt;Counter /&gt;&lt;/div&gt;&lt;span&gt; &lt;Counter /&gt;&lt;/span&gt; This will destroy the old Counter and remount a new one. 这将会销毁旧的 Counter 组件，并重新挂载一个新的 Counter 组件。 相同类型的DOM元素(DOM Elements Of The Same Type)When comparing two React DOM elements of the same type, React looks at the attributes of both, keeps the same underlying DOM node, and only updates the changed attributes. For example: 当比较类型相同的两个 React DOM 元素时，React 会查看两者的属性，保持相同的底层 DOM 节点，并只更新已修改的属性。例如： &lt;div className=&quot;before&quot; title=&quot;stuff&quot; /&gt;&lt;div className=&quot;after&quot; title=&quot;stuff&quot; /&gt; By comparing these two elements, React knows to only modify the className on the underlying DOM node. 通过比较这两个元素， React 知道仅修改底层 DOM 节点的 className 属性。 When updating style, React also knows to update only the properties that changed. For example: 当更新 style 属性时，React 也知道仅更新发生改变的属性，例如： &lt;div style=&#123; &#123;color: &#x27;red&#x27;, fontWeight: &#x27;bold&#x27;&#125; &#125; /&gt;&lt;div style=&#123; &#123;color: &#x27;green&#x27;, fontWeight: &#x27;bold&#x27;&#125; &#125; /&gt; When converting between these two elements, React knows to only modify the color style, not the fontWeight. 在对这两个元素进行转化时，React 知道只修改 color 样式，而不修改 fontWeight。 After handling the DOM node, React then recurses on the children. 当处理完 DOM 节点后，React 会递归处理其子节点。 相同类型的组件元素(Component Elements Of The Same Type)When a component updates, the instance stays the same, so that state is maintained across renders. React updates the props of the underlying component instance to match the new element, and calls componentWillReceiveProps() and componentWillUpdate() on the underlying instance. 当一个组件更新时，这个实例保持不变，所以状态在整个渲染过程中保持不变。React更新底层组件实例的属性（props）以匹配新元素，并在底层实例上调用 componentWillReceiveProps() 和 componentWillUpdate() 。 Next, the render() method is called and the diff algorithm recurses on the previous result and the new result. 接下来， render() 方法被调用，并且 diff 算法对 render() 方法返回的前一个结果和新结果开始递归执行。 对子元素递归(Recursing On Children)By default, when recursing on the children of a DOM node, React just iterates over both lists of children at the same time and generates a mutation whenever there’s a difference. 默认情况下，在递归 DOM 节点的子元素时，React 只是同时迭代两个树的子节点列表，并且每当子节点出现差异时对其改变。 For example, when adding an element at the end of the children, converting between these two trees works well: 例如，当在子元素的末尾添加一个元素时，在这新旧两棵元素树之间的转化效率很高： &lt;ul&gt; &lt;li&gt;first&lt;/li&gt; &lt;li&gt;second&lt;/li&gt;&lt;/ul&gt;&lt;ul&gt; &lt;li&gt;first&lt;/li&gt; &lt;li&gt;second&lt;/li&gt; &lt;li&gt;third&lt;/li&gt;&lt;/ul&gt; React will match the two &lt;li&gt;first&lt;/li&gt; trees, match the two &lt;li&gt;second&lt;/li&gt; trees, and then insert the &lt;li&gt;third&lt;/li&gt; tree. React 将比较 &lt;li&gt;first&lt;/li&gt; 和 &lt;li&gt;second&lt;/li&gt; 两个树，然后插入 &lt;li&gt;third&lt;/li&gt; 树。 If you implement it naively, inserting an element at the beginning has worse performance. For example, converting between these two trees works poorly: 如果你在最前面插入元素的时候也这么简单的实现它，性能将变得很差。例如，这下面这两棵树之间的转换效果就很差： &lt;ul&gt; &lt;li&gt;Duke&lt;/li&gt; &lt;li&gt;Villanova&lt;/li&gt;&lt;/ul&gt;&lt;ul&gt; &lt;li&gt;Connecticut&lt;/li&gt; &lt;li&gt;Duke&lt;/li&gt; &lt;li&gt;Villanova&lt;/li&gt;&lt;/ul&gt; React will mutate every child instead of realizing it can keep the &lt;li&gt;Duke&lt;/li&gt; and &lt;li&gt;Villanova&lt;/li&gt; subtrees intact. This inefficiency can be a problem. React 会改变每个子元素，而不是意识到它可以保持 &lt;li&gt;Duke&lt;/li&gt; 和 &lt;li&gt;Villanova&lt;/li&gt; 两个子树不变，这种低效率的操作方式是一个问题。 KeysIn order to solve this issue, React supports a key attribute. When children have keys, React uses the key to match children in the original tree with children in the subsequent tree. For example, adding a key to our inefficient example above can make the tree conversion efficient: 为了解决这个问题，React 支持一个 key 属性。当子元素包含有 key 属性的时候，React 使用 key 属性值来匹配原始树中的子元素和新树中的子元素。例如，为我们上面的低效率示例添加一个 key 可以使树的转换变得高效： &lt;ul&gt; &lt;li key=&quot;2015&quot;&gt;Duke&lt;/li&gt; &lt;li key=&quot;2016&quot;&gt;Villanova&lt;/li&gt;&lt;/ul&gt;&lt;ul&gt; &lt;li key=&quot;2014&quot;&gt;Connecticut&lt;/li&gt; &lt;li key=&quot;2015&quot;&gt;Duke&lt;/li&gt; &lt;li key=&quot;2016&quot;&gt;Villanova&lt;/li&gt;&lt;/ul&gt; Now React knows that the element with key &#39;2014&#39; is the new one, and the elements with the keys &#39;2015&#39; and &#39;2016&#39; have just moved. 现在React知道 key 为 &#39;2014&#39; 的元素是新元素， key 为 &#39;2015&#39; 和 &#39;2016&#39; 的元素只需要移动即可。 In practice, finding a key is usually not hard. The element you are going to display may already have a unique ID, so the key can just come from your data: 在实践中，找到一个 key 通常不难。你要显示的元素一般有一个唯一的 ID，所以 key 可以来自你的数据： &lt;li key=&#123;item.id&#125;&gt;&#123;item.name&#125;&lt;/li&gt; When that’s not the case, you can add a new ID property to your model or hash some parts of the content to generate a key. The key only has to be unique among its siblings, not globally unique. 如果并非如此，你可以将新的 ID 属性添加到模型中，或者对内容的某些部分进行哈希以生成它。关键只在于它在它的兄弟姐妹是独一无二的，而不需要在全局中唯一。 As a last resort, you can pass an item’s index in the array as a key. This can work well if the items are never reordered, but reorders will be slow. 作为最后的手段，你可以传递数组中的元素索引作为 key。如果列表从未重新排序，这可以很好地工作。但重新排序将会变慢。 Reorders can also cause issues with component state when indexes are used as keys. Component instances are updated and reused based on their key. If the key is an index, moving an item changes it. As a result, component state for things like controlled inputs can get mixed up and updated in unexpected ways. 但当使用索引用作 key 时，重新排序也会导致组件状态的问题。组件实例基于它的 key 进行更新和重用。如果 key 是索引，则移动项目会改变它的 key。因此，像受控输入之类的组件状态可能会以意想不到的方式发生混淆和被更新。 Here is an example of the issues that can be caused by using indexes as keys on CodePen, and here is a updated version of the same example showing how not using indexes as keys will fix these reordering, sorting, and prepending issues. 这里是 CodePen 上使用索引作为 key 可能导致的问题的一个例子，这里 是同一个例子的更新版本，展示了不使用索引作为 key 将解决这些排序、重新排序和潜在的问题。 权衡(Tradeoffs)It is important to remember that the reconciliation algorithm is an implementation detail. React could rerender the whole app on every action; the end result would be the same. Just to be clear, rerender in this context means calling render for all components, it doesn’t mean React will unmount and remount them. It will only apply the differences following the rules stated in the previous sections. 要知道 reconciliation 算法仅仅是 React 的一个实现细节。 React 可以在每个操作上重新渲染整个应用程序，而最终的结果将是一样的。你需要了解，在这种情况下重新渲染意味着为所有组件调用渲染，并不意味着 React 将卸载并重新加载这些，它只会按照前面章节所述的规则进行工作。 We are regularly refining the heuristics in order to make common use cases faster. In the current implementation, you can express the fact that a subtree has been moved amongst its siblings, but you cannot tell that it has moved somewhere else. The algorithm will rerender that full subtree. 为了更快地创建通用用例，我们定期改进我们的启发式算法。在目前的实现中，你可以知道的是，子树已经在其兄弟姐妹之间移动，但是你不必了解它被移动到哪里。该算法将重新渲染完整的子树。 Because React relies on heuristics, if the assumptions behind them are not met, performance will suffer. 因为 React 依赖这个启发式，如果不满足它们背后的假设，性能将受到影响。 The algorithm will not try to match subtrees of different component types. If you see yourself alternating between two component types with very similar output, you may want to make it the same type. In practice, we haven’t found this to be an issue. Keys should be stable, predictable, and unique. Unstable keys (like those produced by Math.random()) will cause many component instances and DOM nodes to be unnecessarily recreated, which can cause performance degradation and lost state in child components. 该算法不会尝试匹配不同组件类型的子树。如果你发现自己在输出非常相似的两种组件之间交替转换，则应该使它们的类型相同。实际上，我们并没有发现这样的问题。 Keys应该是稳定的，可预测的和唯一的。不稳定的keys（如 Math.random() 生成的）将导致许多组件实例和 DOM 节点被不必要地重新创建，这可能会导致子组件中的性能下降和状态丢失。","categories":[{"name":"翻译","slug":"翻译","permalink":"http://tcatche.site/categories/%E7%BF%BB%E8%AF%91/"}],"tags":[{"name":"react","slug":"react","permalink":"http://tcatche.site/tags/react/"},{"name":"翻译","slug":"翻译","permalink":"http://tcatche.site/tags/%E7%BF%BB%E8%AF%91/"}]},{"title":"关于 rel=\"noopener noreferrer\"","slug":"a-blank-must-set-rel-noopener","date":"2018-01-10T09:13:00.000Z","updated":"2018-08-01T10:41:24.000Z","comments":true,"path":"2018/01/a-blank-must-set-rel-noopener/","link":"","permalink":"http://tcatche.site/2018/01/a-blank-must-set-rel-noopener/","excerpt":"","text":"在使用 ESlint 的时候发现，当使用新标签打开外部链接时候（target=&quot;_black&quot;）， eslint-plugin-react 插件报出了错误： Prevent usage of unsafe target=&#x27;_blank&#x27; (react/jsx-no-target-blank) 查了下发现这是一个一直被忽视的很严重的安全问题。 危险的 target=”_blank”假设在我们的这个页面（www.me.com）引入了外部的打开了外部的一个网页（www.out.com）： &lt;!-- www.me.com --&gt;&lt;html lang=&quot;en&quot;&gt;&lt;body&gt; &lt;a href=&quot;www.out.com&quot; target=&quot;_blank&quot;&gt;www.out.com&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;&lt;!-- www.me.com --&gt;&lt;html lang=&quot;en&quot;&gt;&lt;body&gt; &lt;script type=&quot;text/javascript&quot;&gt; if (opener) &#123; opener.window.location.href=&quot;www.danger.com&quot;; &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 然后在我们的网页点击超链接，打开外部网页（www.out.com），然后再切回来我们的网页，就会意外的发现我们的网页被篡改为其他网页（www.danger.com） 而且，打开的外部网页具有本网页的全部控制权，这意外着外部网页可以自由的获取本页面的 cookie、表单等敏感信息。 甚至，在跨域的情况下也生效， CORS 限制对此不起作用！！！ rel=”noopener noreferrer”破解也很简单，对于使用了 target=&quot;_blank&quot; 并且跳转到外部链接的超链接，加上 rel=&quot;noopener noreferrer&quot; 属性即可，此时外部链接获取到的 opener 为 null。 首先，rel=&quot;noopener&quot; 可以确保 window.opener 为 null 在 Chrome 49+ 和 Opera 36，而对于旧版本浏览器和火狐浏览器，可以加上 rel=&quot;noreferrer&quot; 更进一步禁用 HTTP 的 Referer 头，或者使用 js 打开新页面： const safeOpen = url =&gt; &#123; var otherWindow = window.open(); otherWindow.opener = null; otherWindow.location = url;&#125; 总而言之，如果使用了 target=&quot;_blank&quot; 打开外部页面，就必须加上 rel=&quot;noopener noreferrer&quot; 属性以保证安全，特别地，对于由用户输入的链接（比如论坛，讨论等）更要做好拦截处理工作。 参考 About rel=noopener","categories":[{"name":"js","slug":"js","permalink":"http://tcatche.site/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"http://tcatche.site/tags/js/"},{"name":"安全","slug":"安全","permalink":"http://tcatche.site/tags/%E5%AE%89%E5%85%A8/"}]},{"title":"React - Fragment","slug":"react-fragments","date":"2018-01-10T06:35:00.000Z","updated":"2018-08-01T10:41:24.000Z","comments":true,"path":"2018/01/react-fragments/","link":"","permalink":"http://tcatche.site/2018/01/react-fragments/","excerpt":"","text":"问题描述在 React16 以前的版本，组件渲染的返回值必须为一个子元素，而不允许是一个子元素的列表，我们经常需要为其包括一层 div 或者 span 等： // 对于：Some text.&lt;h2&gt;A heading&lt;/h2&gt;More text.&lt;h2&gt;Another heading&lt;/h2&gt;Even more text.// React 16 以前需要包裹一层额外的 divrender() &#123; return ( &lt;div&gt; Some text. &lt;h2&gt;A heading&lt;/h2&gt; More text. &lt;h2&gt;Another heading&lt;/h2&gt; Even more text. &lt;/div&gt; )&#125; 返回数组为了解决这样大部分无意义的 DOM 包装，React16.0 提供了返回数组的支持，允许我们返回一个数组： // React 16.0 以后可以返回数组render() &#123; return [ &quot;Some text.&quot;, &lt;h2 key=&quot;heading-1&quot;&gt;A heading&lt;/h2&gt;, &quot;More text.&quot;, &lt;h2 key=&quot;heading-2&quot;&gt;Another heading&lt;/h2&gt;, &quot;Even more text.&quot; ];&#125; 但是返回数组也很麻烦，比如，我们需要把文本用引号括起来、需要在每一行末尾加上逗号，而且数组元素还会报出没有 key 的错误，有需要为每一个元素指定 key 属性，这样一点也不好用，反而需要修改更多内容。 Fragment为了彻底解决这个问题，React16.2 重新引入了 React.Fragment 标签，专门用于解决这个问题： const &#123; Fragment &#125; = React;render() &#123; return ( &lt;Fragment&gt; Some text. &lt;h2&gt;A heading&lt;/h2&gt; More text. &lt;h2&gt;Another heading&lt;/h2&gt; Even more text. &lt;/Fragment&gt; );&#125; 乍一看，这个和之前使用 div 包装的方式很相似，但是 Fragment 并不会真的在外面包装一层，看下面的例子： render() &#123; return ( &lt;table&gt; &lt;tr&gt; &lt;Columns /&gt; &lt;/tr&gt; &lt;/table&gt; );&#125;// 自己包装，需要多注意应用场合，不然可能包装出来错误的结构：const Columns = () =&gt; ( &lt;div&gt; &lt;td&gt;Hello&lt;/td&gt; &lt;td&gt;World&lt;/td&gt; &lt;/div&gt;);// 结果，结构明显错误&lt;table&gt; &lt;tr&gt; &lt;div&gt; &lt;td&gt;Hello&lt;/td&gt; &lt;td&gt;World&lt;/td&gt; &lt;/div&gt; &lt;/tr&gt;&lt;/table&gt;// 使用 Fragmentreturn ( &lt;React.Fragment&gt; &lt;td&gt;Hello&lt;/td&gt; &lt;td&gt;World&lt;/td&gt; &lt;/React.Fragment&gt;);// 结果，结构正确，也没有额外的无意义的结点出现&lt;table&gt; &lt;tr&gt; &lt;td&gt;Hello&lt;/td&gt; &lt;td&gt;World&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 缩写标签 &lt;&gt;&lt;/&gt;由于这个会比较常用，又引入了简写的标签： &lt;&gt;&lt;/&gt;: return ( &lt;&gt; Some text. &lt;h2&gt;A heading&lt;/h2&gt; More text. &lt;h2&gt;Another heading&lt;/h2&gt; Even more text. &lt;/&gt;); 注意：目前版本，React.Fragment 只能接受 key 这一个属性，未来版本可能做出改进： key is the only attribute that can be passed to Fragment. In the future, we may add support for additional attributes, such as event handlers. 而简写的 &lt;&gt;&lt;/&gt; 标签并不能接收任何属性，同时可能一些工具不支持。 参考本文主要参考了 React 的官方文档： Fragments","categories":[{"name":"js","slug":"js","permalink":"http://tcatche.site/categories/js/"}],"tags":[{"name":"react","slug":"react","permalink":"http://tcatche.site/tags/react/"}]},{"title":"React - Protals","slug":"react-portals","date":"2017-12-05T08:42:00.000Z","updated":"2018-08-01T10:41:24.000Z","comments":true,"path":"2017/12/react-portals/","link":"","permalink":"http://tcatche.site/2017/12/react-portals/","excerpt":"","text":"通常情况下，我们的组件结构如下： &lt;div id=&quot;app&quot;&gt; &lt;RootComponent&gt; &lt;ParentComponent&gt; &lt;ModalComponent&gt; // modal text &lt;/ModalComponent&gt; &lt;/ParentComponent&gt; &lt;ParentSblingsComponent&gt; // come text &lt;/ParentSblingsComponent&gt; &lt;/RootComponent&gt;&lt;/div&gt; 对应的 html 结构如下： &lt;div id=&quot;appRoot&quot;&gt; &lt;div class=&quot;root&quot;&gt; &lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;modal&quot;&gt; // modal text &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;parent-sblings&quot;&gt; // modal text &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 这种情况在大多数渲染情况下并不会出现问题，但是当出现 z-index 的时候： .parent &#123; z-index: 1&#125;.parent-sblings &#123; z-index: 2&#125; 这个时候 modal 将无法出现在所有的组件上层，因为其父元素（ParentComponent）的 z-index 小于其父元素的兄弟元素（ParentSblingsComponent），这样的话就出现了问题, modal 会被 ParentSblingsComponent 的内容覆盖。 除非我们让 ModalComponent 的渲染位置脱离其文档的组件结构： &lt;div id=&quot;appRoot&quot;&gt; &lt;div class=&quot;root&quot;&gt; &lt;div class=&quot;parent&quot;&gt; &lt;!-- &lt;div class=&quot;modal&quot;&gt; // modal text &lt;/div&gt; --&gt; &lt;/div&gt; &lt;div class=&quot;parent-sblings&quot;&gt; // modal text &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;div id=&quot;modalRoot&quot;&gt; &lt;div class=&quot;modal&quot;&gt; // modal text &lt;/div&gt;&lt;/div&gt; 也就是说让 ModalComponent 的渲染位置位于文档的最后面，这样就不会出现被覆盖的问题。而 Portals 的引入，正是为了解决这样的问题： Portals 简介Portals 是 React 16 以后引入的新的功能，用于将组件渲染到父元素节点以外的 DOM 节点中，多用于各种弹出模态框、下拉列表等内容。 ReactDOM.createPortal(child, container) child：刻意渲染的 React 内容，比如 react 元素、字符串、fragment、DOM 元素等； container：渲染的目标 DOM 节点。 使用： // modal renderclass Modal extends React.Component &#123; render() &#123; return ReactDOM.createPortal( this.props.children, document.getElementById(&#x27;modalRoot&#x27;) ) &#125;&#125; Portals 事件冒泡尽管使用 Portals 渲染的元素在 DOM 中的位置脱离了 ParentComponent 元素的 DOM 树结构，但是，使用 Portals 渲染的元素仍然会触发到其组件结构层次上的事件冒泡： &lt;ParentComponent onClick=&#123;() =&gt; console.log(&#x27;click bubbled!&#x27;)&#125;&gt; &lt;ModalComponent&gt; // modal text &lt;/ModalComponent&gt;&lt;/ParentComponent&gt;// click modal// log: click bubbled! 在上面的例子，modal 能够沿着其组件层次进行事件冒泡，可以很灵活的处理事件。 来自 React 官方文档的可运行示例：Example: Portal event bubbling 兼容 React16 以下的版本在 React16 之前版本提供一个不稳定的 API： ReactDOM.unstable_renderSubtreeIntoContainer。 react-modal 组件就是使用这种方式进行兼容的: const createPortal = isReact16 ? ReactDOM.createPortal : ReactDOM.unstable_renderSubtreeIntoContainer; ReactDOM.unstable_renderSubtreeIntoContainer 这个接口可以用于代替 ReactDOM.createPortal 的功能，但是使用它以后，需要使用 ReactDOM.unmountComponentAtNode 清理副作用。 这里我们可以看一下如何使用它（代码来自 react-modal，大量删减和本节无关的内容，完整代码情请点击链接查看：react-modal/src/components/Modal.js）： class OurModal extends Component &#123; // modal 在 componentDidMount 中调用 renderPortal 执行初始化加载。 componentDidMount() &#123; if (!isReact16) &#123; this.node = document.createElement(&quot;div&quot;); &#125; this.node.className = &#x27;portalClassName&#x27;; document.body..appendChild(this.node); !isReact16 &amp;&amp; this.renderPortal(this.props); &#125; // modal 在 componentWillReceiveProps 中调用 renderPortal 执行更新渲染。 componentWillReceiveProps(newProps) &#123; !isReact16 &amp;&amp; this.renderPortal(newProps); &#125; // 组件移除需要执行的一些清理工作 componentWillUnmount() &#123; this.removePortal(); &#125; // renderPortal 就是使用 unstable_renderSubtreeIntoContainer, // 将 modal 的内容更新到指定的 DOM 树上（本例是 document.body） renderPortal(props) &#123; const portal = ReactDOM.unstable_renderSubtreeIntoContainer( this, &lt;Modal &#123;...props&#125; /&gt;, this.node ); this.portal = portal; &#125; // 使用了 unstable_renderSubtreeIntoContainer 就需要调用 unmountComponentAtNode 进行清理 // unmountComponentAtNode 函数将 React 组件从 DOM 中清理，并清除它的事件处理器 // 然后将 modal 内容从 document.body 中删除 removePortal = () =&gt; &#123; if (!this.node || !this.portal) return; !isReact16 &amp;&amp; ReactDOM.unmountComponentAtNode(this.node); document.body.removeChild(this.node); &#125;; // React16 以下 render 方法必须返回 null // React16 直接使用 createPortal render() &#123; if (!isReact16) &#123; return null; &#125; return createPortal(...); &#125;&#125; 从上面示例可以看出，使用替换 Api 的步骤较为繁琐，需要维护额外的组件的挂载，更新和清理工作，而且使用 unstable_renderSubtreeIntoContainer，发生的事件不会从 modal 的 DOM 冒泡到 Modal 组件上： &lt;ParentComponent onClick=&#123;() =&gt; console.log(&#x27;click will not bubble!&#x27;)&#125;&gt; &lt;OurModal&gt; // modal text &lt;/OurModal&gt;&lt;/ParentComponent&gt; 同时带有 unstable 前缀的接口都不稳定，不鼓励使用，如果有相关的需求，还是直接使用封装好的类库较好。 参考： Portals React 模态框秘密和“轮子”渐进设计 传送门：React Portal react-modal 源代码","categories":[{"name":"js","slug":"js","permalink":"http://tcatche.site/categories/js/"}],"tags":[{"name":"react","slug":"react","permalink":"http://tcatche.site/tags/react/"}]},{"title":"JavaScript 常用的一些事件总结","slug":"broswer_common_used_event_intro","date":"2017-09-13T06:58:00.000Z","updated":"2018-08-01T10:41:24.000Z","comments":true,"path":"2017/09/broswer_common_used_event_intro/","link":"","permalink":"http://tcatche.site/2017/09/broswer_common_used_event_intro/","excerpt":"","text":"本文主要总结了在开发中经常使用的的一些浏览器事件的使用。 系列目录本文涉及内容加多，截止现在，“拖拽事件”、“触摸事件”、“手势事件” 三节尚未完成。 鼠标事件 键盘事件 生命周期事件 触摸事件 手势事件 表单事件 错误事件 其他事件 键盘事件键盘事件最常用的是 keyup 和 keydown 两个事件，这两个事件本身很简单，不再多说，本节说一点键盘事件其他细节吧。 这两个事件常配合表单使用，比如用户输入内容后校验，虽然也可以用，但是处理起来较为麻烦，需要判断组合键，非文本输入按键比如 Shift、F1 之类的等，更合适的方法是使用表单的 input 事件，将在后面表单事件说明 组合键和鼠标事件类似，按键事件也具有这几个属性：altKey、ctrlKey/metaKey、metaKeyctrlKey、shiftKey`，具体可以参考上一节，不再详细说明。 e.code 和 e.key这两个属性表示了按键的内容，是两个比较接近的内容，但是也有一点点不同。 code 表示按的是哪个键，而 key 则表示按键的键值，这么说比较模糊，先看个例子： document.onkeydown = function (e) &#123; console.log(&#x27;The code is: &#x27;, e.code); console.log(&#x27;The key is: &#x27;, e.key); console.log(&#x27;---------&#x27;)&#125;// 按下键盘左边shiftThe code is: ShiftLeftThe key is: Shift---------// 按下键盘右边shift---------The code is: ShiftRightThe key is: Shift 由上述例子可以看出，code 是表示的具体的哪个按键被按下，所以会区分左 Shift 和右 Shift，而 key 则反映了按键代表的含义，再看另一个例子： // 按下键盘 AThe code is: KeyAThe key is: a---------// 按下键盘组合键 shift + aThe code is: ShiftLeftThe key is: Shift---------The code is: KeyAThe key is: A 忽略组合键多出来的一组按键，可以看出，此时，多了 Shift, code 值不变，是小写 a，而 key 值变成了大写的 A。 字母键的 key 值为 &quot;Key&quot; + &lt;letter&gt;，数字的 key 值为 &quot;Digit&quot; + &lt;number&gt; ，小键盘和手机按键的 key 值通常为 &quot;Numpad&quot; + &lt;number&gt;，其他控制键则为其名字，更具体查看Specs - Key Codes for Standard Keyboards，这里不在一一说明。 e.keyCode使用 keyCode 判断按键是很常用的代码，比如判断用户输入了回车键，则直接执行操作。但是须知，这个属性已经被废弃，虽然在很多浏览器还有支持，但是不建议再使用，而是使用 key 或者 code 替代： // 不建议使用 keyCodedocument.onkeydown = function (e) &#123; if (!e) e = window.event; if ((e.keyCode || e.which) == 13) &#123; alert(&quot;enter&quot;); &#125;&#125;// 建议使用 key/code 替代document.onkeydown = function (e) &#123; if (!e) e = window.event; if ((e.key) == &quot;Enter&quot;) &#123; alert(&quot;enter&quot;); &#125;&#125; 默认行为一些功能键有一些默认的行为，比如：Delete 会删除表单域的一个字符，PageDown 会向下滚动，Ctrl + S 可以打开浏览器保存网页的对话框，这些行为都是可以取消的： document.onkeydown = function (e) &#123; if (e.code === &#x27;KeyS&#x27; &amp;&amp; e.ctrlKey)&#123; e.preventDefault(); console.log(&#x27;cancel save page&#x27;); &#125; if (e.code === &#x27;PageDown&#x27;)&#123; e.preventDefault(); console.log(&#x27;cancel page down&#x27;); &#125;&#125; 比如上面例子取消了保存网页和翻页的默认操作，但是有些操作是无法取消的，比如操作系统的 Alt + F4。 页面生命周期事件和资源生命周期有关的事件主要有：load、DOMContentLoaded、 abort、beforeunload、unload： loadload：目标对象为 Window, Document 和 Element，当一个资源和其依赖的所有资源加载完成的时候，会触发 load 事件。这个资源可以是图片、CSS 文件、JS 文件、视频、document 和 window 等等。 // 页面内所有的资源加载完成后执行window.addEventListener(&quot;load&quot;, function(event) &#123; console.log(&quot;All resources finished loading!&quot;);&#125;);// 图片加载完成则执行document.getElementById(&#x27;image&#x27;).addEventListener(&quot;load&quot;, function(event) &#123; console.log(&quot;Image resource finished loading!&quot;);&#125;); DOMContentLoadedDOMContentLoaded：目标对象为 Document，当初始 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架完成加载。所以如果想要你的网页加载完成立即执行某些脚本，使用这个事件要优于 load 事件的，因为 load 事件要等待所有内容加载完成，这样无疑是很慢的。 window.onload = function () &#123; console.log(&#x27;onload 后输出&#x27;);&#125;document.addEventListener(&quot;DOMContentLoaded&quot;, function(event) &#123; console.log(&#x27;DOMContentLoaded 先输出&#x27;);&#125;);// &quot;DOMContentLoaded 先输出&quot;// &quot;onload 后输出&quot; 注意：本函数只能绑定在 Document 元素上，而 load 可以绑定到任何元素上，监听该元素的资源加载完成事件。更多关于初始化资源加载情况的监听探讨可以查看本人的另一篇文章（关于文档加载状态相关的事件探讨） abortabort：目标对象为 Window 和 Element，当资源的加载被中止时，此事件被触发。 beforeunloadbeforeunload：目标对象为 Window, 当窗口，文档及其资源即将被卸载时，beforeunload 事件触发。如果此事件的监听器处理函数为 Event 对象的 returnValue 属性赋值非空字符串，或者函数返回非空字符串，浏览器会弹出一个对话框，来询问用户是否确定要离开当前页面。否则，该事件不做响应。 window.addEventListener(&quot;beforeunload&quot;, function (e) &#123; var confirmationMessage = &quot;Are you sure to close？&quot;; (e || window.event).returnValue = confirmationMessage; //Gecko + IE return confirmationMessage; //Gecko + Webkit, Safari, Chrome etc.&#125;); 注意：在 chrome 51 后，不再支持用户自定义网页提示的消息文字，chrome 认为这个经常被用来欺骗用户（详情查看Remove custom messages in onbeforeunload dialogs）。而且 Safari 9.1+，Firefox 4+ 都不支持这个功能。 注意：在实践中调用 window.alert(), window.confirm(), window.prompt() 会被忽略，同时该对话框只能起到提示、阻止关闭作用，如果用户选择关闭，并无法在js中获得回调值，所以，如果页面有未保存动作，可以在这个时候进行一些保存动作。 unloadunload：目标对象为 Window, Document 和 Element，当DOM实现从环境中删除资源（如文档）或任何依赖资源（如图像，样式表，脚本）时，会触发此事件。 如果事件被绑定在 document 或者 window 对象上的时候，当此事件触发，此时文档会处于以下状态： 所有资源仍存在 (图片, iframe 等.) 对于终端用户所有资源均不可见 界面交互无效 (window.open, window.alert, window.confirm 等.) 错误不会停止卸载文档的过程 请注意 unload 事件也遵循文档树：父 iframe 会在子 iframe 卸载前卸载： &lt;!-- Parent.html--&gt;&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;Parent Frame&lt;/title&gt; &lt;script&gt; window.addEventListener(&#x27;beforeunload&#x27;, function(event) &#123; console.log(&#x27;I am the 1st one.&#x27;); &#125;); window.addEventListener(&#x27;unload&#x27;, function(event) &#123; console.log(&#x27;I am the 3rd one.&#x27;); &#125;); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;iframe src=&quot;child-frame.html&quot;&gt;&lt;/iframe&gt; &lt;/body&gt;&lt;/html&gt;&lt;!-- child-frame.html--&gt;&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;Child Frame&lt;/title&gt; &lt;script&gt; window.addEventListener(&#x27;beforeunload&#x27;, function(event) &#123; console.log(&#x27;I am the 2nd one.&#x27;); &#125;); window.addEventListener(&#x27;unload&#x27;, function(event) &#123; console.log(&#x27;I am the 4th and last one…&#x27;); &#125;); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt; 更具体的关于删除文档的细节查看：Unloading Documents — Prompt to unload a document 拖拽事件拖拽事件也是鼠标事件的变形，这里单独列出来解释。 // todo 触摸事件// todo 手势事件// todo 错误事件当错误发生时，触发错误事件。错误事件有两种： 当一项资源（如 &lt;img&gt; 或 &lt;script&gt; ）加载失败，加载资源的元素会触发一个 Event 接口的 error 事件，并执行该元素上的 onerror() 处理函数。这些 error 事件不会向上冒泡到 window，不过能被单一的 window.addEventListener 捕获。 当 JavaScript 运行时错误（包括语法错误）发生时，window 会触发一个 ErrorEvent 接口的 error 事件，并执行 window.onerror()。 第一种应用场合很少，这里主要介绍一下利用第二种的事件来监控和报告发生在网页的错误。 window.onerror window.onerror = function(message, source, lineNumber, columnNumber, errorObj) { … } 函数参数： message：字符串，错误信息。 source：字符串，发生错误的脚本URL lineNumber：数字， 发生错误的行号 columnNumber：数字，发生错误的列号 errorObj：对象，Error 对象 若该函数返回true，则阻止执行默认事件处理函数。 前四个参数告诉您哪个脚本，行和列出现错误，实际上，最后一个参数 Error 对象也许是最有价值的。 Error 对象和 error.stack new Error([message[, fileName[, lineNumber]]]) Error 对象的构造函数包含3个属性：message，fileName 和 lineNumber。实际上这三个属性已经包含在了 window.onerror 提供给你的参数中。 Error 对象最有价值的属性是一个非标准属性：Error.prototype.stack。此堆栈属性会告诉你发生错误时程序的每个帧的源位置。错误堆栈跟踪是调试的关键部分，尽管这个属性是非标准的，但是每个现代浏览器都提供此属性。 这是一个堆栈追踪的示例： Error: foobar at new bar (&lt;anonymous&gt;:241:11) at foo (&lt;anonymous&gt;:245:5) at callFunction (&lt;anonymous&gt;:229:33) at Object.InjectedScript._evaluateOn (&lt;anonymous&gt;:875:140) at Object.InjectedScript._evaluateAndWrap (&lt;anonymous&gt;:808:34) 使用 try…catch 的 Polyfill并不是所有浏览器都支持 errorObj 这个参数，如果为了获得 errorObj 对象，可以使用 try...catch 手动捕获。 function invoke(obj, method, args) &#123; try &#123; return obj[method].apply(this, args); &#125; catch (e) &#123; captureError(e); // report the error throw e; // re-throw the error &#125;&#125;invoke(Math, &#x27;highest&#x27;, [1, 2]); // throws error, no method Math.highest 当然，调用的每个函数都使用 invoke 手动包装无疑十分愚蠢。js 是单线程的，所以我们可以将 try...catch 代码包裹程序的入口，这样就不需要到处手动包装。 这意味着你需要包装以下函数声明： 在你的应用程序开始（例如 jquery 的 $(document).ready，document 的 DOMContentLoaded 事件） 在事件处理程序中，例如 addEventListener 或 $.fn.click 基于定时器的回调，例如 setTimeout 或 requestAnimationFrame function wrapErrors(fn) &#123; // don&#x27;t wrap function more than once if (!fn.__wrapped__) &#123; fn.__wrapped__ = function () &#123; try &#123; return fn.apply(this, arguments); &#125; catch (e) &#123; captureError(e); // report the error throw e; // re-throw the error &#125; &#125;; &#125; return fn.__wrapped__;&#125;$(wrapErrors(function () &#123; // application start doSynchronousStuff1(); // doesn&#x27;t need to be wrapped now. setTimeout(wrapErrors(function () &#123; doSynchronousStuff2(); // doesn&#x27;t need to be wrapped now. &#125;); $(&#x27;.foo&#x27;).click(wrapErrors(function () &#123; doSynchronousStuff3(); // doesn&#x27;t need to be wrapped now. &#125;);&#125;)); Script error 安全限制当加载自不同域的脚本中发生错误时，为避免信息泄露，语法错误的细节将不会报告，而代之简单的Script error.。这种情况通常发生在使用了 CDN，或者来自其他机构提供的服务。 这个问题有两种方法解决： 让非本域网络资源设置 Access-Control-Allow-Origin 标头,这将允许跨域资源共享（CORS）。 在 source 标签上使用新的 crossorigin 属性：&lt;script crossorigin=&quot;anonymous&quot; src=&quot;script.js&quot;&gt;&lt;/script&gt; crossorigin 标签有两个可能的值: anonymous：匿名，意味着无需用户凭据来访问该文件。 use-credentials：如果从引用的外部 JavaScript 文件使用了 Access-Control-Allow-Credentials 头，则使用凭据。 其他事件cut、 copy、 paste这些事件在剪切、复制、粘贴的时候触发，可以被取消。 比如下面这个例子，我们想要用户认真填写自己的Id，禁止用户粘贴： &lt;input type=&quot;text&quot; id=&quot;id&quot; /&gt;&lt;script&gt;document.getElementById(&#x27;id&#x27;).onpaste = function(e) &#123; e.preventDefault(); // 删除剪切板中的内容 deleteCurrentDocumentSelection(); alert(&quot;Not allow to copy and paste&quot;);&#125;&lt;/script&gt; 还有一个常见的例子是当用户复制的时候追加额外的文本，比如追加文章的版权说明： document.addEventListener(&#x27;copy&#x27;, function(e) &#123; // 禁止默认行为 e.preventDefault(); // 获取用户选中的内容，此时不包含标签。 const selectedText = window.getSelection().toString(); const apptendText = &#x27;\\n\\n 著作权归作者所有，未经允许，禁止转载&#x27; // 注意，此处第一个参数是 &quot;text/plain&quot; event.clipboardData.setData(&quot;text/plain&quot;, selectedText + apptendText); // 删除剪切板中的内容 deleteCurrentDocumentSelection();&#125;); 此时选中，复制任何文本，都会在后面追加著作权的信息。 这里的方案仅仅修改文本，如果想要将标签也复制进去比较麻烦： // 选中选择的文本所在的 htmlfunction getSelected() &#123; const selectionRange = window.getSelection().getRangeAt(0); const selectionContents = selectionRange.cloneContents(); const fragmentContainer = document.createElement(&#x27;div&#x27;); const fragmentContainer.appendChild(selectionContents); return fragmentContainer;&#125;document.addEventListener(&#x27;copy&#x27;, function(e) &#123; // 禁止默认行为 e.preventDefault(); // 获取用户选中的内容，此时不包含标签。 const selectedContainer = getSelectedHtml(); const appendHtml = &#x27;&lt;br/&gt;&lt;br/&gt; 著作权归作者所有，未经允许，禁止转载&#x27;; selectedContainer.append(appendHtml); // 注意，此处第一个参数是 &quot;text/html&quot; event.clipboardData.setData(&quot;text/html&quot;, selectedContainer.innerHtml); // 删除剪切板中的内容 deleteCurrentDocumentSelection();&#125;); 剪切板是系统级别的，浏览器可能会出于安全的策略限制了对系统剪切板的访问权限。 剪切板事件并不常用，本文只做了简单的介绍，想要了解更多细节，查看 resize 和 scroll这两个事件很简单，分别是监听文档视图尺寸和页面滚动的事件，本身没有什么要说的，这里主要说的是这两个事件的触发频率比较高，建议使用 requestAnimationFrame，setTimeout 或customEvent 来调节事件的触发频率： 使用 requestAnimationFrame 和 customEvent 优化高频率触发的事件： var throttle = function(type, name, obj) &#123; obj = obj || window; var running = false; var func = function() &#123; if (running) &#123; return; &#125; running = true; requestAnimationFrame(function() &#123; obj.dispatchEvent(new CustomEvent(name)); running = false; &#125;); &#125;; obj.addEventListener(type, func);&#125;;/* init - you can init any event */throttle(&quot;resize&quot;, &quot;optimizedResize&quot;);/* init - you can init any event */throttle(&quot;scroll&quot;, &quot;optimizedScroll&quot;);// handle eventwindow.addEventListener(&quot;optimizedResize&quot;, function() &#123; // resize to do sth;&#125;);// handle eventwindow.addEventListener(&quot;optimizedScroll&quot;, function() &#123; // scroll to do sth;&#125;); 参考 Events: change, input, cut, copy, paste Clipboard API Capture and report JavaScript errors with window.onerror 如何捕获和分析 JavaScript Error Get the raw HTML of selected content using javascript","categories":[{"name":"js","slug":"js","permalink":"http://tcatche.site/categories/js/"}],"tags":[{"name":"dom","slug":"dom","permalink":"http://tcatche.site/tags/dom/"},{"name":"bom","slug":"bom","permalink":"http://tcatche.site/tags/bom/"},{"name":"event","slug":"event","permalink":"http://tcatche.site/tags/event/"},{"name":"listener","slug":"listener","permalink":"http://tcatche.site/tags/listener/"},{"name":"mouse","slug":"mouse","permalink":"http://tcatche.site/tags/mouse/"},{"name":"drag","slug":"drag","permalink":"http://tcatche.site/tags/drag/"},{"name":"touch","slug":"touch","permalink":"http://tcatche.site/tags/touch/"},{"name":"click","slug":"click","permalink":"http://tcatche.site/tags/click/"},{"name":"keyboard","slug":"keyboard","permalink":"http://tcatche.site/tags/keyboard/"}]},{"title":"JavaScript 事件研究","slug":"broswer_events_intro","date":"2017-09-12T03:21:00.000Z","updated":"2021-08-09T02:08:49.261Z","comments":true,"path":"2017/09/broswer_events_intro/","link":"","permalink":"http://tcatche.site/2017/09/broswer_events_intro/","excerpt":"","text":"浏览器中的事件主要有两个来源： 一些是用户生成的（例如鼠标或键盘事件），而其他由API生成(例如指示动画已经完成运行的事件，视频已被暂停等等)。 目录本文主要综合介绍一下浏览器的事件，首先来看事件的监听 事件监听注册与移除注册事件监听有两种方式：注册 on-event 处理器和使用 addEventListener() 事件监听器： 注册 on-event处理器可以将事件监听函数直接写在 HTML 元素属性内： &lt;button id=&quot;btn&quot; onclick=&quot;alert(&#x27;Hello world!&#x27;)&quot;&gt;click&lt;/button&gt; 这种方法将 HTML 和 JS 糅合在一起，不利于维护和开发，尽量避免如此使用。 也可以直接为DOM属性设置指定事件的处理函数： var btn = document.getElementById(&#x27;btn&#x27;);btn.onclick = function() &#123; alert(&#x27;click button&#x27;);&#125;; 为DOM 属性设置的事件处理器会覆盖绑定在HTML元素属性内的事件处理器，但是使用 getAttribute() 获取到的值仍旧为原始值： &lt;button id=&quot;btn&quot; onclick=&quot;console.log(&#x27;click btn handler1.&#x27;)&quot;&gt;click&lt;/button&gt;&lt;script&gt;window.onload = function () &#123; var div = document.getElementById(&quot;btn&quot;); console.log(&quot;Attribute reflected as a property: &quot;, div.onclick.toString()); // function onclick(event) &#123; console.log(&#x27;click btn handler1.&#x27;) &#125; div.onclick = function() &#123; console.log(&#x27;click btn handler2.&#x27;) &#125;; console.log(&quot;Changed property to: &quot;, div.onclick.toString()); // function () &#123; console.log(&#x27;click btn handler2.&#x27;) &#125; console.log(&quot;Attribute value is unchanged: &quot;, div.getAttribute(&quot;onclick&quot;)); // console.log(&#x27;click btn handler1.&#x27;) // click btn. // &#x27;click btn handler2.&#x27;&#125;&lt;/script&gt; 注意 事件处理器的返回值决定了事件默认行为是否被取消，如果返回值为 false，则会取消事件的某些默认行为，相当于调用了 event.preventDefault()，更多细节查看 The event handler processing algorithm。 on-event 处理器只能为每个元素设置一个处理函数，但是可以设置一个执行函数，在函数内绑定多个事件处理器： var eventProxy = function(ele) &#123; var _fns = &#123;&#125;; var _ele = ele; var _trigger = function(type) &#123; _fns[type].forEach(fn =&gt; fn(ele)); &#125; var _addEvent = function(type, fn) &#123; if (!_fns[type]) &#123; _fns[type] = [fn]; _ele[type] = _trigger(type); &#125; else &#123; _fns[type].push(fn); &#125; &#125; var _removeEvent = function(type, fn) &#123; if (!_fns[type]) &#123; return; &#125; else &#123; var fns = []; _fns[type].forEach(function(item) &#123; if (item !== fn) &#123; fns.push(item); &#125; &#125;); _fns[type] = fns; &#125; &#125; return &#123; addEvent: _addEvent, removeEvent: _removeEvent, trigger: _trigger &#125;&#125; 如上，这是一个非常简陋的多事件管理器，当然这个还存在很多问题，比如没有检查参数，没有检查重复，添加删除过程中没有考虑队列是否正在使用等等问题。当然对于多个事件监听，还是推荐以下的标准事件监听函数： 事件监听函数（推荐使用）addEventListener() 方法将指定的监听器注册到 EventTarget 上，当该对象触发指定的事件时，指定的回调函数就会被执行。 事件目标可以是一个文档上的元素 Document 本身，或者任何其他支持事件的对象 (比如 XMLHttpRequest)。 target.addEventListener(type, listener[, options]);target.addEventListener(type, listener[, useCapture]); type 表示事件类型；listener 表示事件监听函数；第三个参数为 boolean 时候，表示该参数是在捕获阶段监听（true）还是在冒泡阶段监听（false），如果为对象，则对象可以有三个选项：capture配置触发是在捕获还是冒泡阶段，once 指定监听器是否只执行一次，passive 指定是否忽略事件监听器中调用的 preventDefault 函数。 // html&lt;button id=&quot;btn&quot;&gt;click&lt;/button&gt;//jsvar btn = document.getElementById(&#x27;btn&#x27;);btn.addEventListener(&#x27;click&#x27;, function() &#123; alert(&#x27;click button&#x27;);&#125;, false); 注意，listener 中的 this 指向的是元素自身，也与传递给它的 event 对象的 currentTarget 属性值一致。如果依赖了某些上下文，可以使用 bind 函数解决： var doSomething = function(element) &#123; this.name = &#x27;Something Name&#x27;; this.onclick = function(event) &#123; console.log(this.name); // undefined, as |this| is the element &#125;; element.addEventListener(&#x27;click&#x27;, this.onclick, false); // undefined element.addEventListener(&#x27;click&#x27;, this.onclick.bind(this), false); // Something Name&#125;var s = new doSomething(document.body); 在 IE 9 之前，不支持该方法，必须使用 attachEvent，如果需要兼容 IE，可以这样写： const addEvent = ((root) =&gt; &#123; if (root.attachEvent) &#123; return (ele, type, fn) =&gt; ele.attachEvent(&#x27;on&#x27; + type, fn); &#125; else if (root.addEventListener) &#123; return (ele, type, fn, capture = false) =&gt; ele.addEventListener(type, fn, capture); &#125;&#125;)(window); 同一个 EventTarget 注册了多个相同的 listener，那么重复的实例会被抛弃，所以不必担心 listener 被调用两次。因此要注意尽量避免使用匿名函数，一方面匿名函数无法取消，而另一方面，传递同样内容的匿名函数不会被抛弃，会被重复执行： var fun1 = () =&gt; console.log(&#x27;bind func1&#x27;);btn.addEventListener(&#x27;click&#x27;, fun1);btn.addEventListener(&#x27;click&#x27;, fun1);// click 重复绑定函数被抛除// bind func1btn.removeEventListener(&#x27;click&#x27;, fun1);btn.addEventListener(&#x27;click&#x27;, () =&gt; console.log(&#x27;bind func2&#x27;));btn.addEventListener(&#x27;click&#x27;, () =&gt; console.log(&#x27;bind func2&#x27;));// click 匿名函数内容一致也无法被抛除// bind func2// bind func2 注意 IE8 不具有任何替代 useCapture 的方法，如果有依赖这个捕获阶段的函数，请慎重考虑。 事件监听移除对应于以上两种事件监听注册方式，有两种不同的移除方式： // on-event 注册方式的移除btn.onclick = null;// addEventListener 注册方式的移除const removeEvent = ((root) =&gt; &#123; if (root.detachEvent) &#123; return (ele, type, fn) =&gt; ele.detachEvent(&#x27;on&#x27; + type, fn); &#125; else if (root.removeEventListener) &#123; return (ele, type, fn, capture = false) =&gt; ele.removeEventListener(type, fn, capture); &#125;&#125;)(window); 事件触发过程上几节定义了事件的注册，本节详细看一下事件的发生过程。 事件捕获和冒泡事件触发的过程可以分为3个阶段：事件捕获阶段、目标阶段、事件冒泡阶段，这三个阶段的过程图所示： 事件对象逐个完成这些阶段。如果浏览器不支持该阶段，或者事件对象的传播已被停止，则将跳过该阶段。例如，如果将事件对象的 bubbles 属性设置为 false，则将跳过冒泡阶段，如果在调度之前调用了 stopPropagation()，则将跳过所有阶段。 事件捕获阶段：事件对象从 window 对象开始，向下经过 document、body 等元素最终传播到事件目标的父级，这个阶段被称为捕获阶段。 目标阶段：事件对象到达事件目标对象（即，event.target），该阶段称为目标阶段。如果事件类型表示事件不冒泡，则事件对象将在此阶段完成后停止，不进入事件冒泡阶段。 事件冒泡阶段：事件对象以事件捕获阶段相反的顺序从事件目标的父级传播到目标的祖先，到 window 对象结束，该阶段称为冒泡阶段。 我们来看个例子： &lt;div id=&quot;outer&quot;&gt; &lt;div&gt;click outer.&lt;/div&gt; &lt;div id=&quot;inner&quot;&gt;click inner.&lt;/div&gt;&lt;/div&gt; window.onload = function() &#123; var outer = document.getElementById(&#x27;outer&#x27;); var inner = document.getElementById(&#x27;inner&#x27;); outer.addEventListener(&#x27;click&#x27;, function() &#123; console.log(&#x27;outer capture phase&#x27;); &#125;, true); outer.addEventListener(&#x27;click&#x27;, function() &#123; console.log(&#x27;outer bubble phase&#x27;); &#125;, false); inner.addEventListener(&#x27;click&#x27;, function() &#123; console.log(&#x27;inner capture phase&#x27;); &#125;, true); inner.addEventListener(&#x27;click&#x27;, function() &#123; console.log(&#x27;inner bubble phase&#x27;); &#125;, false);&#125; 点击后，打印的结果为： // click outer&quot;outer capture phase&quot;&quot;outer bubble phase&quot;// click inner&quot;outer capture phase&quot;&quot;inner capture phase&quot;&quot;inner bubble phase&quot;&quot;outer bubble phase&quot; 注册事件监听器的执行顺序之前提到 addEventListener 函数的第三个参数就是指定事件在哪个阶段处理，设置为 true 则在事件捕获阶段处理，设置为 false 则在事件冒泡阶段处理，实际上并不准确，我们看如下的例子： a.我们去掉 outer 的事件，修改 inner 事件的注册顺序： window.onload = function() &#123; var outer = document.getElementById(&#x27;outer&#x27;); var inner = document.getElementById(&#x27;inner&#x27;); inner.addEventListener(&#x27;click&#x27;, function() &#123; console.log(&#x27;inner bubble phase&#x27;); &#125;, false); inner.addEventListener(&#x27;click&#x27;, function() &#123; console.log(&#x27;inner capture phase&#x27;); &#125;, true);&#125; 然后点击 inner 发现，先执行冒泡，后捕获，似乎和注册的顺序有关： // click inner&quot;inner bubble phase&quot;&quot;inner capture phase&quot; b.这一次，我们去掉 inner 的事件，为 outer 绑定事件： window.onload = function() &#123; var outer = document.getElementById(&#x27;outer&#x27;); var inner = document.getElementById(&#x27;inner&#x27;); outer.addEventListener(&#x27;click&#x27;, function() &#123; console.log(&#x27;outer bubble phase&#x27;); &#125;, false); outer.addEventListener(&#x27;click&#x27;, function() &#123; console.log(&#x27;outer capture phase&#x27;); &#125;, true);&#125; 此时点击 inner 发现，和事件绑定顺序无关，总是先执行捕获，后执行冒泡： // click inner/inner&quot;outer capture phase&quot;&quot;outer bubble phase&quot; c.在 b 的基础上，为 outer 设置 padding，然后点击 outer，避免点击其子元素，会发现，此时又是和事件注册顺序有关，先执行冒泡，后捕获： &quot;outer bubble phase&quot;&quot;outer capture phase&quot; 事件监听器的执行顺序是这样的： 事件发生后，首先进入捕获阶段。 在捕获阶段经过的每一个元素（这些元素均为事件目标元素的祖先元素），查看是否有定义在该阶段的事件监听器和该元素上的事件监听器，如果有则按照定义顺序逐个执行，最终进入目标阶段。 进入目标阶段，按照事件监听器定义顺序，逐个执行定义在事件目标元素上的事件监听器，此时，不考虑听器在注册时 capture 参数值是 true 还是 false，完成后进入下一步。 如果允许冒泡在开始冒泡，并在冒泡阶段，逐个检查并运行绑定在当前元素上的冒泡阶段执行的事件监听器。 总结：如果事件点击目标（event.target）和事件的绑定目标一致（event.currentTarget) 一致，则多个事件监听器按照监听器的绑定顺序执行。否则，事件按照先执行捕获事件，后执行冒泡顺序的事件执行。 更详细的事件触发过程可以参考 DOM 的规范定义：This specification standardizes the DOM#2.8. Dispatching events In the browsers that support the W3C DOM, a traditional event registration element1.onclick = doSomething2; is seen as a registration in the bubbling phase. 注意，在支持捕获和冒泡双阶段的浏览器中，使用 on-event 的传统方式注册的事件，可以认为是发生在冒泡阶段的。 顺便说个小插曲，这两个阶段是当年 netscape 和 微软的战争遗留，当时，netscape 主张捕获方式，微软主张冒泡方式。后来 w3c 采用折中的方式，制定了统一的标准：先捕获再冒泡。 阻止事件继续执行在有些场合下，我们已经捕获到了想要处理的事件，不想让事件继续向下执行，这个时候就要阻止事件的冒泡： event.stopPropagationstopPropagation 方法可以停止事件继续传播： window.onload = function() &#123; var outer = document.getElementById(&#x27;outer&#x27;); var inner = document.getElementById(&#x27;inner&#x27;); outer.addEventListener(&#x27;click&#x27;, function() &#123; console.log(&#x27;outer run&#x27;); event.stopPropagation(); &#125;, true); inner.addEventListener(&#x27;click&#x27;, function() &#123; console.log(&#x27;inner stoped&#x27;); &#125;, true);&#125;// &quot;outer run&quot; 也可以使用 e.cancelBubble = true 来替代 e.stopPropagation()，但是 cancelBubble 支持程度可能受限，为了保险，可以同时设置： const cancelBubble = e =&gt; &#123; if (!e) e = window.event;2e.cancelBubble = true;2if (e.stopPropagation) e.stopPropagation();&#125; event.stopImmediatePropagationstopPropagation 方法，可以阻止事件传播，但是不能阻止当前事件绑定的其他的事件监听器，而本函数可以阻止事件传播，同时阻止当前事件注册的其他事件监听器： window.onload = function() &#123; var outer = document.getElementById(&#x27;outer&#x27;); var inner = document.getElementById(&#x27;inner&#x27;); outer.addEventListener(&#x27;click&#x27;, function() &#123; console.log(&#x27;outer run1&#x27;); event.stopPropagation(); &#125;, true); outer.addEventListener(&#x27;click&#x27;, function() &#123; console.log(&#x27;outer run2&#x27;); &#125;, true); inner.addEventListener(&#x27;click&#x27;, function() &#123; console.log(&#x27;inner stoped&#x27;); &#125;, true);&#125;// stopPropagation 无法阻止当前事件绑定的其他的事件监听器//&quot;outer run1&quot;//&quot;outer run2&quot;window.onload = function() &#123; var outer = document.getElementById(&#x27;outer&#x27;); var inner = document.getElementById(&#x27;inner&#x27;); outer.addEventListener(&#x27;click&#x27;, function() &#123; console.log(&#x27;outer run1&#x27;); event.stopImmediatePropagation(); &#125;, true); outer.addEventListener(&#x27;click&#x27;, function() &#123; console.log(&#x27;outer run2&#x27;); &#125;, true); inner.addEventListener(&#x27;click&#x27;, function() &#123; console.log(&#x27;inner stoped&#x27;); &#125;, true);&#125;// stopImmediatePropagation 可以阻止// &quot;outer run1&quot; 事件委托由于事件的冒泡机制，所有的子元素节点发生的事件都会经过父元素，并返回父元素，这样，可以将事件的处理交给父元素，这就是事件委托。 看这个例子： // html&lt;ul id=&quot;list&quot;&gt; &lt;li&gt;Item 1&lt;/li&gt; &lt;li&gt;Item 2&lt;/li&gt; &lt;li&gt;Item 3&lt;/li&gt; &lt;li&gt;Item 4&lt;/li&gt; &lt;li&gt;Item 5&lt;/li&gt;&lt;/ul&gt;//jsdocument.getElementById(&quot;list&quot;).addEventListener(&quot;click&quot;, function(e) &#123; if ( event.target.tagName == &#x27;LI&#x27; ) &#123; // do sth. &#125;&#125;); 使用事件委托有两个优点： 可以减少事件的绑定，不用给每一个元素都绑定事件； 对于使用脚本动态添加的元素，仍然可以监听之前绑定的事件，不需要重新绑定。 事件对象 Event上面简单介绍了如何为元素注册和移除事件，本节看一下传递给事件监听器的事件对象。 Event接口用于向事件处理程序提供关于事件的上下文信息。实现 Event 接口的对象通常作为第一个参数传递给事件监听器。 Web浏览器定义了不同种类的许多事件，每个不同的事件的定义都是继承自 Event Prototype 对象的对象。事件的继承层次如下： Event 对象通用的属性和方法 通用属性： bubbles： ([boolean, readonly]）指示事件是否可以冒泡。如果可以冒泡，则值为 true，否则该值为 false。 cancelable： ([boolean, readonly]）指示事件是否可以取消其默认动作。如果可以取消该值为 true，否则为 false。 cancelBubble： ([boolean]）在事件处理器中将其值设置为 true 可防止事件传播。 currentTarget： ([EventTarget, readonly]）指示正​​在处理其 EventListener 的 EventTarget。这在捕获和冒泡时特别有用。 defaultPrevented： ([boolean, readonly]）指示事件是否调用了 event.preventDefault()。 eventPhase： ([unsigned short, readonly]）指示当前事件正处于的哪个阶段。 srcElement ：([EventTarget, readonly]） target 的别名。 target： ([EventTarget, readonly]）指示事件最初发送到的 EventTarget。 timeStamp： ([DOMTimeStamp, readonly]）创建事件的时间（以秒为单位） type： ([DOMString, readonly]）事件的名称（不区分大小写） 通用方法： preventDefault： 取消事件对应的默认行为，比如点击超链接跳转新页面，如果 cancelable 属性值为 false 则不可取消，此时调用该方法无效。 stopPropagation 阻止当前事件在捕获和冒泡阶段的进一步传播。 stopImmediatePropagation 阻止事件冒泡，如果几个监听器被绑定到同一个元素的相同事件上，则按照它们被添加的顺序调用它们，如果有一个调用期间调用了event.stopImmediatePropagation()，则不会调用剩余的监听器。 自定义事件在有些场合下，我们会想要自定义事件，这在我们自己的类库、组件的开发场合下很有用，本节介绍如何自定义事件，触发事件： 使用 Event、CustomEvent 创建自定义事件简单创建自定义事件，可以使用 Event 构造函数： var event = new Event(typeArg, [eventInit]); typeArg：是 DOMString 类型，表示所创建事件的名称。 eventInit：可选，接受以下字段: bubbles：可选，Boolean 类型，默认值为 false，表示该事件是否冒泡。 cancelable：可选，Boolean 类型，默认值为 false， 表示该事件能否被取消。 如果需要更高级的附带自定义数据的事件，可以使用 CustomEvent： var myEvent = new CustomEvent(eventName, [options]); eventName：是 String 类型，表示所创建自定义事件的名称。 options：可选，接受以下字段: detail：可选，默认值为 null，表示该事件任意的自定义数据。 bubbles：可选，Boolean 类型，默认值为 false，表示该事件是否冒泡。 cancelable：可选，Boolean 类型，默认值为 false， 表示该事件能否被取消。 如下示例： // add an appropriate event listenerobj.addEventListener(&quot;cat&quot;, function(e) &#123; process(e.detail) &#125;);// create and dispatch the eventvar event = new CustomEvent(&quot;cat&quot;, &#123; detail: &#123; hazcheeseburger: true &#125;&#125;);obj.dispatchEvent(event); 触发事件除了自定义的事件外，浏览器内置的一些事件（比如，click 事件）也可以被模拟触发，比如下面这个模拟触发 click 事件的例子： function simulateClick() &#123; var event = new MouseEvent(&#x27;click&#x27;, &#123; &#x27;view&#x27;: window, &#x27;bubbles&#x27;: true, &#x27;cancelable&#x27;: true &#125;); var cb = document.getElementById(&#x27;checkbox&#x27;); var cancelled = !cb.dispatchEvent(event); if (cancelled) &#123; // A handler called preventDefault. alert(&quot;cancelled&quot;); &#125; else &#123; // None of the handlers called preventDefault. alert(&quot;not cancelled&quot;); &#125;&#125; 在自定义触发事件的时候，常用到的两个方法是：Event Constructor（例如 Event()、MouseEvent()）、element.dispatchEvent(event)。 有的地方可能会用如下的方法，但是注意，这种方法已经过时： function simulateClick() &#123; // 这种方法已经过时，不推荐使用 var evt = document.createEvent(&quot;MouseEvents&quot;); evt.initMouseEvent(&quot;click&quot;, true, true, window, 0, 0, 0, 0, 0, false, false, false, false, 0, null);&#125; 使用自定义事件实现发布订阅者模式class EventEmitter &#123; listen: window.addEventListener, unlisten: window.removeEventListener, trigger(type, data) &#123; window.dispatchEvent(new CustomEvent(type, &#123; detail: data &#125;)) &#125;&#125; 参考本文涉及内容较多，也不可能面面具到，本文主要参考以下内容，更多资料还请阅读下文： The event handler processing algorithm UI Events, W3C Working Draft #3.1. Event dispatch and DOM event flow This specification standardizes the DOM#2.8. Dispatching events W3c-Document Object Model Events#1.4. Event interface Event developer guide MDN：Web APIs-Event Event order JavaScript 浏览器事件解读","categories":[{"name":"js","slug":"js","permalink":"http://tcatche.site/categories/js/"}],"tags":[{"name":"dom","slug":"dom","permalink":"http://tcatche.site/tags/dom/"},{"name":"bom","slug":"bom","permalink":"http://tcatche.site/tags/bom/"},{"name":"event","slug":"event","permalink":"http://tcatche.site/tags/event/"},{"name":"listener","slug":"listener","permalink":"http://tcatche.site/tags/listener/"}]},{"title":"CSS 选择器优先级","slug":"css-selector-cascade-order","date":"2017-08-30T03:50:00.000Z","updated":"2018-08-01T10:41:24.000Z","comments":true,"path":"2017/08/css-selector-cascade-order/","link":"","permalink":"http://tcatche.site/2017/08/css-selector-cascade-order/","excerpt":"","text":"在我们学习 css 的时候就了解样式优先级的排序是：!important &gt; 行内样式 &gt; ID选择器 &gt; 类选择器 &gt; 标签 &gt; 通配符 &gt; 继承 &gt; 浏览器默认属性，我们看一下它们到底具体是如何定义的。 css 的样式有三种来源，页面开发者，用户（使用浏览器的人设置的样式），和用户代理（浏览器），这些样式表会在一定的范围内重叠，互相影响页面的最终样式。 当然， css 的层叠规则也指定了不同样式的权重，当这几种规则同时存在的时候，优先级高的规则生效。 样式表层叠顺序 在应用样式之前，会根据媒体查询（@media 规则）过滤掉一部分样式。 需要说明的是，样式的声明包含普通声明和重要声明（就是样式末尾有 !important）。然后样式的优先级升序排序如下： 用户代理声明（浏览器默认，比如按钮的默认样式） 用户常规声明 开发者常规声明 开发者重要声明（!important） 用户重要声明（!important） 相同的优先级的样式规则按照选择器的特殊性排序，选择器权重高的将覆盖权重一般的，其中伪元素和伪类被分别算作常规元素和类，具体如何计算在下一节详细说明。 如果选择器的权重一致，则按照声明的顺序排序，后声明的样式覆盖先声明的样式。引入的样式表中的声明被认为在样式表本身的所有声明之前。 这种层叠顺序可以保证了浏览器赋予页面元素默认的初始属性（用户代理声明，优先级最低），同给予了开发者编写比用户和用户代理更高权重样式的能力（开发者声明，优先级高于用户代理和用户常规声明，去掉非用户重要声明的样式），之后又提供了用户强制去除开发者样式的能力（用户重要声明，表达用户强制修改的意愿）。 计算选择器的特殊性选择器有多个类比，比如标签选择器、类选择器、ID选择器等，不同的选择器有不同的优先级，最终根据优先级计算出样式规则的权重，权重高的覆盖权重低的规则，权重计算如下： 如果声明来自内联规则（写在 html 标签的 style 属性内），则计 a=1，否则为 a=0 计算选择器中 ID 选择器的数量，赋值给 b 计算选择器中类选择器、属性选择器和伪类（如 :lang、:active）的数量，赋值给 c 计算选择器中元素名（如 div、p）和伪元素（如 :before、:after）的数量，赋值给 d 最后，选择器的权重由 a-b-c-d 决定，a 的优先级最高，a 值相同则比较 b值，以此类推，类似于软件的版本号规则。 看几个示例，优先级从上往下增加： * &#123;&#125; /* a=0 b=0 c=0 d=0 -&gt; specificity = 0,0,0,0 */li &#123;&#125; /* a=0 b=0 c=0 d=1 -&gt; specificity = 0,0,0,1 */li:first-line &#123;&#125; /* a=0 b=0 c=0 d=2 -&gt; specificity = 0,0,0,2 */ul li &#123;&#125; /* a=0 b=0 c=0 d=2 -&gt; specificity = 0,0,0,2 */ul ol+li &#123;&#125; /* a=0 b=0 c=0 d=3 -&gt; specificity = 0,0,0,3 */h1 + *[rel=up]&#123;&#125; /* a=0 b=0 c=1 d=1 -&gt; specificity = 0,0,1,1 */ul ol li.red &#123;&#125; /* a=0 b=0 c=1 d=3 -&gt; specificity = 0,0,1,3 */li.red.level &#123;&#125; /* a=0 b=0 c=2 d=1 -&gt; specificity = 0,0,2,1 */#x34y &#123;&#125; /* a=0 b=1 c=0 d=0 -&gt; specificity = 0,1,0,0 */style=&quot;&quot; /* a=1 b=0 c=0 d=0 -&gt; specificity = 1,0,0,0 */ 注意，本节的优先级计算仅在第一节中的声明顺序一致的情况下才有意义，这也是为什么 !important 的优先级最高。 参考 Cascading Style Sheets Level 2 Revision 2 (CSS 2.2) Specification#6.4 The cascade","categories":[{"name":"css","slug":"css","permalink":"http://tcatche.site/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"http://tcatche.site/tags/css/"},{"name":"cascade","slug":"cascade","permalink":"http://tcatche.site/tags/cascade/"},{"name":"style","slug":"style","permalink":"http://tcatche.site/tags/style/"}]},{"title":"JavaScript 是如何工作的：V8 引擎内部机制及5个诀窍编写优化代码的技巧","slug":"how-javascript-work-part-2-v8-engine-and-5-tips-optimized","date":"2017-08-29T09:18:00.000Z","updated":"2018-08-01T10:41:24.000Z","comments":true,"path":"2017/08/how-javascript-work-part-2-v8-engine-and-5-tips-optimized/","link":"","permalink":"http://tcatche.site/2017/08/how-javascript-work-part-2-v8-engine-and-5-tips-optimized/","excerpt":"","text":"原文：How JavaScript works: inside the V8 engine + 5 tips on how to write optimized code Couple of weeks ago we started a series aimed at digging deeper into JavaScript and how it actually works: we thought that by knowing the building blocks of JavaScript and how they come to play together you’ll be able to write better code and apps. 几周前，我们开始了一系列旨在深入挖掘 JavaScript 及其实际上如何工作的系列文章：我们认为，通过了解 JavaScript 的构建单元以及它们如何一起工作，你将能够编写更好的代码和应用程​​序。 The first post of the series focused on providing an overview of the engine, the runtime and the call stack. This second post will be diving into the internal parts of Google’s V8 JavaScript engine. We’ll also provide a few quick tips on how to write better JavaScript code — best practices our development team at SessionStack follows when building the product. 该系列的第一篇文章集中在介绍引擎，运行时和调用堆栈的概念。这第二篇文章将会深入 Google V8 JavaScript 引擎的内部。我们还将提供一些关于如何编写更好的 JavaScript 代码的小技巧 - 这是我们的开发团队在 SessionStack 最佳原则。 概述（Overview）A JavaScript engine is a program or an interpreter which executes JavaScript code. A JavaScript engine can be implemented as a standard interpreter, or just-in-time compiler that compiles JavaScript to bytecode in some form. JavaScript 引擎是一个执行 JavaScript 代码的程序或解释器。 一个 JavaScript 引擎可以实现为标准解释器，也可以是以某种形式将 JavaScript 编译为字节码的即时编译器。 This is a list of popular projects that are implementing a JavaScript engine: V8 — open source, developed by Google, written in C++ Rhino — managed by the Mozilla Foundation, open source, developed entirely in Java SpiderMonkey — the first JavaScript engine, which back in the days powered Netscape Navigator, and today powers Firefox JavaScriptCore — open source, marketed as Nitro and developed by Apple for Safari KJS — KDE’s engine originally developed by Harri Porten for the KDE project’s Konqueror web browser Chakra (JScript9) — Internet Explorer Chakra (JavaScript) — Microsoft Edge Nashorn, open source as part of OpenJDK, written by Oracle Java Languages and Tool Group JerryScript — is a lightweight engine for the Internet of Things. 这是一个正在实现的 JavaScript引擎的热门项目列表： V8 ：开源的，由 Google 开发的，用 C++ 编写 Rhin：由 Mozilla 基金会管理，开放源代码，完全用 Java 开发 SpiderMonkey ： 第一个 JavaScript 引擎，过去使用在 Netscape Navigator 中，现在工作在 Firefox JavaScriptCore ： 开源，由Nitro推出，由苹果公司开发，用在 Safari 中 KJS ：最初由 Harri Porten 开发，用于 KDE项目的 Konqueror 网络浏览器 Chakra (JScript9) ： Internet Explorer Chakra (JavaScript) ： Microsoft Edge Nashorn：开源，作为 OpenJDK 的一部分，由 Oracle Java 语言和工具组编写 JerryScript ： 是物联网的轻量级引擎 为什么创建 V8 引擎？（Why was the V8 Engine created?）The V8 Engine which is built by Google is open source and written in C++. This engine is used inside Google Chrome. Unlike the rest of the engines, however, V8 is also used for the popular Node.js runtime. 由 Google 构建的 V8 引擎是开源的，用 C++ 编写。该引擎在 Google Chrome 内使用。然而，与其他引擎不同的是 V8 也被用于流行的 Node.js 运行时。 V8 was first designed to increase the performance of JavaScript execution inside web browsers. In order to obtain speed, V8 translates JavaScript code into more efficient machine code instead of using an interpreter. It compiles JavaScript code into machine code at execution by implementing a JIT (Just-In-Time) compiler like a lot of modern JavaScript engines do such as SpiderMonkey or Rhino (Mozilla). The main difference here is that V8 doesn’t produce bytecode or any intermediate code. V8 最初被设计用于提高 Web 浏览器中 JavaScript 执行的性能。为了获得更快的运行速度，V8 将 JavaScript 代码转换为更有效的机器代码，而不是使用解释器。它通过实现JIT（即时）编译器，就像许多现代 JavaScript 引擎（如SpiderMonkey或Rhino（Mozilla））做的的，将JavaScript代码编译成机器代码。与他们相比，最主要的区别在于 V8 不会产生字节码或任何中间代码。 过去 V8 有2个编译器（V8 used to have two compilers）Before version 5.9 of V8 came out (released earlier this year), the engine used two compilers: full-codegen — a simple and very fast compiler that produced simple and relatively slow machine code. Crankshaft — a more complex (Just-In-Time) optimizing compiler that produced highly-optimized code. 在 V8 5.9 版本发布之前（今年早些时候发布），引擎使用两个编译器： full-codegen - 一个简单而非常快速的编译器，可以生成简单而且相对较慢的机器代码。 Crankshaft - 更复杂（即时）优化编译器，可以生成高度优化的代码。 The V8 Engine also uses several threads internally: The main thread does what you would expect: fetch your code, compile it and then execute it There’s also a separate thread for compiling, so that the main thread can keep executing while the former is optimizing the code A Profiler thread that will tell the runtime on which methods we spend a lot of time so that Crankshaft can optimize them A few threads to handle Garbage Collector sweeps V8引擎还内部使用多个线程： 主线程执行你所期望的：获取代码，编译然后执行它 还有一个单独的线程用于编译，所以主线程在前者正在优化代码时可以继续执行 Profiler 线程将告诉运行时，我们花费大量时间的方法，以便 Crankshaft 编译器可以优化它们 几个处理垃圾收集器扫描的线程 When first executing the JavaScript code, V8 leverages full-codegen which directly translates the parsed JavaScript into machine code without any transformation. This allows it to start executing machine code very fast. Note that V8 does not use intermediate bytecode representation this way removing the need for an interpreter. 当第一次执行JavaScript代码时，V8利用full-codegen直接将解析后的 JavaScript 转换为机器代码，而无需任何转换。这使得它能够非常快地开始执行机器代码。注意，V8不会使用中间字节码表示，从而无需解释器。 When your code has run for some time, the profiler thread has gathered enough data to tell which method should be optimized. 当你的代码运行了一段时间后，Profiler 线程已经收集了足够的数据来判断应该优化哪个方法。 Next, Crankshaft optimizations begin in another thread. It translates the JavaScript abstract syntax tree to a high-level static single-assignment (SSA) representation called Hydrogen and tries to optimize that Hydrogen graph. Most optimizations are done at this level. 接下来，Crankshaft 从另一个线程开始优化。它将 JavaScript 抽象语法树转换为称为Hydrogen的高级静态单赋值（SSA）表示，并尝试优化Hydrogen图。大多数优化都是在这个级别完成的。 内联（Inlining）The first optimization is inlining as much code as possible in advance. Inlining is the process of replacing a call site (the line of code where the function is called) with the body of the called function. This simple step allows following optimizations to be more meaningful. 第一个优化是提前内联（Inlining）尽可能多的代码。内联是将被调用函数的函数体替换到调用位置（函数所在的代码行）的处理过程。这个简单的步骤让以下优化更有意义。 隐藏类（Hidden class）JavaScript is a prototype-based language: there are no classes and objects are created using a cloning process. JavaScript is also a dynamic programming language which means that properties can be easily added or removed from an object after its instantiation. JavaScript 是一种基于原型的语言：没有使用克隆创建类和对象的过程。 JavaScript 也是一种动态编程语言，这意味着在实例化之后，可以轻松地从对象中添加或删除属性。 Most JavaScript interpreters use dictionary-like structures (hash function based) to store the location of object property values in the memory. This structure makes retrieving the value of a property in JavaScript more computationally expensive than it would be in a non-dynamic programming language like Java or C#. In Java, all of the object properties are determined by a fixed object layout before compilation and cannot be dynamically added or removed at runtime (well, C# has the dynamic type which is another topic). As a result, the values of properties (or pointers to those properties) can be stored as a continuous buffer in the memory with a fixed-offset between each. The length of an offset can easily be determined based on the property type, whereas this is not possible in JavaScript where a property type can change during runtime. 大多数 JavaScript 解释器都使用类似字典的结构（基于哈希函数）将对象属性值的位置存储在内存中。这种结构使得检索 JavaScript 中的属性的值比在 Java 或 C# 这样的非动态编程语言中更昂贵。在 Java 中，所有对象属性都是由编译前的固定对象布局确定的，并且不能在运行时动态添加或删除（C# 具有动态类型，这是另一个话题了）。因此，属性值（或指向这些属性的指针）可以作为连续缓冲区存储在存储器中，它们之间具有固定偏移量，偏移量的长度可以根据属性类型容易地确定。而在 JavaScript中，属性类型可能会在运行时间内发生变化，这样做是不可能的。 Since using dictionaries to find the location of object properties in the memory is very inefficient, V8 uses a different method instead: hidden classes. Hidden classes work similarly to the fixed object layouts (classes) used in languages like Java, except they are created at runtime. Now, let’s see what they actually look like: 由于使用字典来查找对象属性在内存中的位置是非常低效的，所以 V8 使用不同的方法替代：隐藏类。隐藏类工作原理类似于 Java 语言中使用的固定对象布局（类），除了它们在运行时被创建。现在，我们来看看它们的实际情况： function Point(x, y) &#123; this.x = x; this.y = y;&#125;var p1 = new Point(1, 2); Once the new Point(1,2) invocation happens, V8 will create a hidden class called C0. 一旦 new Point(1,2) 被调用，V8 将创建一个隐藏的类 C0。 No properties have been defined for Point yet, so C0 is empty. 没有为 Point 定义属性，因此C0为空。 Once the first statement this.x = x is executed (inside the Point function), V8 will create a second hidden class called C1 that is based on C0. C1 describes the location in the memory (relative to the object pointer) where the property x can be found. In this case, x is stored at offset 0, which means that when viewing a point object in the memory as a continuous buffer, the first offset will correspond to property x. V8 will also update C0 with a class transition which states that if a property x is added to a point object, the hidden class should switch from C0 to C1. The hidden class for the point object below is now C1. 一旦执行了第一个语句this.x = x（在Point函数中），V8将创建一个基于C0的第二个隐藏类C1。 C1描述了可以找到属性x的内存中的位置（相对于对象指针）。在这种情况下，在偏移 0 处存储x，这意味着当将存储器中的点对象作为连续缓冲器查看时，第一个偏移将对应于属性x。 V8也会用类转换来更新C0，也就是说，如果将一个属性x添加到点对象，则隐藏类应该从C0切换到C1。下面的点对象的隐藏类现在是C1。 Every time a new property is added to an object, the old hidden class is updated with a transition path to the new hidden class. Hidden class transitions are important because they allow hidden classes to be shared among objects that are created the same way. If two objects share a hidden class and the same property is added to both of them, transitions will ensure that both objects receive the same new hidden class and all the optimized code that comes with it. 每次将新属性添加到对象中时, 旧的隐藏类都将用转换路径更新为新的隐藏类。隐藏类转换非常重要, 因为它们允许在以相同方式创建的对象之间共享隐藏类。如果两个对象共享一个隐藏类, 并且将相同的属性添加到它们中, 则转换将确保两个对象都收到相同的新隐藏类和随之而来的所有优化代码。 This process is repeated when the statement this.y = y is executed (again, inside the Point function, after the this.x = x statement). 当执行语句this.y = y（在Point函数内部，在this.x = x语句之后）时，会重复此过程。 A new hidden class called C2 is created, a class transition is added to C1 stating that if a property y is added to a Point object (that already contains property x) then the hidden class should change to C2, and the point object’s hidden class is updated to C2. 一个名为C2的新隐藏类被创建，类转换将被添加到C1，表示如果将属性y添加到Point对象（已包含属性x），则隐藏类应更改为C2，点对象的隐藏类也更新为C2。 Hidden class transitions are dependent on the order in which properties are added to an object. Take a look at the code snippet below: 隐藏类的转换取决于将属性添加到对象的顺序。看下面的代码片段： function Point(x, y) &#123; this.x = x; this.y = y;&#125;var p1 = new Point(1, 2);p1.a = 5;p1.b = 6;var p2 = new Point(3, 4);p2.b = 7;p2.a = 8; Now, you would assume that for both p1 and p2 the same hidden classes and transitions would be used. Well, not really. For p1, first the property a will be added and then the property b. For p2, however, first b is being assigned, followed by a. Thus, p1 and p2 end up with different hidden classes as a result of the different transition paths. In such cases, it’s much better to initialize dynamic properties in the same order so that the hidden classes can be reused. 现在，你可以假设对于p1和p2，将使用相同的隐藏类和转换。实际并不相同。对于p1，首先将添加属性a，然后添加属性b。但是，对于p2，首先分配b，然后再分配a。因此，由于不同的转换路径，p1和p2最终会有不同的隐藏类。在这种情况下，以相同的顺序初始化动态属性要更好，以便隐藏的类可以重用。 内联缓存（Inline caching）V8 takes advantage of another technique for optimizing dynamically typed languages called inline caching. Inline caching relies on the observation that repeated calls to the same method tend to occur on the same type of object. An in-depth explanation of inline caching can be found here. V8利用另一种称为内联缓存的技术来优化动态类型语言。内联缓存依赖于往往发生在同一类型对象上的对同一方法的重复调用的观察。可以在这里找到内联缓存的深入解释。 We’re going to touch upon the general concept of inline caching (in case you don’t have the time to go through the in-depth explanation above). 我们将简要说明内联缓存的一般概念（如果你没有时间通过​​上面的深入解释）。 So how does it work? V8 maintains a cache of the type of objects that were passed as a parameter in recent method calls and uses this information to make an assumption about the type of object that will be passed as a parameter in the future. If V8 is able to make a good assumption about the type of object that will be passed to a method, it can bypass the process of figuring out how to access the object’s properties, and instead, use the stored information from previous lookups to the object’s hidden class. 那么它是如何工作呢？ V8维护在最近的方法调用中作为参数传递的对象类型的缓存，并使用该信息对将来作为参数传递的对象类型做出假设。如果 V8 能够对未来传递给该方法的对象类型做出一个很好的假设，那么它可以绕过如何访问对象的属性的过程，而是使用来自先前查找的对象的隐藏类存储的信息。 So how are the concepts of hidden classes and inline caching related? Whenever a method is called on a specific object, the V8 engine has to perform a lookup to the hidden class of that object in order to determine the offset for accessing a specific property. After two successful calls of the same method to the same hidden class, V8 omits the hidden class lookup and simply adds the offset of the property to the object pointer itself. For all future calls of that method, the V8 engine assumes that the hidden class hasn’t changed, and jumps directly into the memory address for a specific property using the offsets stored from previous lookups. This greatly increases execution speed. 那么隐藏类和内联缓存的概念如何相关？无论何时在特定对象上调用方法，V8引擎必须对该对象的隐藏类执行查找，以确定访问特定属性的偏移量。在同一个隐藏类的两次成功调用相同的方法之后，V8省略了隐藏的类查找，并将属性的偏移量添加到对象指针本身。对于该方法的所有将来的调用，V8引擎假定隐藏类没有改变，并使用先前查找中存储的偏移量直接跳转到特定属性的内存地址。这大大提高了执行速度。 Inline caching is also the reason why it’s so important that objects of the same type share hidden classes. If you create two objects of the same type and with different hidden classes (as we did in the example earlier), V8 won’t be able to use inline caching because even though the two objects are of the same type, their corresponding hidden classes assign different offsets to their properties. 内联缓存也是为什么同一类型的对象共享隐藏类的重要的原因。如果你创建两个相同类型的对象和不同的隐藏类（如前面的示例），V8将无法使用内联缓存，因为即使两个对象的类型相同，它们的相应隐藏类为其属性分配不同的偏移量。 编译到机器码（Compilation to machine code）Once the Hydrogen graph is optimized, Crankshaft lowers it to a lower-level representation called Lithium. Most of the Lithium implementation is architecture-specific. Register allocation happens at this level. 一旦 Hydrogen 图被优化，Crankshaft 将其降低到称为 Lithium 的较低级别表示。大多数 Lithium 的实现都是针对架构的。寄存器分配发生在这个级别。 In the end, Lithium is compiled into machine code. Then something else happens called OSR: on-stack replacement. Before we started compiling and optimizing an obviously long-running method, we were likely running it. V8 is not going to forget what it just slowly executed to start again with the optimized version. Instead, it will transform all the context we have (stack, registers) so that we can switch to the optimized version in the middle of the execution. This is a very complex task, having in mind that among other optimizations, V8 has inlined the code initially. V8 is not the only engine capable of doing it. 最后，Lithium 被编译为机器码。然后发生称为 OSR 其他事：堆栈替换。在我们开始编译和优化一个明显长期运行的方法之前，我们可能会运行它。 V8 不会忘记它刚刚缓慢执行的结果，不会再次运行它。相反，它将转换所有的上下文（堆栈，寄存器），以便我们可以在执行过程中切换到优化版本。这是一个非常复杂的任务，请记住，除了其他优化之外，V8在初始化的时候已经内联了代码。 V8不是唯一能够做到这一点的引擎。 There are safeguards called deoptimization to make the opposite transformation and revert back to the non-optimized code in case an assumption the engine made doesn’t hold true anymore. 有一种称为去优化的保护措施，作出相反的转换，并恢复为非优化代码，以防引擎之前做的的假设不再成立（假设隐藏类没有改变）。 垃圾回收（Garbage collection）For garbage collection, V8 uses a traditional generational approach of mark-and-sweep to clean the old generation. The marking phase is supposed to stop the JavaScript execution. In order to control GC costs and make the execution more stable, V8 uses incremental marking: instead of walking the whole heap, trying to mark every possible object, it only walk part of the heap, then resumes normal execution. The next GC stop will continue from where the previous heap walk has stopped. This allows for very short pauses during the normal execution. As mentioned before, the sweep phase is handled by separate threads. 对于垃圾收集，V8采用传统的标记-清除的扫描方法处理 old generation 。标记阶段应该停止执行JavaScript。为了控制 GC 成本并使执行更加稳定，V8使用增量式标记：而不是遍历整个堆，尝试标记每一个可能的对象，相反，只是遍历一部分堆，然后恢复正常执行。下一个 GC 将继续从之前的遍历停止的位置开始。这允许在正常执行期间有非常短的暂停。如前文所述，扫描阶段由单独的线程处理。 Ignition and TurboFanWith the release of V8 5.9 earlier in 2017, a new execution pipeline was introduced. This new pipeline achieves even bigger performance improvements and significant memory savings in real-world JavaScript applications. 随着V8 5.9 的版本在2017年早些时候发布，新的执行流程被推出。这个新的管道体系在实际的 JavaScript 应用程序中实现了更大的性能改进和显着的内存节省。 The new execution pipeline is built on top of Ignition, V8’s interpreter, and TurboFan, V8’s newest optimizing compiler. 这个新的执行管道建立在 V8 的新解释器on top of Ignition和V8的最新优化编译器TurboFan之上。 You can check out the blog post from the V8 team about the topic here. 你可以在V8团队中查看有关这个主题的博文。 Since version 5.9 of V8 came out, full-codegen and Crankshaft (the technologies that have served V8 since 2010) have no longer been used by V8 for JavaScript execution as the V8 team has struggled to keep pace with the new JavaScript language features and the optimizations needed for these features. 由于 V8 5.9版本的出炉，V8将不再使用 full-codegen 和 Crankshaft （自2010年起服务于 V8 的技术），因为V8团队努力跟上新的JavaScript语言功能，这些功能需要优化。 This means that overall V8 will have much simpler and more maintainable architecture going forward. 这意味着整体V8将会有更简单和更易维护的架构。 These improvements are just the start. The new Ignition and TurboFan pipeline pave the way for further optimizations that will boost JavaScript performance and shrink V8’s footprint in both Chrome and Node.js in the coming years. 这些改进只是一开始。新的 Ignition 和 TurboFan 管道为进一步优化铺平了道路，这将在未来几年内提升JavaScript性能并缩小V8在Chrome和Node.js中的占地面积。 Finally, here are some tips and tricks on how to write well-optimized, better JavaScript. You can easily derive these from the content above, however, here’s a summary for your convenience: 最后，这里有一些关于如何编写更优的，更好的 JavaScript 的技巧。你可以从上面的内容中轻松获得这些内容，但是，为了方便起见，这里有一个摘要： 如何编写优化的JavaScript（How to write optimized JavaScript）1.Order of object properties: always instantiate your object properties in the same order so that hidden classes, and subsequently optimized code, can be shared. 对象属性的顺序：始终以相同的顺序实例化对象属性，以便可以共享隐藏类和随后优化的代码。 2.Dynamic properties: adding properties to an object after instantiation will force a hidden class change and slow down any methods that were optimized for the previous hidden class. Instead, assign all of an object’s properties in its constructor. 动态属性：在实例化后向对象添加属性将强制隐藏类更改，并减缓任何为先前隐藏类优化的方法。相反，在其构造函数中分配对象的所有属性。 3.Methods: code that executes the same method repeatedly will run faster than code that executes many different methods only once (due to inline caching). 方法：重复执行相同方法的代码将比只执行一次的代码（由于内联缓存）运行得快。 4.Arrays: avoid sparse arrays where keys are not incremental numbers. Sparse arrays which don’t have every element inside them are a hash table. Elements in such arrays are more expensive to access. Also, try to avoid pre-allocating large arrays. It’s better to grow as you go.Finally, don’t delete elements in arrays. It makes the keys sparse. 数组：避免键值不是增量数字的稀疏数组。不包含每个元素的稀疏数组是一个哈希表。访问这种数组元素的代价更加昂贵。另外，尽量避免预分配大数组。最好随着你的使用而增长。最后，不要删除数组中的元素。它使键值稀疏。 5.Tagged values: V8 represents objects and numbers with 32 bits. It uses a bit to know if it is an object (flag = 1) or an integer (flag = 0) called SMI (SMall Integer) because of its 31 bits. Then, if a numeric value is bigger than 31 bits, V8 will box the number, turning it into adouble and creating a new object to put the number inside. Try to use 31 bit signed numbers whenever possible to avoid the expensive boxing operation into a JS object. 标记值：V8 使用 32位 表示对象和数字。它使用一个位来知道它是一个对象（flag = 1）还是一个称为SMI（SMall Integer）的整数（flag = 0），因为它是31位。因此，如果一个数值大于31位，V8 将会把数字转换为 double，并创建一个新对象把数字放在里面。尽可能使用31位有符号数字，以避免将数字转换为jc对象的昂贵的装箱操作。 We at SessionStack try to follow these best practices in writing highly optimized JavaScript code. The reason is that once you integrate SessionStack into your production web app, it starts recording everything: all DOM changes, user interactions, JavaScript exceptions, stack traces, failed network requests, and debug messages. 我们在 SessionStack 尝试遵循这些最佳做法来编写高度优化的 JavaScript 代码。原因是一旦将 SessionStack 集成到生产网络应用程序中，它就开始记录所有内容：所有DOM更改，用户交互，JavaScript异常，堆栈跟踪，失败的网络请求和调试消息。 With SessionStack, you can replay issues in your web apps as videos and see everything that happened to your user. And all of this has to happen with no performance impact for your web app. 使用SessionStack，你可以将Web应用中的问题重现为视频，并查看发生在你用户的一切。所有的一切都必须重新，并且不对你的 web 应用程序的性能产生影响。 There is a free plan that allows you to get started for free. 这里是一个免费的计划，让你免费入门。 资源 https://docs.google.com/document/u/1/d/1hOaE7vbwdLLXWj3C8hTnnkpE0qSa2P–dtDvwXXEeD0/pub https://github.com/thlorenz/v8-perf http://code.google.com/p/v8/wiki/UsingGit http://mrale.ph/v8/resources.html https://www.youtube.com/watch?v=UJPdhx5zTaw https://www.youtube.com/watch?v=hWhMKalEicY","categories":[{"name":"翻译","slug":"翻译","permalink":"http://tcatche.site/categories/%E7%BF%BB%E8%AF%91/"}],"tags":[{"name":"js","slug":"js","permalink":"http://tcatche.site/tags/js/"},{"name":"翻译","slug":"翻译","permalink":"http://tcatche.site/tags/%E7%BF%BB%E8%AF%91/"}]},{"title":"JavaScript 是如何工作的：引擎，运行时和调用堆栈的概述","slug":"how-javascript-work-part-1-overview","date":"2017-08-29T07:24:00.000Z","updated":"2018-08-01T10:41:24.000Z","comments":true,"path":"2017/08/how-javascript-work-part-1-overview/","link":"","permalink":"http://tcatche.site/2017/08/how-javascript-work-part-1-overview/","excerpt":"","text":"原文：How JavaScript works: an overview of the engine, the runtime, and the call stack As JavaScript is getting more and more popular, teams are leveraging its support on many levels in their stack - front-end, back-end, hybrid apps, embedded devices and much more. 随着 JavaScript 越来越受欢迎，许多团队在他们技术栈的多个方面使用它：前端，后端，混合应用程序，嵌入式设备等等。 As shown in the GitHut stats, JavaScript is at the top in terms of Active Repositories and Total Pushes in GitHub. It doesn’t lag behind much in the other categories either. 如 GitHut统计 所示，JavaScript 在 GitHub 中的活跃仓库和总推送方面位于顶部，在其他类别中也没有落后很多。 If projects are getting so much dependent on JavaScript, this means that developers have to be utilizing everything that the language and the ecosystem provide with deeper and deeper understanding of the internals, in order to build amazing software. 如果项目越来越依赖 JavaScript，这意味着开发人员必须利用这门语言和生态系统提供的所有内容，并且深入地了解其内部内容，以便构建出惊人的软件。 As it turns out, there are a lot of developers that are using JavaScript on a daily basis but don’t have the knowledge of what happens under the hood. 事实证明，有很多开发人员每天都在使用JavaScript，但并不知道什么情况下会发生什么。 概述（Overview）Almost everyone has already heard of the V8 Engine as a concept, and most people know that JavaScript is single-threaded or that it is using a callback queue. 几乎所有人都已经听说过V8引擎的概念，大多数人都知道JavaScript是单线程的，或者是使用回调队列。 In this post, we’ll go through all these concepts in detail and explain how JavaScript actually runs. By knowing these details, you’ll be able to write better, non-blocking apps that are properly leveraging the provided APIs. 在这篇文章中，我们将详细介绍所有这些概念，并解释 JavaScript 如何运行。了解这些细节，你将能够正确利用提供的 API 编写更好的非阻塞性应用程序。 If you’re relatively new to JavaScript, this blog post will help you understand why JavaScript is so “weird” compared to other languages. 如果你是 JavaScript 初学者，此博客文章将帮助你了解为什么 JavaScript 与其他语言相比是如此“奇怪”。 And if you’re an experienced JavaScript developer, hopefully, it will give you some fresh insights on how the JavaScript Runtime you’re using every day actually works. 如果你是一位经验丰富的 JavaScript 开发人员，希望能为你提供一些关于你每天使用的 JavaScript 运行时实际工作的新见解。 JavaScript引擎（The JavaScript Engine）A popular example of a JavaScript Engine is Google’s V8 engine. The V8 engine is used inside Chrome and Node.js for example. Here is a very simplified view of what it looks like: JavaScript 引擎的一个流行示例是 Google 的 V8 引擎。V8 引擎被 Chrome 和 Node.js 使用。这是一个该引擎非常简化的视图： The Engine consists of two main components: Memory Heap - this is where the memory allocation happens Call Stack - this is where your stack frames are as your code executes 引擎由两个主要组成部分组成： 内存堆 - 这是内存分配发生的地方 调用堆栈 - 这是你的代码执行时堆栈帧的位置 运行时（The Runtime）There are APIs in the browser that have been used by almost any JavaScript developer out there (e.g. “setTimeout”). Those APIs, however, are not provided by the Engine. 浏览器中已经有一些几乎被所有 JavaScript 开发人员使用的API（例如“setTimeout”）。然而，引擎不提供这些API。 So, where are they coming from? It turns out that the reality is a bit more complicated. 那么他们从哪里来？ 事实上，这有点复杂。 So, we have the Engine but there is actually a lot more. We have those things called Web APIs which are provided by browsers, like the DOM, AJAX, setTimeout and much more. 所以，我们有引擎，但实际上还有更多内容。有一些被称为 Web API 的东西，由浏览器提供，如 DOM，AJAX，setTimeout 等等。 And then, we have the so popular event loop and the callback queue. 然后，还有受欢迎的事件循环和回调队列。 调用堆栈（The Call Stack）JavaScript is a single-threaded programming language, which means it has a single Call Stack. Therefore it can do one thing at a time. JavaScript是一种单线程编程语言，这意味着它有一个单一的调用堆栈。因此，它一次只可以做一件事。 The Call Stack is a data structure which records basically where in the program we are.If we step into a function, we put it on the top of the stack. If we return from a function, we pop off the top of the stack. That’s all the stack can do. 调用堆栈是一个数据结构，它记录了我们在程序的基本位置。如果我们进入一个函数，我们把它放在堆栈的顶部。如果我们从一个函数返回，我们弹出堆栈的顶部。这就是堆栈做的事情。 Let’s see an example. Take a look at the following code: 我们来看一个例子。看看下面的代码： function multiply(x, y) &#123; return x * y;&#125;function printSquare(x) &#123; var s = multiply(x, x); console.log(s);&#125;printSquare(5); When the engine starts executing this code, the Call Stack will be empty. Afterwards, the steps will be the following: 当引擎开始执行此代码时，调用堆栈将为空。之后，步骤如下 Each entry in the Call Stack is called a Stack Frame. 进入调用堆栈中的每个条目称为堆栈帧。 And this is exactly how stack traces are being constructed when an exception is being thrown — it is basically the state of the Call Stack when the exception happened. Take a look at the following code: 这正是在抛出异常时构造堆栈跟踪的方式 — 当异常发生时，它基本上是调用堆栈的状态。看看下面的代码： function foo() &#123; throw new Error(&#x27;SessionStack will help you resolve crashes :)&#x27;);&#125;function bar() &#123; foo();&#125;function start() &#123; bar();&#125;start(); If this is executed in Chrome (assuming that this code is in a file called foo.js), the following stack trace will be produced: 如果这是在 Chrome 中执行的（假设此代码位于一个名为foo.js的文件中），则会产生以下堆栈跟踪： Blowing the stack — this happens when you reach the maximum Call Stack size. And that could happen quite easily, especially if you’re using recursion without testing your code very extensively. Take a look at this sample code: Blowing the stack — 当你达到最大调用堆栈尺寸时，会发生这种情况。这可能会非常容易发生，特别是如果你在不经过很大程度测试代码的情况下使用递归。看看这个示例代码： function foo() &#123; foo();&#125;foo(); When the engine starts executing this code, it starts with calling the function “foo”. This function, however, is recursive and starts calling itself without any termination conditions. So at every step of the execution, the same function gets added to the Call Stack over and over again. It looks something like this: 当引擎开始执行这个代码时，它首先调用 “foo” 函数。然而，此函数是递归的，并且开始调用自身而没有任何终止条件。所以在执行的每个步骤中，相同的函数都被一次又一次地添加到调用堆栈中。看起来像这样： At some point, however, the number of function calls in the Call Stack exceeds the actual size of the Call Stack, and the browser decides to take action, by throwing an error, which can look something like this: 然后，在调用堆栈中的函数调用次数超过了调用堆栈的实际大小的时候，浏览器决定采取行动，抛出一个错误，看起来像这样： Running code on a single thread can be quite easy since you don’t have to deal with complicated scenarios that are arising in multi-threaded environments — for example, deadlocks. 在单线程上运行代码可能非常容易，因为你不必处理在多线程环境中出现的复杂场景，例如死锁。 But running on a single thread is quite limiting as well. Since JavaScript has a single Call Stack, what happens when things are slow? 但在单线程上运行也是非常受限的。由于JavaScript有一个调用堆栈，当事情开始缓慢时会发生什么？ 并发和事件循环（Concurrency &amp; the Event Loop）What happens when you have function calls in the Call Stack that take a huge amount of time in order to be processed? For example, imagine that you want to do some complex image transformation with JavaScript in the browser. 当你在调用堆栈中进行函数调用需要大量时间才能进行处理时会发生什么？例如，假设你想在浏览器中使用 JavaScript 进行一些复杂的图像转换。 You may ask — why is this even a problem? The problem is that while the Call Stack has functions to execute, the browser can’t actually do anything else — it’s getting blocked. This means that the browser can’t render, it can’t run any other code, it’s just stuck. And this creates problems if you want nice fluid UIs in your app. 你可能会问 - 为什么这是一个问题？问题在于，当调用堆栈有函数在执行的时候，浏览器实际上不能做任何事情 - 它被阻塞了。这意味着浏览器无法渲染任何内容，它也不能运行任何其他代码，它卡住了。如果你想要的UI流畅，这会产生问题。 And that’s not the only problem. Once your browser starts processing so many tasks in the Call Stack, it may stop being responsive for quite a long time. And most browsers take action by raising an error, asking you whether you want to terminate the web page. 这不是唯一的问题。一旦你的浏览器开始处理“调用堆栈”中的许多任务，它可能会停止响应很长时间。大多数浏览器通过提出错误来采取行动，询问你是否要终止网页。 Now, that’s not the best user experience out there, is it? 这不是最好的用户体验，不是吗？ So, how can we execute heavy code without blocking the UI and making the browser unresponsive? Well, the solution is asynchronous callbacks. 那么，如何不阻塞 UI 并不造成使浏览器不响应的情况下执行繁重的代码呢？解决方案是异步回调。 This will be explained in great detail in Part 2 of the “How JavaScript actually work” tutorial. Stay tuned :) 这将在“如何JavaScript实际工作”教程的第2部分中详细解释。敬请关注 :)。","categories":[{"name":"翻译","slug":"翻译","permalink":"http://tcatche.site/categories/%E7%BF%BB%E8%AF%91/"}],"tags":[{"name":"js","slug":"js","permalink":"http://tcatche.site/tags/js/"},{"name":"翻译","slug":"翻译","permalink":"http://tcatche.site/tags/%E7%BF%BB%E8%AF%91/"}]},{"title":"外边距合并（margin collapsing）和 块格式上下文（Block formatting contexts）","slug":"mastering_margin_collapsing_and_block_formatting_context","date":"2017-08-29T04:11:00.000Z","updated":"2021-05-12T02:30:45.266Z","comments":true,"path":"2017/08/mastering_margin_collapsing_and_block_formatting_context/","link":"","permalink":"http://tcatche.site/2017/08/mastering_margin_collapsing_and_block_formatting_context/","excerpt":"","text":"外边距合并（margin collapsing）在流式布局中，两个或者多个毗邻元素块的外边距（margin）在垂直方向上会被合并为单个的外边距，其大小是两个块中的最大的外边距，这就是外边距合并（margin collapsing） 首先要注意的是，发生合并是元素块之间相互的行为，元素块数量则必须大于一个，单个元素块不存在合并的行为。其次，只有垂直方向上的 margin 会发生合并，水平方向上的并不会合并。 发生外边距合并这要有三种情况： 相邻的兄弟元素两个相邻的兄弟元素会发生边距合并，如： &lt;div class=&quot;block&quot;&gt; &lt;h2&gt;相邻的兄弟元素会发生边距合并&lt;/h2&gt; &lt;p style=&quot;margin-bottom: 40px;&quot;&gt;下外边距被合并...&lt;/p&gt; &lt;p style=&quot;margin-top: 20px;&quot;&gt;...上外边距被合并。&lt;/p&gt;&lt;/div&gt; 如上例，此时上下边距发生合并，距离为较大的一个边距 40px， 而不是 60px。 块级父元素与其第一个或最后一个子元素如果块级父元素中，不存在 border top 和 padding top，且其在普通流中第一个子元素不存在清除浮动这个属性（也即上边框宽度及上内边距距离为0时），此时这个块级父元素和其第一个子元素就会发生上外边距合并现象。此时这个父元素对外展现出来的外边距将直接变成这个父元素和其第一个子元素的 margin-top 的较大者。 同样的，块级父元素没有 border bottom、padding bottom、inline content、height=auto、min-height、 max-height 分隔时，就会与它的最后一个子元素的 margin-bottom 发生下外边距合并 。如下html和css： html: &lt;div class=&quot;block1&quot;&gt; ...&lt;/div&gt;&lt;div class=&quot;block2&quot;&gt; &lt;h2&gt;块级父元素与其第一个和最后一个子元素发生边距合并&lt;/h2&gt; &lt;p class=&quot;p1&quot;&gt;...&lt;/p&gt; &lt;p class=&quot;p1 last&quot;&gt;...&lt;/p&gt;&lt;/div&gt;&lt;div class=&quot;block3&quot;&gt; ...&lt;/div&gt; css: div.block2 &#123; margin: 10px 40px 10px;&#125;.p1 &#123; height: 20px; border: 1px solid #f00;&#125;.block2 h2 &#123; margin-top: 30px;&#125;p.last &#123; margin-bottom: 30px;&#125; 在上述示例中，block1 和 block2&gt;h2 元素之间的距离实际是 30px 而不是 30px + 10px；同样的 block2&gt;p1.last 和 block3 之间也是如此。 注意，在这种情况下，框的顶部边界被定义为父元素的边界，也就是说，block2 如果设置背景颜色，则背景不包括 h2 元素 margin-top 的 10px ，此时等价于： div.block2 &#123; margin-top: 30px;&#125;.block2 h2 &#123; margin-top: 0;&#125; 空内容的块元素如果一个块级元素内容为空，并且其 border、padding、inline content、height、min-height 都不存在，也即不存在任何能使元素高度大于0的属性，则此时其上下边距中间都没有阻碍，它的上下边距都会合并。 &lt;div class=&quot;block&quot;&gt; &lt;h2&gt;空内容的块元素会发生边距合并&lt;/h2&gt; &lt;p style=&quot;margin-bottom: 20px;&quot;&gt;下外边距被合并...&lt;/p&gt; &lt;p style=&quot;margin-top: 20px; margin-bottom: 20px;&quot;&gt;&lt;/p&gt; &lt;p style=&quot;margin-top: 10px;&quot;&gt;...上外边距被合并。&lt;/p&gt;&lt;/div&gt; 此时，中间的p元素将会被忽略，即使其指定了上下边距，但实际上，第一个 p 元素和第三个p元素的 margin 实际为较大的一个，即 20px，而不是 20px + 20px + 10px。 负边距处理当存在边距合并的两个元素中间有负边距，则实际边距是绝对值最大的那个负边距的绝对值减去绝对值最大的正边距，如果不存在正边距，则减去 0。 也就是说当相邻元素的边距有一个为负边距时，合并后的外边距将是最大正边距加上最小负边距，即负边距中绝对值最大的一个。若两个都为负边距，则合并后的外边距将是即负边距中绝对值最大的一个。 &lt;p class=&quot;p1&quot; style=&quot;margin-bottom: 10px;&quot;&gt;正边距1...&lt;/p&gt;&lt;p class=&quot;p2&quot; style=&quot;margin-top: -20px;background:green;&quot;&gt;有一个负边距被求和合并&lt;/p&gt;&lt;p class=&quot;p3&quot; style=&quot;margin-top: 40px; margin-bottom: -20px;&quot;&gt;正边距2...&lt;/p&gt;&lt;p class=&quot;p4&quot; style=&quot;margin-top: -10px;background:green;&quot;&gt;都为负边距取最大绝对值合并&lt;/p&gt; 在上述示例中，p1 与 p2之间的外间距为 (10px + (-20px)) 而 p1 与 p2 之间的外间距为 min(-20px, -10px)。 本节三部分内容的完整示例： See the Pen Margin collapsing by tcatche (@tcatche) on CodePen. 取消边距合并这个很简单，破坏上述发生合并的前提条件即可，通常是通过创建块格式上下文解决: 如在 p 外面包裹一层容器，并触发该容器生成一个 BFC。那么两个 P 便不属于同一个 BFC，就不会发生 margin 合并了： &lt;div class=&quot;block&quot;&gt; &lt;h2&gt;相邻的兄弟元素会发生边距合并&lt;/h2&gt; &lt;p style=&quot;margin-bottom: 40px;&quot;&gt;下外边距不被合并...&lt;/p&gt; &lt;div style=&quot;overflow: hidden&quot;&gt;&lt;p style=&quot;margin-top: 20px;&quot;&gt;...上外边距不被合并。&lt;/p&gt;&lt;/div&gt;&lt;/div&gt; 当然也可以使用 clear 属性解决，同时也会解决非浮动块的边框无法包括浮动元素的问题。 块格式上下文（Block formatting contexts）首先普通流包含三种：块格式上下文（Block formatting contexts, BFC）、inline formatting context 和 Relative positioning。 块格式上下文页面是普通流的一部分。一个块格式化上下文由以下之一创建： 根元素 floats 值不是 none 绝对定位元素即 position 为 absolute 或 fixed 的元素 display: inline-block、table-cells（HTML表格单元格默认属性）、table-captions（HTML表格标题默认属性）、flex、 inline-flex overflow 值不是 visible 在块格式上下文中，从容器块的顶部开始，垂直地布置内部块。两个兄弟块之间的垂直距离由 margin 属性决定，块格式化上下文内相邻块之间的垂直边距会发生边距合并。 在块格式上下文中，每个框的左外边缘挨着容器块的左边缘（如果是从右到左的格式，则从右边开始）。即使在浮动状态的情况下也是如此（尽管盒子的线框可能由于浮动而收缩），除非盒子建立了一个新的块格式化环境（在这种情况下盒子本身可能由于浮动而变得更窄）。 块格式上下文的特点块格式化上下文的行与普通块类似，除了这几条： 块格式化上下文可防止边缘合并相邻块框只有在相同的块格式上下文中才垂直边距合并。换句话说，如果相邻的框不属于相同的块格式上下文，则它们的边距不会崩溃。 &lt;div class=&quot;block1&quot;&gt; &lt;h2&gt;块格式化上下文可防止边缘合并&lt;/h2&gt; &lt;p class=&quot;p1&quot;&gt;下外边距被合并...&lt;/p&gt; &lt;p class=&quot;p1&quot;&gt;...上外边距被合并。&lt;/p&gt; &lt;div style=&quot;overflow:hidden&quot;&gt;&lt;p class=&quot;p1&quot; &gt;...上外边距不被合并。&lt;/p&gt;&lt;/div&gt;&lt;/div&gt; .p1 &#123; height: 20px; border: 1px solid #f00; margin: 20px; background: green;&#125; 块格式化上下文可包含 float 块如果一个float 块位于块格式化上下文内，则被其容纳，否则不被包括。 &lt;div style=&quot;border: 1px solid #333&quot;&gt; &lt;h2&gt;块级父元素与其第一个和最后一个子元素发生边距合并&lt;/h2&gt; &lt;div class=&quot;block&quot;&gt; &lt;h3&gt;不包含内部 float 块&lt;/h3&gt; &lt;p class=&quot;p1&quot; style=&quot;float: left;&quot;&gt; 内部块1不在父div框中 &lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;block&quot; style=&quot;overflow:hidden&quot;&gt; &lt;h3&gt;包含内部 float 块&lt;/h3&gt; &lt;p class=&quot;p1&quot; style=&quot;float: left;&quot;&gt; 内部块2在父div框中 &lt;/p&gt; &lt;/div&gt;&lt;/div&gt; 在上述示例中，内部第二个 block 创建了块格式化上下文，因此其能容纳内部的 float，而第一个 block 并不是，所以 float 在其边框之外。 块格式化上下文和 float 块不会合并根据规范，块格式化上下文的边框不与同一块格式上下文中的浮动块边框相合并。如此，应用于浮动块旁边的块格式化上下文的负边距不起作用。小于其宽度（元素宽度+边框+边距+补白）的边距也不起作用。 &lt;div class=&quot;block&quot;&gt; &lt;h2&gt;空内容的块元素会发生边距合并&lt;/h2&gt; &lt;div class=&quot;block1&quot; style=&quot;float: left;width:100px;padding: 10px&quot;&gt; &lt;h3&gt;float 块&lt;/h3&gt; &lt;/div&gt; &lt;div class=&quot;block2&quot; style=&quot;overflow:hidden;width:100px;margin-left: 20px&quot;&gt; &lt;h3&gt;块格式化上下文块&lt;/h3&gt; &lt;/div&gt;&lt;/div&gt; 在这个例子中，如果要设置 block2 和 block1 的间距位 margin-left: 20px 并不起作用，实际上需要设置的值为 block1 的 width + border * 2 + padding * 2 + margin-left + 自身的margin-right + block2 的 margin-left ，当然这样很繁琐，可以简单设置 block 的 margin-right 为 block2 的 margin-left + block1 的原来的 margin-left。 .block1 &#123; margin-right: 20px;&#125;// or.block2 &#123; margin-left: 140px; // 100px + 10px*2 + 20px&#125; 常见的浮动布局就是利用这一特性实现的，这里不在说明。 本节三部分内容的完整示例： See the Pen Block formatting contexts by tcatche (@tcatche) on CodePen. 参考 Cascading Style Sheets Level 2 Revision 2 (CSS 2.2) Specification#8.3.1 Collapsing margins Mastering margin collapsing Cascading Style Sheets Level 2 Revision 2 (CSS 2.2) Specification#9.4.1Block formatting contexts Block Formatting Contexts","categories":[{"name":"css","slug":"css","permalink":"http://tcatche.site/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"http://tcatche.site/tags/css/"},{"name":"html","slug":"html","permalink":"http://tcatche.site/tags/html/"},{"name":"bfc","slug":"bfc","permalink":"http://tcatche.site/tags/bfc/"},{"name":"块格式上下文","slug":"块格式上下文","permalink":"http://tcatche.site/tags/%E5%9D%97%E6%A0%BC%E5%BC%8F%E4%B8%8A%E4%B8%8B%E6%96%87/"},{"name":"外边距合并","slug":"外边距合并","permalink":"http://tcatche.site/tags/%E5%A4%96%E8%BE%B9%E8%B7%9D%E5%90%88%E5%B9%B6/"}]},{"title":"回流（Reflow）和重绘（Repaint）","slug":"repaint-and-reflow","date":"2017-08-25T06:02:00.000Z","updated":"2018-08-01T10:41:24.000Z","comments":true,"path":"2017/08/repaint-and-reflow/","link":"","permalink":"http://tcatche.site/2017/08/repaint-and-reflow/","excerpt":"","text":"最近在重看一些基础的理论知识，看到了回流（Reflow）和重绘（Repaint）的概念，惭愧的发现，对此竟然说不出太详细的内容，在此参阅一些文章进行一个总结。 在了解这两个概念之前先了解一下 HTML 的渲染过程。 HTML 渲染过程浏览的引擎处理 HTML 的基本流程分为如下四个步骤： 1.解析 HTML 并构建 DOM 树和 CSSOM 树。浏览器对 HTML 进行解析，将 HTML 标记转换成文档对象模型 (DOM)，CSS 标记则被转换成 CSS 对象模型 (CSSOM)，而 DOM 和 CSSOM 是独立的数据结构。在解析过程中，DOM 树包含了所有的 html 标签，包括不展示的 head 节点和 display:none 的节点，而 CSSOM 树则会去掉浏览器不能识别的样式，比如不支持的浏览器前缀（chrome不支持的-moz-前缀）和 hack（如firefox不支持_开头的样式）。 2.构建 render 树。将 DOM 树和 CSSOM 树合并为 render 树，在这个过程中，需要计算每一个呈现对象的可视化属性，会去掉不展示在页面上的节点（如 display:none 和 head 节点等）。 3.布局 render 树。render 树在创建完成时，并不包含位置和大小信息。计算这些值的过程称为布局或重排。从 render 树的根节点（（对应于 HTML 文档的 元素））递归调用，计算每一个元素的位置和大小信息。 4.使用 render 树绘制页面。在绘制阶段，系统会遍历 render 树，将其内容显示在屏幕上。绘制的顺序其实就是元素进入堆栈样式上下文的顺序。这些堆栈会从后往前绘制，因此这样的顺序会影响绘制。这就是浏览器引擎处理页面的基本流程了。接下来我们看一下回流和重绘的概念 回流（Reflow）和重绘（Repaint）回流和重绘分别出现在上面的第三和第四步。 回流（Reflow）：当 render 树中的一部分(或全部)因为元素的规模尺寸，布局，隐藏等改变而需要重新构建。这就称为回流(reflow)。每个页面至少需要一次回流，就是在页面第一次加载的时候。在回流的时候，浏览器会使渲染树中受到影响的部分失效，并重新构造这部分渲染树，完成回流后，浏览器会重新绘制受影响的部分到屏幕中，该过程成为重绘。 重绘（Repaint）：当render tree中的一些元素需要更新属性，而这些属性只是影响元素的外观，风格，而不会影响 render 树重新布局的，比如修改了元素的 background-color。 由上定义可以看出，回流必将引起重绘，而重绘不一定会引起回流。明显回流的成本比重绘的成本高得多。 引起回流和重绘的操作任何对 render 树中元素的操作都会引起回流或者重绘： 改变 DOM 树结构，比如添加或者删除可见的元素、改变文本内容、改变位置； 改变元素几何尺寸：边距、填充、边框、宽度和高度； 用户改变浏览器窗口尺寸； CSS伪类激活，在用户交互过程中发生； 获取某些属性，浏览器一般对引起回流、重绘的操作进行优化，将多个操作合并在固定时候执行，如果此时获取一些 style 信息，则会提前执行操作，以提供准确数值。常见的这类信息如：offsetTop/offsetLeft/offsetWidth/offsetHeight、scrollTop/Left/Width/Height，具体可以查看 CSS Triggers 减少回流和重绘减少回流、重绘其实就是需要减少对render 树的操作，合并多次 DOM 和样式的修改，并减少对一些style信息的请求。具体有： 避免多次更改样式属性，合并为一个当更该样式的时候，可以更改class 或者将多个更改操作合并为一个： // 不好的写法var left = 1;var top = 1;el.style.left = left + &quot;px&quot;;el.style.top = top + &quot;px&quot;;// 比较好的写法el.className += &quot; className1&quot;; // 比较好的写法el.style.cssText += &quot;; left: &quot; + left + &quot;px; top: &quot; + top + &quot;px;&quot;; 将要操作的元素“离线处理”主要注意三点： 使用 DocumentFragment 进行缓存操作，引发一次回流和重绘； 使用 display:none 技术，只引发两次回流和重绘； 使用 cloneNode(true or false) 和 replaceChild 技术，引发一次回流和重绘； 减少操作影响的元素将导致多次回流的元素，position 属性设为 absolute 或 fixed，这样此元素就脱离了文档流，它的变化不会影响到其他元素。例如有动画效果的元素就最好设置为绝对定位。 读取引起回流的属性，尽量缓存// 不好的写法for(;;) &#123; el.style.left = el.offsetLeft + 5 + &quot;px&quot;; el.style.top = el.offsetTop + 5 + &quot;px&quot;;&#125;// 这样写好点var left = el.offsetLeft,top = el.offsetTop,s = el.style;for(;;) &#123; left += 10; top += 10; s.left = left + &quot;px&quot;; s.top = top + &quot;px&quot;;&#125; 参考 Google Web Fundamentals-关键渲染路径 高性能WEB开发(8) - 页面呈现、重绘、回流。 扩展阅读 浏览器的工作原理：新式网络浏览器幕后揭秘 无线性能优化：Composite CSS Animation性能优化 CSS Triggers：CSS中影响Layout、Paint和Composite的属性","categories":[{"name":"html","slug":"html","permalink":"http://tcatche.site/categories/html/"}],"tags":[{"name":"dom","slug":"dom","permalink":"http://tcatche.site/tags/dom/"},{"name":"html","slug":"html","permalink":"http://tcatche.site/tags/html/"}]},{"title":"深入理解层叠上下文（stacking context）和 z-index","slug":"stacking-context-and-z-index","date":"2017-08-22T10:47:00.000Z","updated":"2021-05-12T01:38:58.236Z","comments":true,"path":"2017/08/stacking-context-and-z-index/","link":"","permalink":"http://tcatche.site/2017/08/stacking-context-and-z-index/","excerpt":"","text":"在CSS的盒模型中，所有的元素除了可以再屏幕上自由摆放外，还可以沿着 z轴 进行摆放，特别是当元素为止互相重叠的时候，了解z轴的摆放顺序非常重要。使用 z-index 可以改变元素在 z轴 的上下层级，但是 z-index 具体是如何影响元素的层级呢？为什么有时候它并不生效。本文详细总结一下这些问题。 层叠上下文（stacking context）元素被绘制到画布上的层级顺序用层叠上下文来描述。当前层叠上下文可以包含子层叠上下文，当元素的内容发生层叠后，整个该元素将会在父层叠上下文中按顺序进行层叠。每个层叠上下文完全独立于它的兄弟元素，在其他层叠环境中的元素不会影响当前层叠环境。 每个盒元素都属于一个层叠上下文。给定层叠上下文中的每个定位元素都具有一个整数的层叠层级，具有更大堆栈级别的元素盒子总是在具有较低堆栈级别的盒子的前面（上面）。盒子可能具有负层叠级别。层叠上下文中具有相同堆栈级别的框根据文档树出现的顺序层叠在一起。 根元素形成根层叠上下文，是所有层叠上下文的根层叠上下文。注意，层叠上下文不一定与包含块相关，也就是说并不是每个元素都能形成一个层叠上下文。文档中的层叠上下文由满足以下任意一个条件的元素形成： 根元素 (HTML) z-index 值不为 auto 的 绝对/相对定位 position 值为 fixed|sticky 一个 z-index 值不为 auto 的 flex 项目 (flex item)，即：父元素 display: flex|inline-flex opacity 属性值小于 1 的元素 transform 属性值不为 “none”的元素 mix-blend-mode 属性值不为 normal 的元素 filter | perspective | clip-path |mask / mask-image / mask-border 值不为 none 的元素 perspective 值不为 none 的元素 isolation 属性被设置为 isolate 的元素 在 will-change 中指定了任意 CSS 属性，即便你没有直接指定这些属性的值 -webkit-overflow-scrolling 属性被设置 touch的元素 其中，加粗几条是经常见到和使用的css属性。 层叠上下文的顺序实际上确定页面上所有元素（包括边框，背景，文本节点等）的堆叠顺序是非常复杂的，本文对其进行了一些简化，将不常用和不常出现的内容去掉，更详细顺序的请参考 css规范 Appendix E. Elaborate description of Stacking Contexts 以下是层叠顺序的基本规则（从底层向顶层排列）： 堆叠上下文的根元素 具有负 z-index 值的定位元素（position 不为 static），其中较高 z-index 值的堆叠在较低值的前面，具有相同 z-index 值的元素根据HTML中的出现顺序进行堆叠） 非定位元素（不存在 position 或 position 为 static） 定位元素具有自动的 z-index 值（ z-index 为 auto 或者 为 0） 浮动块元素（指定 float） 定位元素具有正 z-index 值（较高的值堆叠在较低值之前;具有相同值的元素根据HTML中的外观进行堆叠） 层叠位置示例如下： See the Pen Stacking context by tcatche (@tcatche) on CodePen. 如果在某些场合下，为元素指定 z-index 并不生效，这个时候需要查看下是否其上层是否形成了堆栈上下文，如果形成了，那么无论设置多大的数值都不生效： 如下示例，按照预想，red 元素设置了 z-index，应该在 green 元素上面，但是并不起作用： See the Pen Z-index Not work by tcatche (@tcatche) on CodePen. 出现这一个问题的原因在于，示例中指定了每个颜色块的父元素top 元素一个透明度属性 opacity: 0.99; 如果不使用该属性，元素的层级大概以认为如下（注意，这里只是为了说明，并不代表元素的真实层级）： &lt;div class=&quot;top top1&quot;&gt;&lt;!-- top1: 1 --&gt; &lt;span class=&quot;red&quot;&gt;&lt;!-- red：4 --&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;top top2&quot;&gt;&lt;!-- top2: 2 --&gt; &lt;span class=&quot;green&quot;&gt;&lt;!-- 3 --&gt;&lt;span&gt;&lt;/div&gt; 当使用该属性将 top 元素变成了层叠上下文元素，在确定位置的时候首先定位 top1 和 top2，确定 top2 的层级在 top1 之上。而后确定 top1 和 top2 内部元素的层级，而 top1 内的子元素指定的 z-index 仅影响其在 top1 中的层级，并无法改变 top1 在更上的层级，因此不起作用。 此时，可以认为元素的层级大概如下： &lt;div class=&quot;top top1&quot;&gt;&lt;!-- top1: 1 --&gt; &lt;span class=&quot;red&quot;&gt;&lt;!-- red: 1.1 --&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;top top2&quot;&gt;&lt;!-- top2: 2 --&gt; &lt;span class=&quot;green&quot;&gt;&lt;!-- green: 2.1 --&gt;&lt;span&gt;&lt;/div&gt; 参考 Cascading Style Sheets Level 2 Revision 2 (CSS 2.2) Specification Appendix E. Elaborate description of Stacking Contexts Understanding CSS z-index What No One Told You About Z-Index","categories":[{"name":"css","slug":"css","permalink":"http://tcatche.site/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"http://tcatche.site/tags/css/"}]},{"title":"React 内部实现，第五部分：基本更新","slug":"react-internals-part-five-transactions","date":"2017-08-18T03:13:00.000Z","updated":"2018-08-01T10:41:24.000Z","comments":true,"path":"2017/08/react-internals-part-five-transactions/","link":"","permalink":"http://tcatche.site/2017/08/react-internals-part-five-transactions/","excerpt":"","text":"原文：React Internals, Part Five: transactions In this part, we’ll talk about React’s transactions. The series part one: basic rendering part two: componentWillMount and componentDidMount part three: basic updating part four: setState part five: transactions &lt;- you are here 全部译文： 第一部分：基础渲染 第二部分：componentWillMount and componentDidMount 第三部分：基本更新 第四部分：setState 第五部分：事务 &lt;- 当前位置 transactions everywhereAt this point, the little React clone we built, Feact, is complete. You can see the final version of it here. 到了这里，我们所构建的一个小小的 React 克隆 Feact 已经完成。你可以在这里看到它的最终版本。 But if you decide to dive into React’s source, you’ll quickly notice all these “transactions” everywhere. They obscure the intent of the code, and make it harder to get a sense of what is going on. Rest assured, Feact is following React pretty closely (well, React 15.3 at least), but it purposely doesn’t have transactions to make the actual “meat” of the code more apparent. 但是，如果您深入查看 React 的源代码，您将很快注意到所有这些 “transactions ” 到处都有。它们掩盖了代码的意图，使得更难了解发生了什么。放心，Feact跟随React相当紧密（好吧，至少是 React 15.3），但它没有transactions ，使代码的实际“肉”更明显。 what is a transaction?The good news is transactions are simple. They are just a pattern the React team has adopted to make the framework more robust and easier to maintain. 好消息是transactions 很简单。它们只是 React 团队采用的一种模式，使框架更加健壮，更易于维护。 Whenever React decides it needs to do something, that “something” usually needs to do a little bit of prep work before, do its main logic, then some clean up work afterwards. This diagram showing how transactions work is taken straight from the React source code 每当 React 决定需要做某事时，这些“某事”通常需要做一些准备工作，执行主要逻辑，然后再执行一些清理工作。这个图是直接从 React 源代码中获取的，展示了 transactions 是如何工作的。 * wrappers (injected at creation time)* + +* | |* +-----------------|--------|--------------+* | v | |* | +---------------+ | |* | +--| wrapper1 |---|----+ |* | | +---------------+ v | |* | | +-------------+ | |* | | +----| wrapper2 |--------+ |* | | | +-------------+ | | |* | | | | | |* | v v v v | wrapper* | +---+ +---+ +---------+ +---+ +---+ | invariants* perform(anyMethod) | | | | | | | | | | | | maintained* +-----------------&gt;|-|---|-|---|--&gt;|anyMethod|---|---|-|---|-|--------&gt;* | | | | | | | | | | | |* | | | | | | | | | | | |* | | | | | | | | | | | |* | +---+ +---+ +---------+ +---+ +---+ |* | initialize close |* +-----------------------------------------+ If Feact was to add transactions, its (very) simple take would be something like this: 如果 Feact 添加 transactions ，它（非常）简单的实现将是这样的： class Transaction &#123; constructor(wrapper) &#123; this._wrapper = wrapper; &#125; perform(method) &#123; const wrapperValue = this._wrapper.initialize(); method(); this._wrapper.close(wrapperValue); &#125;&#125; 一个 transactions 的用例（A use case for transactions）Why all the fuss? Mostly transactions enable React to do what it needs to do while keeping the browser happy. 为什么大惊小怪？大部分 transactions 确保 React 能够在保持浏览器开放的同时做必要的事情。 For example, consider this dumb little React app, it swaps a button and a text input every 5 seconds 例如，看这个愚蠢的小 React 应用程序，它每5秒交换一个按钮和一个文本输入框的位置： const MyComp = React.createClass(&#123; getInitialState() &#123; return &#123; textFirst: true &#125;; &#125;, componentDidMount() &#123; setInterval(() =&gt; &#123; this.setState(&#123; textFirst: !this.state.textFirst &#125;); &#125;, 5000); &#125;, render() &#123; let children; if (this.state.textFirst) &#123; children = [ &lt;input key=&quot;text&quot; type=&quot;text&quot; /&gt;, &lt;button key=&quot;button&quot; /&gt; ]; &#125; else &#123; children = [ &lt;button key=&quot;button&quot; /&gt;, &lt;input key=&quot;text&quot; type=&quot;text&quot; /&gt; ]; &#125; return ( &lt;div&gt;&#123;children&#125;&lt;/div&gt; ); &#125;&#125;);ReactDOM.render(&lt;MyComp /&gt;, document.body); The trouble with this app is the input element. Whenever you move an input element in the DOM (for example, parentElement.insertBefore(myInputElement, someOtherChild)), the browser clears out its selection. So if the user has highlighted some text in the input, then something about how your app renders causes React to move the input in the DOM, that selection gets cleared, frustrating your user. To solve this problem, React component updates are done in a transaction. During the initialize phase of the transaction, React grabs the current selection state of the browser and stores it. Then in the close phase, it takes that previous value and makes sure it gets restored. The transactions that happen during a React render handle many other things such as maintaining the window’s scroll position, and a lot of other necessary book keeping. Another benefit of the transaction pattern is it becomes easy to store the state of the browser, do a whole bunch of work, then restore the state at the very end, rather than having to continually worry about accidentally scrolling the window or clearing an input selection. 这个应用程序的麻烦是 input 元素。无论何时在DOM中移动输入元素（例如，parentElement.insertBefore(myInputElement, someOtherChild)），浏览器将清除其选择状态。因此，如果用户突出选中了输入的某些文本，那么有关应用程序渲染原因导致在 DOM 中移动输入元素，该选择状态将被清除，从而使您的用户感到沮丧。为了解决这个问题，React 组件更新是在 transaction 中完成的。在 transaction 的初始化阶段，React 抓住浏览器的当前选择状态并将其存储起来。然后在关闭阶段，它需要先前的值，并确保它恢复。在 React 渲染期间发生的 transaction 处理许多其他事情，例如维护窗口的滚动位置，以及许多其他必要的状态。transactions 模式的另一个好处是容易存储浏览器的状态，做一大堆工作，然后在最后恢复状态，而不必担心意外滚动窗口或清除输入选择。 Feact transactionsIf Feact managed selection using transactions, it’d look something like 如果 Feact 使用 transactions 来管理选择状态，那么看起来就像这样： const SELECTION_RESTORATION = &#123; initialize() &#123; const focusedElem = document.activeElement; return &#123; focusedElem, selection: &#123; start: focusedElem.selectionStart, end: focusedElem.selectionEnd &#125; &#125;; &#125;, close(priorSelectionInformation) &#123; const focusedElem = priorSelectionInformation.focusedElem; focusedElem.selectionStart = priorSelectionInformation.selection.start; focusedElem.selectionEnd = priorSelectionInformation.selection.end; &#125;&#125;;const updateTransaction = new Transaction(SELECTION_RESTORATION);FeactReconciler = &#123; ... receiveComponent(internalinstance, nextElement) &#123; updateTransaction.perform(function() &#123; internalInstance.receiveComponent(nextElement); &#125;); &#125; ...&#125; As always with Feact, trying to keep the code as straightforward as possible. This silly little transaction doesn’t even check if the element is capable of having a selection, amongst many other problems. I don’t recommend using Feact in production. 和Feact一样，尽量保持代码尽可能简单。这个愚蠢的小 transactions 甚至没有检查元素是否能够进行选择，以及许多其他问题。我不建议在生产中使用Feact。 Over in React, transactions are more complicated. For starters, they allow more than one wrapper. They also deal with exceptions being thrown, and ensure transactions don’t call back into themselves. 在 React 中，transactions 更复杂。对于初学者，它们允许多个包装。他们还处理抛出的异常，并确保 transaction 不会自动回调。 系列总结（Series Conclusion）And with that, this series has covered the basics of how React works. Whenever you’re debugging your React applications, that large chunk of the call stack that is inside React should feel a little less alien now. That’s a primary reason I decided to write this series out. 与此同时，本系列还介绍了 React 的基本工作原理。无论何时调试您的 React 应用程序，现在应该会感觉到 React 内部的大块调用堆栈有一点了解。这是我决定写这个系列的主要原因。 If you spotted any errors or have any feedkback, feel free to email me.","categories":[{"name":"翻译","slug":"翻译","permalink":"http://tcatche.site/categories/%E7%BF%BB%E8%AF%91/"}],"tags":[{"name":"react","slug":"react","permalink":"http://tcatche.site/tags/react/"},{"name":"翻译","slug":"翻译","permalink":"http://tcatche.site/tags/%E7%BF%BB%E8%AF%91/"}]},{"title":"React 内部原理，第四部分：setState","slug":"react-internals-part-four-setState","date":"2017-07-27T06:12:00.000Z","updated":"2018-08-01T10:41:24.000Z","comments":true,"path":"2017/07/react-internals-part-four-setState/","link":"","permalink":"http://tcatche.site/2017/07/react-internals-part-four-setState/","excerpt":"","text":"原文：React Internals, Part Four: setState In part four of this series we finally add setState to our little React clone. setState is a beast, so grab your favorite beverage and get comfortable! The series part one: basic rendering part two: componentWillMount and componentDidMount part three: basic updating part four: setState &lt;- you are here part five: transactions 全部译文： 第一部分：基础渲染 第二部分：componentWillMount and componentDidMount 第三部分：基本更新 第四部分：setState &lt;- 当前位置 第五部分：事务 为 Feact 添加 State（Adding state to Feact）State and props are very similar in that they are both data and both influence how and when a component renders. The core difference is props come from an outside source, where state is entirely internal to the component. So far Feact only supports props, so before we can implement setState we need to add the notion of state itself to the framework. state 和 props 非常相似，因为它们都是影响组件渲染的时间和方式的数据。核心区别是 props 来自组件外部，而状态完全在组件内部。到目前为止，Feact 只支持 props，所以在我们可以实现 setState 之前，我们需要在框架中添加 state 的概念。 getInitialStateWhen mounting a fresh component, we need to set up its initial state, that’s where this lifecycle method comes in. It’s just called when a component is getting instantiated, so we need to hook into this method in the constructor function that Feact.createClass creates 当挂载新的组件时，我们需要设置它的初始状态，这是生命周期方法开始的地方。当组件被实例化时，它被调用，所以我们需要在 Feact.createClass 创建的构造函数中执行这个方法。 const Feact = &#123; createClass(spec) &#123; function Constructor(props) &#123; this.props = props; // new lines added for state const initialState = this.getInitialState ? this.getInitialState() : null; this.state = initialState; &#125; Constructor.prototype = Object.assign(Constructor.prototype, spec); return Constructor; &#125;&#125; Just like props, we set the state on the instance. 就像 props 一样，我们在实例上设置 state。 Notice if the component does not have getInitialState defined, the initial state will be null? React won’t default initial state to an empty object, so if you want to use state, chances are you need to implement this method and return an object, otherwise your first render will blow up if it tries to do this.state.foo 注意，如果组件没有定义 getInitialState，初始状态将为 null？ React 不会将默认初始状态设置为空对象，所以如果要使用状态，则可能需要实现此方法并返回一个对象，否则，如果尝试执行 this.state.foo，您的第一个渲染将会错误。 Now with getInitialState defined, Feact components can start using this.state whenever they’d like. 现在 getInitialState 已经定义，Feact 组件可以随时开始使用 this.state。 添加一个简单的（Adding a simple setState()）Whenever a component wants to update, it needs to tell Feact “hey, I’d like to render again!”, and this.setState() is the primary way to accomplish that. setState updates this.state, and triggers a render, which will send the component through the lifecycle methods shouldComponentUpdate -&gt; componentWillUpdate -&gt; render -&gt; componentDidUpdate (which Feact doesn’t have, but of course React does). 每当一个组件想要更新，它需要告诉 Feact “嘿，我想再次渲染”，而 this.setState() 是完成这个的主要方式。setState 更新 this.state，并触发一个渲染，它将通过生命周期方法 shouldComponentUpdate -&gt; componentWillUpdate -&gt; render -&gt; componentDidUpdate（该 Feact没有，但是 React 有）发送组件。 在组件上定义 setState（Defining setState on the component）Again we need to tweak Feact.createClass to get setState in place. To do this, we’ll give all classes created this way a prototype, and this prototype will have setState defined 我们需要再次调整 Feact.createClass 来获取 setState。为此，我们将给出所有以这种方式创建的类一个原型，而这个原型上定义了 setState。 function FeactComponent() &#123;&#125;FeactComponent.prototype.setState = function() &#123; // to be implemented later&#125;;function mixSpecIntoComponent(Constructor, spec) &#123; const proto = Constructor.prototype; for (const key in spec) &#123; proto[key] = spec[key]; &#125;&#125;const Feact = &#123; createClass(spec) &#123; function Constructor(props) &#123; this.props = props; // new lines added for state const initialState = this.getInitialState ? this.getInitialState() : null; this.state = initialState; &#125; Constructor.prototype = new FeactComponent(); mixSpecIntoComponent(Constructor, spec); return Constructor; &#125;&#125; Prototypical inheritance in action. mixSpecIntoComponent in React is more complicated (and robust), dealing with things like mixins and making sure users don’t accidentally clobber a React method. 原型继承在起作用。mixSpecIntoComponent 在 React 中更复杂（强大），处理像 mixins 这样的事情，确保用户不会意外地破坏 React 方法。 将 setState 绑定到 updateComponent（Threading setState over to updateComponent）Back in part three we updated a component by calling FeactCompositeComponentWrapper#receiveComponent, which in turn called updateComponent. It makes sense to not repeat ourselves, so we should thread state updates through updateComponent too. We need to get all the way from FeactComponent.prototype.setState to FeactCompositeComponentWrapper#updateComponent. Currently Feact has no means of accomplishing this. 回到第三部分，我们通过调用 FeactCompositeComponentWrapper#receiveComponent 来更新一个组件，它又反过来调用 updateComponent。没必要再重复一遍，所以我们也应该通过 updateComponent 进行状态更新。我们需要从 FeactComponent.prototype.setState 到FeactCompositeComponentWrapper#updateComponent。目前，无法 Feact 完成这项工作。 In React, there is the notion of “public instances” and “internal instances”. Public instances are the objects that get created from the classes defined with createClass, and internal instances are the objects that React internally creates. In this scenario the internal instance is the FeactCompositeComponentWrapper that the framework created. The internal instance knows about the public instance, since it wraps it. But the relationship doesn’t go in the opposite direction, yet now it needs to. Here setState is the public instance attempting to communicate with the internal instance, so with that in mind, let’s take a stab at implementing setState 在 React 中，存在“公共实例”和“内部实例”的概念。公共实例是从使用 createClass 定义的类创建的对象，内部实例是 React 内部创建的对象。在这种情况下，内部实例是框架创建的 FeactCompositeComponentWrapper 。内部实例知道公共实例，因为它包装的公共实例。但是，这种关系是单向的，现在需要双向的关系，也就是说我们需要公共示例知道内部示例。这里的 setState 是尝试与内部实例进行通信的公共实例，所以考虑到这一点，我们来强制实现 setState function FeactComponent() &#123;&#125;FeactComponent.prototype.setState = function(partialState) &#123; const internalInstance = getMyInternalInstancePlease(this); internalInstance._pendingPartialState = partialState; FeactReconciler.performUpdateIfNecessary(internalInstance);&#125; React solves the “get my internal instance” problem with an instance map, which really just stores the internal instance on the public instance React使用实例映射解决了“获取我的内部实例”的问题，它实际上只是将内部实例存储在公共实例上。 const FeactInstanceMap = &#123; set(key, value) &#123; key.__feactInternalInstance = value; &#125;, get(key) &#123; return key.__feactInternalInstance; &#125;&#125;; We’ll set up this relationship while mounting 我们将在组件挂载时建立这种关系。 class FeactCompositeComponentWrapper &#123; ... mountComponent(container) &#123; const Component = this._currentElement.type; const componentInstance = new Component(this._currentElement.props); this._instance = componentInstance; FeactInstanceMap.set(componentInstance, this); ... &#125;&#125; We have one other unimplemented method, FeactReconciler.performUpdateIfNecessary, but just like other reconciler methods, it will just delegate to the instance 我们有一个其他未实现的方法，FeactReconciler.performUpdateIfNecessary，但是像其他 reconciler 方法一样，它将只是委托给实例。 const FeactReconciler = &#123; ... performUpdateIfNecessary(internalInstance) &#123; internalInstance.performUpdateIfNecessary(); &#125; ...&#125;class FeactCompositeComponentWrapper &#123; ... performUpdateIfNecessary() &#123; this.updateComponent(this._currentElement, this._currentElement); &#125; ...&#125; Finally, we are calling updateComponent! Notice we seem to be cheating a little bit. We are saying to update the component, but with the same element being used as both previous and next. Whenever updateComponent is called with the same element, then React knows only state is getting updated, otherwise props are updating. React will decide whether to call componentWillReceiveProps based on prevElement !== nextElement, so let’s go ahead and throw that into Feact too 最后我们调用 updateComponent ！请注意，我们似乎在隐瞒了一点。我们说要更新组件，但是使用相同的元素作为上一个和下一个更新的组件。每当使用相同的元素调用 updateComponent 时，React 只知道 state 正在更新，否则 props 正在更新。 React 会决定是否根据 prevElement !== nextElement 调用 componentWillReceiveProps，所以让我们继续把它转换成 Feact class FeactCompositeComponentWrapper &#123; ... updateComponent(prevElement, nextElement) &#123; const nextProps = nextElement.props; const inst = this._instance; const willReceive = prevElement !== nextElement; if (willReceive &amp;&amp; inst.componentWillReceiveProps) &#123; inst.componentWillReceiveProps(nextProps); &#125; ... &#125;&#125; That isn’t the entirety of updateComponent, (check the fiddle at the end of the article for all the code), just enough to show that calling setState() does not cause componentWillReceiveProps to get called before the render happens. Which does make sense, setState has no means of influencing props, just state. 这并不是完整的 updateComponent （在文章底部的 fiddle 获得所有代码），但足以显示调用 setState() 不会导致 componentWillReceiveProps 在渲染发生之前被调用。这是有道理的， setState 没有办法影响 props，只是影响 state。 If you want a heads up on every render, whether caused by prop changes or state changes, then implement componentWillUpdate in your component. We won’t add it to Feact since this blog series is already too long, but it’s called right before a render, no matter what caused the render. The only exception is the first render, where you can hook into componentWillMount instead. 如果您想考虑每个渲染上是否发生，无论是由 props 更改或 state 更改引起的，请在组件中实现 componentWillUpdate。我们不会将它添加到 Feact中，因为这个博客系列已经太长了，但是无论什么导致了渲染，它都将在渲染之前就被调用。唯一的例外是第一次渲染，但这种情况下您也可以在 componentWillMount钩子中执行一些操作。 用新的 state 更新（Updating with the new state）If you trace through the code we’ve written so far, you’ll see we’re now hanging out in updateComponent, and the internal instance has the pending partial state waiting to be used at internalInstance._pendingPartialState. Now all we need to do is have the component render again – this time with state –, then from there actually getting the update all the way into the DOM is the same procedure as done back in part three 如果您浏览到目前为止写的代码，您将看到我们现在在 updateComponent 中进行操作，并且在内部实例有等待在 internalInstance._pendingPartialState 中使用的部分状态。现在我们需要做的是使组件再次渲染，这次与状态有关，然后实际更新到 DOM 的方式是完全和第三部分中相同的过程。 class FeactCompositeComponentWrapper &#123; ... updateComponent(prevElement, nextElement) &#123; const nextProps = nextElement.props; const inst = this._instance; const willReceive = prevElement !== nextElement; if (willReceive &amp;&amp; inst.componentWillReceiveProps) &#123; inst.componentWillReceiveProps(nextProps); &#125; let shouldUpdate = true; const nextState = Object.assign(&#123;&#125;, inst.state, this._pendingPartialState); this._pendingPartialState = null; if (inst.shouldComponentUpdate) &#123; shouldUpdate = inst.shouldComponentUpdate(nextProps, nextState); &#125; if (shouldUpdate) &#123; this._performComponentUpdate( nextElement, nextProps, nextState ); &#125; else &#123; inst.props = nextProps; inst.state = nextState; &#125; &#125; _performComponentUpdate(nextElement, nextProps, nextState) &#123; this._currentElement = nextElement; const inst = this._instance; inst.props = nextProps; inst.state = nextState; this._updateRenderedComponent(); &#125; _updateRenderedComponent() &#123; const prevComponentInstance = this._renderedComponent; const inst = this._instance; const nextRenderedElement = inst.render(); FeactReconciler.receiveComponent( prevComponentInstance, nextRenderedElement ); &#125; ...&#125; This updating of the component is almost identical to part three, with the exception of the added state of course. Since state just sits on the public instance at this.state, _performComponentUpdate only had a one line change and _updateRenderedComponent had no change at all. The real key change was in the middle of updateComponent where we merge the previous state with the new partial state, and this partial state originated way back in this.setState(). 组件的更新几乎与第三部分相同，当然,除了新添加的 state。由于 state 只是在公共实例的 this.state 上，_performComponentUpdate 只有一行更改，而 _updateRenderedComponent 根本没有改变。真正的关键变化是在 updateComponent，我们将先前的 state 与新的局部 state 来自 this.setState() 的 state 进行合并。 全做完了！ 全做完了！ … 对吗？（All done! … right?）Phew, we now have setState! Here is a fiddle of what we have so far 现在我们已经有了 setState ，这里是迄今为止的完整代码： fiddle But Feact’s setState is a bit simple, not performant and could even be a little surprising. The main problem is every distinct call to setState causes the component to render. This forces the user to either figure out how to fit all their changes into one call, or accept that each call will render. It’d be better if the programmer could call setState when it’s convenient, and let the framework batch the calls when it can, resulting in fewer renders. 但是，Feact 的 setState 有点简单，没有性能，甚至有点令人惊讶。主要的问题是每个不同的调用 setState 导致组件呈现。这将迫使用户确定如何将其所有更改合并为一次调用，或接受每次调用都将渲染。如果程序员可以在方便的时候调用 setState，那么这个框架会更好，让框架在调用时可以批量调用，从而产生更少的渲染。 批处理 setState 调用（Batching setState calls）If you take a look at Feact’s render lifecycle, you can see we call componentWillReceiveProps just before we’re about to render. What if inside componentWillReceiveProps the user was to call setState? Currently in Feact, that’d cause it to go ahead and start a second render, while in the middle of the first render! That doesn’t sound good. Not to mention, responding to incoming props by updating your state is a common need. It makes sense to expect your state update and the new props to all flow into the same render, otherwise you’d get an intermediate render with only the state change, then the final render with both state and props change, which would probably be unexpected. 如果您看看 Feact 的渲染生命周期，可以看到我们在渲染之前调用 componentWillReceiveProps。如果用户在 componentWillReceiveProps 内部要调用 setState 怎么办？目前在 Feact 中，这将导致它继续执行，并在第一个渲染的中间开始第二个渲染！这听起来不好，更不要说，通过响应传入的 state 来更新 props 是一个常见的需求。期望你的 state 更新和新的 props 流入同一渲染是有道理的，否则你会得到只有 state 改变的中间渲染，然后 state 和 props 同时改变的最终渲染，可能是不可预期的。 Here is a fiddle that demonstrates this (fiddle). Depending on your browser, you might not be able to see the second render. But if you open the debugger and place a debugger; statement in FeactDOMComponent#_updateTextContent, you should be able to see how Feact naively does three renders when it should have been just two. 这是一个 fiddle 的演示（fiddle ）。根据您的浏览器，您可能无法看到第二次渲染。但是如果您打开调试器并放置断点在 FeactDOMComponent#_updateTextContent 中，您应该能够看到三次呈现，Feact 如何天真地做了三次渲染，而本应该只是两次渲染的。 批量步骤一，存放批量状态变化的地方（batching step one, a place to store the batched state changes）We need a place to store more than one state update, so we will change _pendingPartialState into an array 我们需要一个存储多个状态更新的地方，所以我们将 _pendingPartialState 更改为一个数组。 function FeactComponent() &#123;&#125;FeactComponent.prototype.setState = function(partialState) &#123; const internalInstance = FeactInstanceMap.get(this); internalInstance._pendingPartialState = internalInstance._pendingPartialState || []; internalInstance._pendingPartialState.push(partialState); ...&#125; Over in updateComponent, let’s pull the state processing out into its own method 在 updateComponent 中，我们将状态处理拉出到自己的方法中。 class FeactCompositeComponentWrapper &#123; ... updateComponent(prevElement, nextElement) &#123; ... const nextState = this._processPendingState(); ... &#125; _processPendingState() &#123; const inst = this._instance; if (!this._pendingPartialState) &#123; return inst.state; &#125; let nextState = inst.state; for (let i = 0; i &lt; this._pendingPartialState.length; ++i) &#123; nextState = Object.assign(nextState, this._pendingPartialState[i]); &#125; this._pendingPartialState = null; return nextState; &#125;&#125; 批量步骤二，将状态更改合为一个渲染（batching step two, batching up the state changes into one render） The batching mechanism we’re about to add to Feact is very simple and not at all what React does. The point is to just show the general idea of how batching works (and later, show why it can make setState tricky). 我们即将添加到“快乐”中的配料机制非常简单，而且还没有反应。关键是要显示批处理如何工作的一般想法（后来，显示为什么它可以使setState变得棘手）。 For Feact, we will batch updates while rendering, otherwise, we won’t batch them. So during updateComponent, we just set a flag that tells the world we are rendering, then unset it at the end. If setState sees we are rendering, it will set the pending state, but not cause a new render, as it knows the current render that is going on will pick up this state change 对于 Feact，我们将在渲染时批量更新，否则我们不会批量更新。所以在 updateComponent 期间，我们只是设置一个标志告诉世界我们正在渲染，然后在渲染的最后取消设置。如果 setState 看到我们正在渲染，它将设置待处理状态，但不会导致新的渲染，因为它知道当前正在执行的渲染将会接收到该状态更改。 class FeactCompositeComponentWrapper &#123; ... updateComponent(prevElement, nextElement) &#123; this._rendering = true; // entire rest of the method this._rendering = false; &#125;&#125;function FeactComponent() &#123;&#125;FeactComponent.prototype.setState = function(partialState) &#123; const internalInstance = FeactInstanceMap.get(this); internalInstance._pendingPartialState = internalInstance._pendingPartialState || []; internalInstance.push(partialState); if (!internalInstance._rendering) &#123; FeactReconciler.performUpdateIfNecessary(internalInstance); &#125;&#125; 包装起来（wrapping it up）Here is a fiddle that contains the final version of Feact： 这是一个包含最终版本的 Feact 的 fiddle： fiddle It contains the simple batching, so it will only render twice (whereas the previous fiddle above rendered three times). 它包含简单的批处理，所以它只会渲染两次（而上一个 fiddle 渲染三次）。 setState 陷阱（setState pitfalls）Now that we understand how setState works and the overall concept on how batching works, we can see there are some pitfalls in setState. The problem is it takes several steps to update a component’s state, as each pending partial state needs to get applied one by one. That means using this.state when setting state is dangerous 现在我们了解了 setState 的工作原理以及批处理如何工作的总体概念，我们可以看到 setState 有一些陷阱。问题是需要几个步骤更新组件的状态，因为每个待处理的部分状态需要逐个应用。这意味着在设置状态的时候使用 this.state 是很危险的。 componentWillReceiveProps(nextProps) &#123; this.setState(&#123; counter: this.state.counter + 1 &#125;); this.setState(&#123; counter: this.state.counter + 1 &#125;);&#125; This contrived example shows what I mean. You might expect counter to get 2 added to it, but since states are being batched up, the second call to setState has the same values for this.state as the first call, so counter will only get incremented once. React solves this problem by allowing a callback to be passed into setState 这个例子显示了我的意思。您可能希望计数器可以添加2，但是由于状态正在被批量化，所以第二次调用 this.state this.state 的值与第一次调用 this.state 的值相同，所以计数器只会增加一次。 React 通过允许将回调函数传递给 this.state 来解决这个问题 componentWillReceiveProps(nextProps) &#123; this.setState((currentState) =&gt; (&#123; counter: currentState.counter + 1 &#125;); this.setState((currentState) =&gt; (&#123; counter: currentState.counter + 1 &#125;);&#125; By using the callback flavor of setState, you get access to the intermediate values state works through. If Feact were to implement this, it’d look like 通过使用 setState 的回调函数，您可以访问工作中的 state 值。如果 Feact 要实现这一点，看起来就像： _processPendingState() &#123; const inst = this._instance; if (!this._pendingPartialState) &#123; return inst.state; &#125; let nextState = inst.state; for (let i = 0; i &lt; this._pendingPartialState.length; ++i) &#123; const partialState = this._pendingPartialState[i]; if (typeof partialState === &#x27;function&#x27;) &#123; nextState = partialState(nextState); &#125; else &#123; nextState = Object.assign(nextState, patialState); &#125; &#125; this._pendingPartialState = null; return nextState;&#125; You can see how the callback gets access to the intermediate values of nextState as we work our way through all the pending changes. 你可以看到回调函数如何访问 nextState 的中间值，当我们我们正在等待完成所有待处理的更改。 下一步（Up Next）If you’ve read this far then holy cow, thanks! Feel free to email me if you have any feedback. Part five is just around the corner. It will go over React’s transactions and wrap the whole shebang up. Stay tuned. Here is the final fiddle for Feact one more time: fiddle","categories":[{"name":"翻译","slug":"翻译","permalink":"http://tcatche.site/categories/%E7%BF%BB%E8%AF%91/"}],"tags":[{"name":"react","slug":"react","permalink":"http://tcatche.site/tags/react/"},{"name":"翻译","slug":"翻译","permalink":"http://tcatche.site/tags/%E7%BF%BB%E8%AF%91/"}]},{"title":"React 内部原理，第三部分：基本更新","slug":"react-internals-part-three-basic-updating","date":"2017-07-26T07:32:00.000Z","updated":"2018-10-18T12:15:30.000Z","comments":true,"path":"2017/07/react-internals-part-three-basic-updating/","link":"","permalink":"http://tcatche.site/2017/07/react-internals-part-three-basic-updating/","excerpt":"","text":"原文：React Internals, Part Three: basic updating In part one, our small React clone, Feact, was implemented far enough to do basic rendering. But once the render happens, that was it. In this part, we’ll add the ability to make changes to the app with subsequent renders. This part will begin to show how the virtual DOM diffing works. 在第一部分，我们的小型 React 克隆（Feact）被实现的足以进行基本的渲染。在这部分中，我们将添加后续渲染对应用进行更改的功能。这部分将开始展示虚拟 DOM diffing 过程的工作原理。 The series part one: basic rendering part two: componentWillMount and componentDidMount part three: basic updating &lt;- you are here part four: setState part five: transactions coming soon! 全部译文： 第一部分：基础渲染 第二部分：componentWillMount and componentDidMount 第三部分：基本更新 &lt;- 当前位置 第四部分：setState 第五部分：事务 简单更新（Simple updating）Calling setState() in a component is the primary way people cause their React apps to update. But React also supports updating through React.render(). Take this contrived example 在组件中调用 setState() 是人们更新其 React 应用程序的主要方式。但是 React 还支持通过 React.render() 进行更新。看这个例子： React.render(&lt;h1&gt;hello&lt;/h1&gt;, root);setTimeout(function() &#123; React.render(&lt;h1&gt;hello again&lt;/h1&gt;, root);&#125;, 2000); We’ll ignore setState() for now (that’s coming in part four) and instead implement updates through Feact.render(). Truth be told, this is simply “props have changed so update”, which also happens if you render again and pass different props down to a child component. We just happen to be causing the props change through Feact.render(). 我们现在将忽略 setState()（这是第四部分），而是通过 Feact.render() 实现更新。说实话，这只是简单的 “props 改变了，所以需要更新”，如果再次渲染并将不同的 props 传递给一个子组件，这也会发生。我们这里是通过 Feact.render() 导致 props 改变。 执行更新（Doing the update）The concept is pretty simple, Feact.render() just needs to check if it has rendered before, and if so, update the page instead of starting fresh. 这个概念很简单，Feact.render() 只需要检查它之前是否已经呈现，如果是这样，更新页面而不是开始创建。 const Feact = &#123; ... render(element, container) &#123; const prevComponent = getTopLevelComponentInContainer(container); if (prevComponent) &#123; return updateRootComponent( prevComponent, element ); &#125; else &#123; return renderNewRootComponent(element, container); &#125; &#125; ...&#125;function renderNewRootComponent(element, container) &#123; const wrapperElement = Feact.createElement(TopLevelWrapper, element); const componentInstance = new FeactCompositeComponentWrapper(wrapperElement); return FeactReconciler.mountComponent( componentInstance, container );&#125;function getTopLevelComponentInContainer(container) &#123; // need to figure this out&#125;function updateRootComponent(prevComponent, nextElement) &#123; // need to figure this out too&#125; This is looking pretty promising. If we rendered before, then take the state of the previous render, grab the new desired state, and pass that off to a function that will figure out what DOM updates need to happen to update the app. Otherwise if there’s no signs of a previous render, then render into the DOM exactly how we did in part one and two. We just need to figure out the two missing pieces. 这看起来很有保障。如果我们以前渲染过，然后采取先前渲染的状态，抓住新的需要状态，并将其传递给一个函数，由其确定哪些 DOM 需要更新并进行更新。否则，如果没有之前已经渲染的迹象，那么将其渲染到 DOM 中，就像我们在第一部分和第二部分中所做的那样。 我们只需要弄清楚两个缺失的部分。 记住我们已经做过的（Remembering what we did）For each render, We need to store the components we created, so we can refer to them in a subsequent render. Where to store them? Why not on the DOM nodes they create? 对于每次渲染，我们需要存储我们创建的组件，以便我们可以在之后的渲染中引用它们。那么，在哪里存储它们？为什么不在他们创建的DOM节点上？ function renderNewRootComponent(element, container) &#123; const wrapperElement = Feact.createElement(TopLevelWrapper, element); const componentInstance = new FeactCompositeComponentWrapper(wrapperElement); const markUp = FeactReconciler.mountComponent( componentInstance, container ); // new line here, store the component instance on the container // we want its _renderedComponent because componentInstance is just // the TopLevelWrapper, which we don&#x27;t need for updates container.__feactComponentInstance = componentInstance._renderedComponent; return markUp;&#125; Well, that was easy. Similarly retrieving the stashed component is easy too: 这很容易，类似地，找到我们隐藏的组件也很容易： function getTopLevelComponentInContainer(container) &#123; return container.__feactComponentInstance;&#125; 更新到新的状态（Updating to the new state）This is the simple example we are working through 这是我们使用的简单例子： Feact.render( Feact.createElement(&#x27;h1&#x27;, null, &#x27;hello&#x27;), root);setTimeout(function() &#123; Feact.render( Feact.createElement(&#x27;h1&#x27;, null, &#x27;hello again&#x27;), root );&#125;, 2000); 2 seconds has elapsed, so we are now calling Feact.render() again, but this time with an element that looks like 2秒过去了，我们现在再次调用 Feact.render()，但是这时候看起来像是一个元素 &#123; type: &#x27;h1&#x27;, props: &#123; children: &#x27;hello again&#x27; &#125;&#125; Since Feact determined this is an update, we ended up in updateRootComponent, which is just going to delegate to the component 由于 Feact 确定这是一个更新，我们最终在 updateRootComponent 中将元素委派给组件： function updateRootComponent(prevComponent, nextElement) &#123; prevComponent.receiveComponent(nextElement)&#125; Notice a new component is not getting created. prevComponent is the component that got created during the first render, and now it’s going to take a new element and update itself with it. Components get created once at mount, and live on until unmount (which, does make sense…) 注意没有创建一个新组件。prevComponent 是在第一次渲染过程中创建的组件，现在它将使用一个新元素并更新它自身。组件在挂载时创建一次，直到卸载（这是有意义的） class FeactDOMComponent &#123; ... receiveComponent(nextElement) &#123; const prevElement = this._currentElement; this.updateComponent(prevElement, nextElement); &#125; updateComponent(prevElement, nextElement) &#123; const lastProps = prevElement.props; const nextProps = nextElement.props; this._updateDOMProperties(lastProps, nextProps); this._updateDOMChildren(lastProps, nextProps); this._currentElement = nextElement; &#125; _updateDOMProperties(lastProps, nextProps) &#123; // nothing to do! I&#x27;ll explain why below &#125; _updateDOMChildren(lastProps, nextProps) &#123; // finally, the component can update the DOM here // we&#x27;ll implement this next &#125;&#125;; receiveComponent just sets up updateComponent, which ultimately calls _updateDOMProperties and _updateDOMChildren which are the meaty functions which will finally cause the actual DOM to get updated. _updateDOMProperties is mostly concerned with updating CSS styles. We’re not going to implement it in this blog post series, but just pointing it out as that is the method React uses to deal with style changes. receiveComponent 只是设置 updateComponent ，它最终调用 _updateDOMProperties 和 _updateDOMChildren，它们是最终导致实际DOM更新的实体函数。_updateDOMProperties 主要关心更新 CSS 样式。我们不会在这个博客文章系列中实现它，只是指出它是 React 用于处理样式更改的方法。 _updateDOMChildren in React this method is pretty complex, handling a lot of different scenarios. But in Feact the children is just the text contents of the DOM element, in this case the children will go from &quot;hello&quot; to &quot;hello again&quot; 在 React中 _updateDOMChildren 这个方法很复杂，处理了很多不同的场景。但在 Feact 中，子元素只是 DOM 元素的文本内容，在这种情况下，子元素将从 &quot;hello&quot; 变成 &quot;hello again&quot;。 class FeactDOMComponent &#123; ... _updateDOMChildren(lastProps, nextProps) &#123; const lastContent = lastProps.children; const nextContent = nextProps.children; if (!nextContent) &#123; this.updateTextContent(&#x27;&#x27;); &#125; else if (lastContent !== nextContent) &#123; this.updateTextContent(&#x27;&#x27; + nextContent); &#125; &#125; updateTextContent(text) &#123; const node = this._hostNode; const firstChild = node.firstChild; if (firstChild &amp;&amp; firstChild === node.lastChild &amp;&amp; firstChild.nodeType === 3) &#123; firstChild.nodeValue = text; return; &#125; node.textContent = text; &#125;&#125;; Feact‘s version of _updateDOMChildren is hopelessly stupid, but this is all we need for our learning purposes. Feact 的版本的 _updateDOMChildren 是非常愚蠢的，但它对于我们的学习目标很有帮助。 更新复合组件（Updating composite components）The work we did above was fine and all, but we can only update FeactDOMComponents. In other words, this won’t work 我们上面所做的已经很好，但是只能更新 FeactDOMComponent，也就是说，还不能工作在如下场景： Feact.render( Feact.createElement(MyCoolComponent, &#123; myProp: &#x27;hello&#x27; &#125;), document.getElementById(&#x27;root&#x27;));setTimeout(function() &#123; Feact.render( Feact.createElement(MyCoolComponent, &#123; myProp: &#x27;hello again&#x27; &#125;), document.getElementById(&#x27;root&#x27;) );&#125;, 2000); Updating composite components is much more interesting and where a lot of the power in React lies. The good news is, a composite component will ultimately boil down to a FeactDOMComponent, so all the work we did above won’t go to waste. 更新复合组件非常有趣，而这是 React 的大部分工作。好消息是，复合组件最终将归结为 FeactDOMComponent，所以我们上面所做的工作不会浪费。 Even more good news, updateRootComponent has no idea what kind of component it received. It just blindly calls receiveComponent on it. So all we need to do is add receiveComponent to FeactCompositeComponentWrapper and we’re good! 更好的消息是，updateRootComponent 不知道接收到什么样的组件。它只是盲目地调用 receiveComponent。所以我们需要做的是将 receiveComponent 添加到 FeactCompositeComponentWrapper，这很容易！ class FeactCompositeComponentWrapper &#123; ... receiveComponent(nextElement) &#123; const prevElement = this._currentElement; this.updateComponent(prevElement, nextElement); &#125; updateComponent(prevElement, nextElement) &#123; const nextProps = nextElement.props; this._performComponentUpdate(nextElement, nextProps); &#125; _performComponentUpdate(nextElement, nextProps) &#123; this._currentElement = nextElement; const inst = this._instance; inst.props = nextProps; this._updateRenderedComponent(); &#125; _updateRenderedComponent() &#123; const prevComponentInstance = this._renderedComponent; const inst = this._instance; const nextRenderedElement = inst.render(); prevComponentInstance.receiveComponent(nextRenderedElement); &#125;&#125; It’s a little silly to spread such little logic across four methods, but it will make more sense as we progress. These four methods are also what is found in React’s ReactCompositeComponentWrapper. 在这四种方法中传递这样的小逻辑看起来有点愚蠢，但将因为我们的进展变得很有意义。这四种方法也可以在 React 的 ReactCompositeComponentWrapper 中找到。 Ultimately the update boils down to calling render with the current set of props. Take the resulting element and passing it on to the _renderedComponent, and telling it to update. _renderedComponent could be another FeactCompositeComponentWrapper, or possibly a FeactDOMComponent. It was created during the first render. 最终，调用 render 更新归结为使用当前的 props 来渲染，取得结果元素并将其传递给 _renderedComponent ，通知它进行更新。 _renderedComponent 可以是 FeactCompositeComponentWrapper，或者可能是 FeactDOMComponent。它是第一次渲染过程中创建的。 让我们再次使用 FeactReconciler（Let’s use FeactReconciler again）Mounting components always goes through FeactReconciler, so updating them should to. This isn’t that important for Feact, but it keeps us consistent with React. 安装组件总是通过 FeactReconciler，因此也应该更新它们。这对于 Feact 并不重要，但可以与 React 保持一致。 const FeactReconciler = &#123; ... receiveComponent(internalInstance, nextElement) &#123; internalInstance.receiveComponent(nextElement); &#125;&#125;;function updateRootComponent(prevComponent, nextElement) &#123; FeactReconciler.receiveComponent(prevComponent, nextElement);&#125;class FeactCompositeComponentWrapper &#123; ... _updateRenderedComponent() &#123; const prevComponentInstance = this._renderedComponent; const inst = this._instance; const nextRenderedElement = inst.render(); FeactReconciler.receiveComponent( prevComponentInstance, nextRenderedElement); &#125;&#125; shouldComponentUpdate和componentWillReceiveProps(shouldComponentUpdate and componentWillReceiveProps)We can now easily add these two lifecycle methods into Feact. 我们现在可以轻松地将这两种生命周期方法添加到 Feact 中。 class FeactCompositeComponentWrapper &#123; ... updateComponent(prevElement, nextElement) &#123; const nextProps = nextElement.props; const inst = this._instance; if (inst.componentWillReceiveProps) &#123; inst.componentWillReceiveProps(nextProps); &#125; let shouldUpdate = true; if (inst.shouldComponentUpdate) &#123; shouldUpdate = inst.shouldComponentUpdate(nextProps); &#125; if (shouldUpdate) &#123; this._performComponentUpdate(nextElement, nextProps); &#125; else &#123; // if skipping the update, // still need to set the latest props inst.props = nextProps; &#125; &#125; ...&#125; A Major HoleThere’s a big problem with Feact’s updating that we won’t be addressing. It’s making the assumption that when the update happens, it can keep using the same type of component. In other words, Feact can handle this just fine Feact 的更新有一个很大的问题，我们没有指出。这些都是建立在，当更新发生时，它仍然继续使用相同类型的组件的假设上的。 换句话说，Feact 可以很好的处理这个问题： Feact.render( Feact.createElement(MyCoolComponent, &#123; myProp: &#x27;hi&#x27; &#125;), root);// some time passesFeact.render( Feact.createElement(MyCoolComponent, &#123; myProp: &#x27;hi again&#x27; &#125;), root); but it can’t handle this 但是，它无法处理这样的问题： Feact.render( Feact.createElement(MyCoolComponent, &#123; myProp: &#x27;hi&#x27; &#125;), root);// some time passesFeact.render( Feact.createElement(SomeOtherComponent, &#123; someOtherProp: &#x27;hmmm&#x27; &#125;), root); In this case, the update swapped in a completely different component class. Feact will just naively grab the previous component, which would be a MyCoolComponent, and tell it to update with the new props &#123; someOtherProp: &#39;hmmm&#39;&#125;. What it should have done is notice the component type changed, and instead of updating, unmounted MyCoolComponent and mounted SomeOtherComponent. 在这种情况下，更新被交给一个完全不同的组件类中。 Feact 只是简单地抓住以前的组件，比如这是 MyCoolComponent，使用新的 props &#123; someOtherProp: &#39;hmmm&#39;&#125; 告诉它去更新。它还应该做的是注意组件类型已更改，卸载旧的 MyCoolComponent 并挂载了 SomeOtherComponent，而不是更新 MyCoolComponent 组件。 In order to do this, Feact would need: some ability to unmount a component notice the type change and head over to FeactReconciler.mountComponent instead of FeactComponent.receiveComponent 为了做到这一点，Feact将需要： 卸载组件的能力 注意到组件类型更改，并跳转到 FeactReconciler.mountComponent 而不是 FeactComponent.receiveComponent In React, if you render again with the same component type, it will get updated. You don’t actually need to specify a key for your element to update in most cases. Keys are only necessary when a component is dealing with a collection of children. In this case, React will warn you if you forget your keys. It’s best to heed the warning, because without the key React is not updating, but completely unmounting and mounting again! 在React中，如果使用相同的组件类型再次渲染，则会被更新。在大多数情况下，您实际上不需要指定要更新的元素的 key。只有当组件处理子元素集合时才需要key。在这种情况下，如果您忘记了 key，React 会警告您。最好注意警告，因为没有 key 的 React 将不会更新，而是完全卸载和重新挂载！ 你发现了虚拟 DOM 吗？（Did you spot the virtual DOM?）When React first came out, a lot of the hype was around the “virtual DOM”. But the virtual DOM isn’t really a concrete thing. It is more a concept that all of React (and Feact) accomplish together. There isn’t anything inside React called VirtualDOM or anything like that. Instead prevElement and nextElement together capture the diff from render to render, and FeactDOMComponent applies the diff into the actual DOM. 当 React 第一次出现时，大量的炒作都围绕着“虚拟DOM”。但虚拟 DOM 并不是一个具体的内容，它更像所有的 React（和 Feact 等类似框架）完成其内容的一个概念。React 里面没有任何内容叫做 VirtualDOM 或类似这样的东西。相反，prevElement 和 nextElement 一起捕获两次渲染的差异，FeactDOMComponent 将差异应用于实际的DOM。 总结（Conclusion）And with that, Feact is able to update components, albeit only through Feact.render(). That’s not too practical, but we’ll improve things next time when we explore setState(). 现在，Feact 可以更新组件，尽管只能通过 Feact.render() 更新。这并不太实用，但是下一次我们探索 setState() 时，会改进。 To wrap things up, here is a fiddle encompassing all that we’ve done so far 这里是一个 fiddle 在线示例，包括我们迄今所实现的内容： fiddle On to part four!","categories":[{"name":"翻译","slug":"翻译","permalink":"http://tcatche.site/categories/%E7%BF%BB%E8%AF%91/"}],"tags":[{"name":"react","slug":"react","permalink":"http://tcatche.site/tags/react/"},{"name":"翻译","slug":"翻译","permalink":"http://tcatche.site/tags/%E7%BF%BB%E8%AF%91/"}]},{"title":"React 内部原理，第二部分：添加 componentWillMount 和 componentDidMount","slug":"react-internals-part-two-componentWillMount-and-componentDidMount","date":"2017-07-25T08:18:00.000Z","updated":"2018-08-01T10:41:24.000Z","comments":true,"path":"2017/07/react-internals-part-two-componentWillMount-and-componentDidMount/","link":"","permalink":"http://tcatche.site/2017/07/react-internals-part-two-componentWillMount-and-componentDidMount/","excerpt":"","text":"原文：React Internals, Part Two: componentWillMount and componentDidMount In part one we established basic rendering in Feact. That touched upon the most important lifecycle method, render, and now we’re going to add in componentWillMount and componentDidMount support to Feact. 在part one ，我们在 Feact 中建立了基本渲染。这涉及到最重要的生命周期方法，渲染（render），现在我们将在 Feact 添加 componentWillMount 和 componentDidMount 的支持。 The series part one: basic rendering part two: componentWillMount and componentDidMount &lt;- you are here part three: basic updating part four: setState part five: transactions 全部译文： 第一部分：基础渲染 第二部分：componentWillMount and componentDidMount &lt;- 当前位置 第三部分：基本更新 第四部分：setState 第五部分：事务 首先，修复 createClass（First, fix createClass）createClass back in part one only supported render createClass 在第一部分中仅支持 render 方法： const Feact = &#123; createClass(spec) &#123; function Constructor(props) &#123; this.props = props; &#125; // we pluck render off and ignore the rest of spec Constructor.prototype.render = spec.render; return Constructor; &#125; ...&#125; This is a simple fix, let’s add the entire spec to the component’s prototype. That allows methods like componentWillMount, but it also allows any arbitrary methods the user defined to be used. 这是一个简单的修复，我们将整个规范的接口添加到组件的原型。这将允许使用如 componentWillMount 的方法，但它也允许使用用户定义的任意方法。 const Feact = &#123; createClass(spec) &#123; function Constructor(props) &#123; this.props = props; &#125; Constructor.prototype = Object.assign(Constructor.prototype, spec); return Constructor; &#125; ...&#125; 解决 mountComponent 的快捷方式（Addressing mountComponent’s shortcut）Back in part one, I noted that FeactCompositeComponentWrapper#mountComponent had taken a shortcut. This shortcut will prevent lifecycle methods such as componentWillMount from getting called. 回到第一部分，注意到 FeactCompositeComponentWrapper.mountComponent 采取了一个快捷实现。此快捷实现方式将阻止诸如 componentWillMount 之类的生命周期方法被调用。 Here’s mountComponent as it stood in part one 这是第一部分的 mountComponent： class FeactCompositeComponentWrapper &#123; constructor(element) &#123; this._currentElement = element; &#125; mountComponent(container) &#123; const Component = this._currentElement.type; const componentInstance = new Component(this._currentElement.props); let element = componentInstance.render(); while (typeof element.type === &#x27;function&#x27;) &#123; element = (new element.type(element.props)).render(); &#125; const domComponentInstance = new FeactDOMComponent(element); return domComponentInstance.mountComponent(container); &#125;&#125; mountComponent is working its way down to a native element. As long as render() returns a composite component element, it calls render again until it finally gets a native element. The problem is these sub composite components are not privy to the entire lifecycle. In other words, their render method is being called, but that’s it. What we really need to do is properly mount all components. mountComponent 正在不断向下调用直到返回一个原生元素。只要 render() 返回一个复合组件元素，它就一直调用 render ，直到它最终获得一个原生元素。问题是这些子复合组件不清楚整个生命周期。换句话说，它们的渲染方法被调用，就是这样。我们真正需要做的是正确挂载所有组件。 To fix this, let’s have something else do the mounting for us 为了解决这个问题，让我们为处理挂载 class FeactCompositeComponentWrapper &#123; ... mountComponent(container) &#123; const Component = this._currentElement.type; const componentInstance = new Component(this._currentElement.props); this._instance = componentInstance; const markup = this.performInitialMount(container); return markup; &#125; performInitialMount(container) &#123; const renderedElement = this._instance.render(); const child = instantiateFeactComponent(renderedElement); this._renderedComponent = child; return FeactReconciler.mountComponent(child, container); &#125;&#125;const FeactReconciler = &#123; mountComponent(internalInstance, container) &#123; return internalInstance.mountComponent(container); &#125;&#125;;function instantiateFeactComponent(element) &#123; if (typeof element.type === &#x27;string&#x27;) &#123; return new FeactDOMComponent(element); &#125; else if (typeof element.type === &#x27;function&#x27;) &#123; return new FeactCompositeComponentWrapper(element); &#125;&#125; This is a fair amount of new code, but the basic idea is to move mounting out into another layer. That’s the job of FeactReconciler, which will also gain more jobs as we move forward. Over in React, there is ReactReconciler which is serving the same role. 这是相当数量的新代码，但基本思想是将挂载移至另一层。这是 FeactReconciler 的工作，随着我们的前进，也将有更多的工作要做。在 React 中，ReactReconciler 扮演同样的角色。 Remember the tight coupling that was called out in part one? It’s gone now, FeactCompositeComponentWrapper is usable in more places now, which is a good thing. 还记得在第一部分中提到的紧耦合？现在已经消失了，FeactCompositeComponentWrapper 现在可以在更多的地方使用，这是件好事。 调整 Feact.render()（Tweaking Feact.render()）Feact.render() is calling componentInstance.mountComponent(container) in part one. Let’s change that and instead have FeactReconciler deal with all mounting Feact.render() 在第一部分中调用 componentInstance.mountComponent(container)。让我们改变一下，使用 FeactReconciler 处理所有的挂载。 const Feact = &#123; ... render(element, container) &#123; const wrapperElement = this.createElement(TopLevelWrapper, element); const componentInstance = new FeactCompositeComponentWrapper(wrapperElement); return FeactReconciler.mountComponent( componentInstance, container ); &#125;&#125; And with that, all composite component elements will get properly mounted. This sets them up properly for participating in the entire Feact lifecycle. 现在，所有复合组件元素都将正确挂载。可以开始参与整个 Feact 生命周期。 最后添加 componentWillMount 和 componentDidMount（Finally adding componentWillMount and componentDidMount）Now with all the setup out of the way, actually adding support for these two is simple. Just before mounting, call componentWillMount if it exists. Likewise, just after mounting, call componentDidMount if it exists 实际上，添加对这两个生命周期方法的支持很简单。在组件挂载之前，如果存在，调用 componentWillMount。同样的，在挂载之后，如果存在，调用 componentDidMount。 class FeactCompositeComponentWrapper &#123; ... mountComponent(container) &#123; const Component = this._currentElement.type; const componentInstance = new Component(this._currentElement.props); this._instance = componentInstance; if (componentInstance.componentWillMount) &#123; componentInstance.componentWillMount(); &#125; const markUp = this.performInitialMount(container); if (componentInstance.componentDidMount) &#123; componentInstance.componentDidMount(); &#125; return markUp; &#125;, ...&#125; 第二部分总结（Concluding part two）That wraps up part two. Here is a fiddle encompassing all we’ve done 这就是第二部分，这是一个 fiddle 在线示例，包含我们目前所实现的代码： fiddle 在线示例：fiddle In part three, we’ll add support for updates. 在 第三部分 我们将添加组件更新的支持。","categories":[{"name":"翻译","slug":"翻译","permalink":"http://tcatche.site/categories/%E7%BF%BB%E8%AF%91/"}],"tags":[{"name":"react","slug":"react","permalink":"http://tcatche.site/tags/react/"},{"name":"翻译","slug":"翻译","permalink":"http://tcatche.site/tags/%E7%BF%BB%E8%AF%91/"}]},{"title":"React 内部原理，第一部分：基础渲染","slug":"react-internals-part-one-basic-rendering","date":"2017-07-25T07:35:00.000Z","updated":"2018-08-01T10:41:24.000Z","comments":true,"path":"2017/07/react-internals-part-one-basic-rendering/","link":"","permalink":"http://tcatche.site/2017/07/react-internals-part-one-basic-rendering/","excerpt":"","text":"原文：React Internals, Part One: basic rendering In this five part series, we will “recreate” React from the ground up, learning how it works along the way. Once we’ve finished, you should have a good grasp of how React works, and when and why it calls the various lifecycle methods of a component. 在这五部分系列中，我们将从头开始“重新创建” React，学习其如何工作。一旦完成，你应该对 React 的工作原理有一个很好地掌握，以及它在何时，为何调用组件的各种生命周期方法。 本系列（The series） part one: basic rendering &lt;- you are here part two: componentWillMount and componentDidMount part three: basic updating part four: setState part five: transactions 全部译文： 第一部分：基础渲染 &lt;- 当前位置 第二部分：componentWillMount and componentDidMount 第三部分：基本更新 第四部分：setState 第五部分：事务 声明（disclaimer）This series is based on React 15.3, in particular using ReactDOM and the stack reconciler. The fancy new fiber reconciler is out of scope here. The React clone we are going to build will not even come close to implementing all of React. But Feact’s source code will mirror React’s as much as possible. 本系列基于 React 15.3，特别是使用 ReactDOM 和堆栈 reconciler。这款高性能的 fiber reconciler 超出了本文的范围。我们要构建的 React 克隆版（Feact）不会实现所有的 React 功能。但是，Feact 的源代码将尽可能地反映 React 的内容。 一些背景：元素和组件（Some Background: Elements and Components）At the heart of React are three different types of entities: native DOM elements, virtual elements and components. React 的核心是三种不同类型的实体：原生 DOM 元素，虚拟元素和组件。 原生 DOM 元素（native DOM elements）These are exactly what they sound like, the actual DOM elements that the browser uses as the building blocks of a webpage. At some point, React will call document.createElement() to get one, and use the browser’s DOM api to update them such as element.insertBefore(), element.nodeValue, etc. 正如它的名字所说，原生 DOM 元素是浏览器用作构建网页块的实际 DOM 元素。在某些时候，React会调用 document.createElement() 来创建它，并使用浏览器的 DOM API 如 element.insertBefore()、element.nodeValue 等来更新它们。 虚拟 React 元素（virtual React elements）A virtual React element (just called an “element” in the source code), is an in memory representation of what you’d like a given DOM element (or entire tree of elements) to be for a particular render. An element can either directly represent a DOM element such as h1, div, etc. Or it can represent a user defined composite component, which is explained below. 虚拟的 React 元素（在源代码中称为“元素”），是表示特定渲染中给定的DOM元素（或整个元素树）在内存中的表示形式。一个React 元素可以直接表示一个 DOM 元素，如h1、div等，或者表示一个用户定义的复合组件，这将在下面解释。 组件（Components）“Component” is a pretty generic term in React. They are entities within React that do various types of work. Different types of components do different things. For example, ReactDOMComponent from ReactDOM is responsible for bridging between React elements and their corresponding native DOM elements. “组件”是 React 中相当通用的术语。它们是 React 中的执行不同类型工作的实体。不同类型的组件做不同的事情。例如，ReactDOM 的 ReactDOMComponent 负责在 React 元素及其对应的原生 DOM 元素之间进行连接。 用户定义的复合组件（User Defined Composite Components）You are already familiar with one type of component: the composite component. Whenever you call React.createClass(), or have an es6 class extend React.Component, you are creating a Composite Component class. It turns out our view of the component lifecycle with methods like componentWillMount, shouldComponentUpdate is just one piece of the puzzle. These are the lifecycle methods that we hook into because they benefit us. But React components have other lifecycle methods such as mountComponent and receiveComponent. We never implement, call, or even know these other lifecycle methods exist. They are only used internally by React. 你已经熟悉一种类型的组件：复合组件。无论何时调用 React.createClass() ，或者有一个 es6 类扩展了 React.Component，都将创建一个复合组件类。我们经常所看到的组件生命周期的方法，如 componentWillMount、shouldComponentUpdate 只是它的一部分，这些我们经常使用的生命周期方法，因为他们很有帮助。但是 React 组件还具有其他生命周期方法，如 mountComponent 和 receiveComponent。我们从来没有实现，调用，甚至知道这些其他的生命周期方法存在。它们仅在 React 内部被使用。 The truth is the components we create are incomplete. React will take our component class, and wrap it in a ReactCompositeComponentWrapper, which then gives the components we wrote the full lifecycle hooks and ability to participate in React. 事实是我们创建的组件是不完整的。 React 将我们的组件类包装在 ReactCompositeComponentWrapper 中，然后给出了我们可以编写完整生命周期钩子和参与 React 的能力的组件。 React 是声明式的（React is declarative）When it comes to components, our job is to define component classes. But we never instantiate them. Instead React will instantiate an instance of our classes when it needs to. 当开始编写组件的时候，我们的工作就是定义组件类。但是我们从不实例化它们。相反，React 会在需要时实例化类的实例。 We also don’t consciously instantiate elements. But we do implicitly when we write JSX, such as: 我们也不必实例化元素。但是，当我们编写 JSX 时，我们会隐式地进行实例化，比如： class MyComponent extends React.Component &#123; render() &#123; return &lt;div&gt;hello&lt;/div&gt;; &#125;&#125; That bit of JSX gets translated into this by the compiler: 这一段 JSX 被编译器翻译成： class MyComponent extends React.Component &#123; render() &#123; return React.createElement(&#x27;div&#x27;, null, &#x27;hello&#x27;); &#125;&#125; so in a sense, we are causing an element to be created because our code will call React.createElement(). But in another sense we aren’t, because it’s up to React to instantiate our component and then call render() for us. It’s simplest to consider React declarive. We describe what we want, and React figures out how to make it happen. 所以在某种意义上，我们造成一个元素被创建，因为我们的代码将调用 React.createElement()。但是在另一个意义上，并不是这样，因为实际是 React 实例化了我们的组件，为我们调用 render() 。让 React 是声明式的是最简单的。我们描述我们想要什么，而由 React 计算出如何实现。 一个小型的，山寨的 React，我们叫它 Feact（A tiny, fake React called Feact）Now with a little bit of background under our belt, let’s get started building our React clone. Since this clone is tiny and fake, we’ll give it the imaginative name “Feact”. 现在我们对背景有一点了解，让我们开始构建我们的 React 克隆版。这个克隆是非常小型的山寨的，我们给它一个有想象力的名字 Feact。 Let’s pretend we want to create this tiny Feact app: 我们假装要创建这个小巧的 Feact 应用程序： Feact.render(&lt;h1&gt;hello world&lt;/h1&gt;, document.getElementById(&#x27;root&#x27;)); For starters, let’s ditch the JSX. Assuming Feact was fully implemented, after running the JSX through the compiler we’d end up with 对于初学者，让我们来看看 JSX。假设 Feact 已经完全实现了 JSX，在通过编译器运行后，我们最终会得到： Feact.render( Feact.createElement(&#x27;h1&#x27;, null, &#x27;hello world&#x27;), document.getElementById(&#x27;root&#x27;)); JSX is a large topic on its own and a bit of a distraction. So from here on out, we will use Feact.createElement instead of JSX, so let’s go ahead and implement it JSX 本身就是一个很大内容，有点脱离本文主题。所以从这里开始，我们将使用 Feact.createElement 代替 JSX，让我们继续实现它： const Feact = &#123; createElement(type, props, children) &#123; const element = &#123; type, props: props || &#123;&#125; &#125;; if (children) &#123; element.props.children = children; &#125; return element; &#125;&#125;; Elements are just simple objects representing something we want rendered. 元素只是我们想要渲染的东西的简单对象表示。 Feact.render() 应该做什么？（What should Feact.render() do?）Our call to Feact.render() passes in what we want rendered and where it should go. This is the starting point of any Feact app. For our first attempt, let’s define render() to look something like this 我们调用 Feact.render() ，传递了我们想要渲染的内容，以及它的位置。这是任何 Feact 应用的入口。对于我们的第一次尝试，让我们定义这样的 render() const Feact = &#123; createElement() &#123; /* as before */ &#125;, render(element, container) &#123; const componentInstance = new FeactDOMComponent(element); return componentInstance.mountComponent(container); &#125;&#125;; When render() finishes, we have a finished webpage. So based on that, we know FeactDOMComponent is truly digging in and creating DOM for us. Let’s go ahead and take a stab at implementing it: 当 render() 完成时，我们会有一个完整的网页。基于此，我们知道 FeactDOMComponent 参与并为我们创建了 DOM。让我们继续努力实施它： class FeactDOMComponent &#123; constructor(element) &#123; this._currentElement = element; &#125; mountComponent(container) &#123; const domElement = document.createElement(this._currentElement.type); const text = this._currentElement.props.children; const textNode = document.createTextNode(text); domElement.appendChild(textNode); container.appendChild(domElement); this._hostNode = domElement; return domElement; &#125;&#125; mountComponent stores the DOM element it creates in this._hostNode. We don’t need that in part one, but we will in part three. mountComponent 存储它创建的 DOM元素到 this._hostNode。在本文我们不需要它，但是在第三部分的文章我们需要。 在线示例：fiddle In about 40 lines of pretty crappy code we’ve got an incredibly limited and pathetic little “React clone”! Feact isn’t going to take over the world, but it’s serving as a nice learning sandbox. 在这大约 40 行的相当糟糕的代码，我们得到了一个令人难以置信的非常的小的“React 克隆”。Feact 不会接管世界，但它是一个很好的学习沙箱。 添加用户定义的组件（Adding user defined components）We want to be able to render more than just a single, hardcoded, DOM element. So let’s add support for defining component classes: 我们希望能够渲染不仅仅是一个单一的，硬编码的 DOM 元素，我们来添加对自定义组件类的支持： const Feact = &#123; createClass(spec) &#123; function Constructor(props) &#123; this.props = props; &#125; Constructor.prototype.render = spec.render; return Constructor; &#125;, render(element, container) &#123; // our previous implementation can&#x27;t // handle user defined components, // so we need to rethink this method &#125;&#125;;const MyTitle = Feact.createClass(&#123; render() &#123; return Feact.createElement(&#x27;h1&#x27;, null, this.props.message); &#125;&#125;;Feact.render(&#123; Feact.createElement(MyTitle, &#123; message: &#x27;hey there Feact&#x27; &#125;), document.getElementById(&#x27;root&#x27;)); Remember, we’re not dealing with JSX for this blog post series, because we’ve got plenty to deal with already. If we had JSX available, the above would look like 请记住，我们这系列文章并不处理 JSX，因为我们已经有很多要处理的内容了。如果我们有可用的 JSX 处理器，上面将会是被编译成这样： Feact.render( &lt;MyTitle message=&quot;hey there Feact&quot; /&gt;, document.getElementById(&#x27;root&#x27;)); We passed the component class into createElement. An element can either represent a primitive DOM element, or it can represent a composite component. The distinction is easy, if type is a string, the element is a native primitive. If it is a function, the element represents a composite component. 我们将组件类传递给 createElement。元素可以表示原生 DOM 元素，也可以表示复合组件。区别很容易，如果 type 是一个字符串，则元素表示原始 DOM 元素。如果它是一个函数，则该元素表示一个复合组件。 改进 Feact.render()（Improving Feact.render()）If you trace back through the code so far, you will see that Feact.render() as it stands now can’t handle composite components, so let’s fix that: 如果你回溯到目前为止的代码，你会看到现在的 Feact.render() 不能处理复合组件，所以我们来改进一下： Feact = &#123; render(element, container) &#123; const componentInstance = new FeactCompositeComponentWrapper(element); return componentInstance.mountComponent(container); &#125;&#125;class FeactCompositeComponentWrapper &#123; constructor(element) &#123; this._currentElement = element; &#125; mountComponent(container) &#123; const Component = this._currentElement.type; const componentInstance = new Component(this._currentElement.props); const element = componentInstance.render(); const domComponentInstance = new FeactDOMComponent(element); return domComponentInstance.mountComponent(container); &#125;&#125; By giving users the ability to define their own components, Feact can now create dynamic DOM nodes that can change depending on the value of the props. There’s a lot going on in this upgrade to Feact, but if you trace through it, it’s not too bad. You can see where we call componentInstance.render(), to get our hands on an element that we can then pass into FeactDOMComponent. 通过给用户定义自己的组件的能力，Feact 现在可以创建能够根据 props 的值改变的动态 DOM 节点。在升级 Feact 的过程中有很多事情要做，但是如果你跟踪它的进行过程，这并不是很困难。你可以看到我们在哪里调用 componentInstance.render() ，以获得一个可以传入 FeactDOMComponent 的元素。 Notice how FeactCompositeComponentWrapper is directly creating a FeactDOMComponent? That’s a tight coupling which isn’t so great. We’ll fix this later. If React was this tightly coupled, it’d only ever be able to build web apps. Keeping ReactCompositeComponentWrapper in the dark about other component types surely made building React Native easier. 注意 FeactCompositeComponentWrapper 如何直接创建一个 FeactDOMComponent ？这个耦合很紧密的，但问题不大。我们稍后会解决这个问题。如果 React 是紧密耦合的，那么它只能构建 Web 应用程序。保持 ReactCompositeComponentWrapper 与其他组件类型透明会使本地化的 React（React Native） 更容易。 复合组件的改进(An improvement for composite components)Currently our composite components must return elements that represent primitive DOM nodes, we can’t return other composite component elements. Let’s fix that. We want to be able to do this 目前，我们的复合组件必须返回原始 DOM 节点的元素，我们不能返回其他复合组件元素。我们来解决这个问题，我们希望能够实现这个功能： const MyMessage = Feact.createClass(&#123; render() &#123; if (this.props.asTitle) &#123; return Feact.createElement(MyTitle, &#123; message: this.props.message &#125;); &#125; else &#123; return Feact.createElement(&#x27;p&#x27;, null, this.props.message); &#125; &#125;&#125; This composite component’s render() is either going to return a primitive element or a composite component element. Currently Feact can’t handle this, if asTitle was true, FeactCompositeComponentWrapper would give FeactDOMComponent a non-native element, and FeactDOMComponent would blow up. Let’s fix FeactCompositeComponentWrapper 该复合元素的 render() 方法返回一个原始元素或者复合元素。当前版本的 Feact 无法处理它，如果 asTitle 值为 true，FeactCompositeComponentWrapper 将会传递给 FeactDOMComponent 一个非原始的元素，FeactDOMComponent 就会挂掉，我们来修复 FeactCompositeComponentWrapper。 class FeactCompositeComponentWrapper &#123; constructor(element) &#123; this._currentElement = element; &#125; mountComponent(container) &#123; const Component = this._currentElement.type; const componentInstance = new Component(this._currentElement.props); let element = componentInstance.render(); while (typeof element.type === &#x27;function&#x27;) &#123; element = (new element.type(element.props)).render(); &#125; const domComponentInstance = new FeactDOMComponent(element); domComponentInstance.mountComponent(container); &#125;&#125; Heads up, this “fix” is a short cut that’s just good enough to meet our current needs. Notice how it repeatedly calls render until it gets down to a primitive element? That’s not good enough, because those subcomponents need to participate in the entire lifecycle. For example, if we had support for componentWillMount, those subcomponents would never get their’s called. We’ll fix this later. 首先，这个“修复”是一个小的，足以满足我们当前的需求。注意，如果它重复调用 render，直到最终变成一个原始元素？这不够好，因为这些子组件需要参与整个生命周期。例如，如果我们已经支持了 componentWillMount` ，那么这些子组件的这个方法将永远不会被调用。我们稍后会解决这个问题。 再一次修复 Feact.render()（Fixing Feact.render() again）The first version of Feact.render() could only handle primitive elements. Now it can only handle composite elements. It needs to be able to handle both. We could write a “factory” function that will create a component for us based on the element’s type, but there’s another approach that React took. Since FeactCompositeComponentWrapper components ultimately result in a FeactDOMComponent, let’s just take whatever element we were given and wrap it in such a way that we can just use a FeactCompositeComponentWrapper 第一个版本的 Feact.render() 只能处理原始元素，现在它只能处理复合元素。它需要能够处理两者。我们可以编写一个工厂函数，它将根据元素的类型为我们创建一个组件，但是还有另外一种 React 采用的方法。由于 FeactCompositeComponentWrapper 组件最终产生了 FeactDOMComponent，所以我们只需要使其接收我们给定的任何元素，并将它包装起来，以便我们可以只使用 FeactCompositeComponentWrapper const TopLevelWrapper = function(props) &#123; this.props = props;&#125;;TopLevelWrapper.prototype.render = function() &#123; return this.props;&#125;;const Feact = &#123; render(element, container) &#123; const wrapperElement = this.createElement(TopLevelWrapper, element); const componentInstance = new FeactCompositeComponentWrapper(wrapperElement); // as before &#125;&#125;; ToplevelWrapper is basically a simple composite component. It could have been defined by calling Feact.createClass(). Its render method just returns the user provided element. Since ToplevelWrapper will get wrapped in a FeactCompositeComponentWrapper, we don’t care what type the user provided element was, FeactCompositeComponentWrapper will do the right thing regardless. ToplevelWrapper 基本上是一个简单的复合组件。它可以通过调用 Feact.createClass() 来定义。它的渲染方法只返回用户提供的元素。由于ToplevelWrapper 将被包装在 FeactCompositeComponentWrapper 中，所以我们不关心用户提供的元素是什么类型的，FeactCompositeComponentWrapper 会做正确的事情。 第一部分总结（Conclusion to part one）With that, Feact can render simple components. As far as basic rendering is concerned, we’ve hit most of the major considerations. In real React, rendering is much more complicated as there are many other things to consider such as events, focus, scroll position of the window, performance, and much more. Here’s a final fiddle that wraps up all we’ve built so far: 现在，Feact 可以渲染简单的组件。就基本渲染而言，我们已经遇到了大多数需要主要考虑因素。在真实的 React 中，渲染要复杂得多，因为还有许多其他的事情需要考虑，比如事件，焦点，滚动窗口的位置，性能等等。 这是最后的 fiddle 示例，包装了我们迄今为止所建立的所有内容： 在线示例：fiddle on to part two!第二部分译文","categories":[{"name":"翻译","slug":"翻译","permalink":"http://tcatche.site/categories/%E7%BF%BB%E8%AF%91/"}],"tags":[{"name":"react","slug":"react","permalink":"http://tcatche.site/tags/react/"},{"name":"翻译","slug":"翻译","permalink":"http://tcatche.site/tags/%E7%BF%BB%E8%AF%91/"}]},{"title":"React - Mixins 是“有害”的（Mixins Considered Harmful）","slug":"react-mixins-considered-harmful","date":"2017-07-24T07:25:00.000Z","updated":"2018-08-01T10:41:24.000Z","comments":true,"path":"2017/07/react-mixins-considered-harmful/","link":"","permalink":"http://tcatche.site/2017/07/react-mixins-considered-harmful/","excerpt":"","text":"原文：Mixins Considered Harmful “How do I share the code between several components?” is one of the first questions that people ask when they learn React. Our answer has always been to use component composition for code reuse. You can define a component and use it in several other components. “我如何在几个组件之间共享代码？”，这是人们在学习 React 时提出的一个问题。我们的答案一直是使用组件组合来进行代码重用。你可以定义一个组件并在其他几个组件中使用它。 It is not always obvious how a certain pattern can be solved with composition. React is influenced by functional programming but it came into the field that was dominated by object-oriented libraries. It was hard for engineers both inside and outside of Facebook to give up on the patterns they were used to. 通过组合解决特定模式并不总是很明显。React 受函数式编程影响，但它进入了面向对象库主导的领域。 Facebook 内部和其他外面的工程师很难放弃他们习惯的模式。 To ease the initial adoption and learning, we included certain escape hatches into React. The mixin system was one of those escape hatches, and its goal was to give you a way to reuse code between components when you aren’t sure how to solve the same problem with composition. 为了更容易最初的适应和学习 React，我们在 React 中包含了一些逃生舱口。mixin 系统是其中之一，它的目标是为你提供一种在组件之间重用代码的方法，当你不确定如何使用组合解决相同的问题时。 Three years passed since React was released. The landscape has changed. Multiple view libraries now adopt a component model similar to React. Using composition over inheritance to build declarative user interfaces is no longer a novelty. We are also more confident in the React component model, and we have seen many creative uses of it both internally and in the community. React 发布三年了，环境已经改变了。现在多个视图库采用类似于 React 的组件模型。使用组合而不是继承来构建声明式用户界面不再是新奇的事物。我们对 React 的组件模型也更有信心，而且我们在内部和社区都看到了很多创造性的用途。 In this post, we will consider the problems commonly caused by mixins. Then we will suggest several alternative patterns for the same use cases. We have found those patterns to scale better with the complexity of the codebase than mixins. 在这篇文章中，我们将思考由 mixins 引起的问题。并且我们将为相同的用例提出几种 mixins 的替代模式。我们发现这些模式与 mixins 相比较，更适应复杂的代码库。 Why Mixins are BrokenAt Facebook, React usage has grown from a few components to thousands of them. This gives us a window into how people use React. Thanks to declarative rendering and top-down data flow, many teams were able to fix a bunch of bugs while shipping new features as they adopted React. 在 Facebook，React 的使用已经从几个组件增长到数千个。这给了我们一个人们如何使用 React 的窗口。由于声明式渲染和自上而下的数据流，许多团队采用React 能够修复一大堆错误，同时发布新功能。 However it’s inevitable that some of our code using React gradually became incomprehensible. Occasionally, the React team would see groups of components in different projects that people were afraid to touch. These components were too easy to break accidentally, were confusing to new developers, and eventually became just as confusing to the people who wrote them in the first place. Much of this confusion was caused by mixins. At the time, I wasn’t working at Facebook but I came to the same conclusions after writing my fair share of terrible mixins. 然而，不可避免的，我们使用 React 的一些代码逐渐变得难以理解。有时候，React 小组在不同的项目中能看到很多人们害怕接触的组件。这些组件太容易被意外地破坏，使新的开发人员感到困惑，最终变得即使最初编写它们的人也一样困惑。很多这样的混乱是由 mixins 造成的。虽然当时我没有在 Facebook 上工作，但是在写出我的关于 mixins 的糟糕之处的分享后，我得出了同样的结论。 This doesn’t mean that mixins themselves are bad. People successfully employ them in different languages and paradigms, including some functional languages. At Facebook, we extensively use traits in Hack which are fairly similar to mixins. Nevertheless, we think that mixins are unnecessary and problematic in React codebases. Here’s why. 这并不意味着 mixins 本身是坏的。人们成功地在不同的语言和范例中使用它，包括一些函数式语言。在 Facebook，我们广泛地在 Hack 语言中使用 traits，它们与 mixins 非常相似。尽管如此，我们仍然认为在 React 代码库中，mixins 是不必要的和容易出问题的。这里列出来为什么这样说的几条理由： Mixins 引入了隐式的依赖关系（Mixins introduce implicit dependencies）Sometimes a component relies on a certain method defined in the mixin, such as getClassName(). Sometimes it’s the other way around, and mixin calls a method like renderHeader() on the component. JavaScript is a dynamic language so it’s hard to enforce or document these dependencies. 有时一个组件依赖于在 mixin 中定义的某个确定方法，例如 getClassName()。有时相反，mixin 在组件上调用 renderHeader() 方法。 JavaScript 是一种动态语言，因此很难强制记录这些依赖关系。 Mixins break the common and usually safe assumption that you can rename a state key or a method by searching for its occurrences in the component file. You might write a stateful component and then your coworker might add a mixin that reads this state. In a few months, you might want to move that state up to the parent component so it can be shared with a sibling. Will you remember to update the mixin to read a prop instead? What if, by now, other components also use this mixin? Mixins 打破了常见的，通常是安全的假设，你可以通过搜索 state 在组件文件中的出现位置来重命名它的键名或方法。你可能会写一个有状态的组件，然后你的同事可能添加一个读取这个组件 state 的 mixin。几个月之后，你可能希望将该 state 移动到父组件，以便与其兄弟组件共享。你会记得更新这个 mixin 来读取 props 而不是 state 吗？如果此时，其他组件也在使用这个 mixin 呢？ These implicit dependencies make it hard for new team members to contribute to a codebase. A component’s render() method might reference some method that isn’t defined on the class. Is it safe to remove? Perhaps it’s defined in one of the mixins. But which one of them? You need to scroll up to the mixin list, open each of those files, and look for this method. Worse, mixins can specify their own mixins, so the search can be deep. 这些隐含的依赖关系使得新的团队成员很难为代码库做出贡献。组件的 render() 方法可能引用一些未在该类上定义的方法，是否可以安全地删除？也许它是在一个 maxin 中定义的。但是是哪一个呢？你需要向上滚动到 mixin 列表，打开这些文件，并查找此方法。更糟糕的是，mixins 可以指定自己的 mixins，所以搜索层级可能会很深。 Often, mixins come to depend on other mixins, and removing one of them breaks the other. In these situations it is very tricky to tell how the data flows in and out of mixins, and what their dependency graph looks like. Unlike components, mixins don’t form a hierarchy: they are flattened and operate in the same namespace. 通常来说，mixins 依赖于其他 mixin，并且删除其中的一个会破坏另一个 mixin。在这些情况下，告诉数据如何流入和流出 mixin 以及它们的依赖图怎样是非常棘手的。与组件不同，mixins 不构成层次结构：它们被平坦化并在相同的命名空间中运行。 Mixins 引起名称冲突（Mixins cause name clashes）There is no guarantee that two particular mixins can be used together. For example, if FluxListenerMixin defines handleChange() and WindowSizeMixin defines handleChange(), you can’t use them together. You also can’t define a method with this name on your own component. 无法保证两个特定的 mixin 可以一起使用。例如，如果 FluxListenerMixin 和 WindowSizeMixin 都定义了 handleChange()，则不能一起使用它们。同时，你也无法在自己的组件上定义具有此名称的方法。 It’s not a big deal if you control the mixin code. When you have a conflict, you can rename that method on one of the mixins. However it’s tricky because some components or other mixins may already be calling this method directly, and you need to find and fix those calls as well. 如果你控制此 mixin 代码，这倒还好，当有冲突时，你可以在其中一个mixins上重命名该方法。但是这也会很棘手，因为某些组件或其他 mixins 可能已经直接调用此方法，你还需要查找和修复这些调用。 If you have a name conflict with a mixin from a third party package, you can’t just rename a method on it. Instead, you have to use awkward method names on your component to avoid clashes. 如果你有与第三方软件包的 mixins 名称冲突，则无法重命名其上的方法。相反，你必须在组件上使用尴尬的方法名称才能避免冲突。 The situation is no better for mixin authors. Even adding a new method to a mixin is always a potentially breaking change because a method with the same name might already exist on some of the components using it, either directly or through another mixin. Once written, mixins are hard to remove or change. Bad ideas don’t get refactored away because refactoring is too risky. 对于 mixin 作者，情况也并不好。即使添加一个新的方法到 mixin 中也通常是一个潜在的破坏性的变化，因为具有相同的名称方法可能已经存在于使用它的一些组件，直接或通过另一个mixin。一旦写入，mixins 很难删除或改变。坏的设计也不会被重构，因为重构太危险了。 Mixins 导致滚雪球式的复杂性（Mixins cause snowballing complexity）Even when mixins start out simple, they tend to become complex over time. The example below is based on a real scenario I’ve seen play out in a codebase. 即使刚开始的时候 mixins 很简单，它们往往随着时间的推移变得复杂。下面的例子是基于我在代码库中看到的一个真实场景。 A component needs some state to track mouse hover. To keep this logic reusable, you might extract handleMouseEnter(), handleMouseLeave() and isHovering() into a HoverMixin. Next, somebody needs to implement a tooltip. They don’t want to duplicate the logic in HoverMixin so they create a TooltipMixin that uses HoverMixin. TooltipMixin reads isHovering() provided by HoverMixin in its componentDidUpdate() and either shows or hides the tooltip. 一个组件需要一些状态来跟踪鼠标悬停。为了使逻辑可重用，你可以将 handleMouseEnter()、handleMouseLeave() 和 isHovering()提取到HoverMixin 中。接下来，有人需要实现一个工具提示。他们不想复制 HoverMixin 的逻辑，所以他们创建一个使用 HoverMixin 的 TooltipMixin。 TooltipMixin 在其 componentDidUpdate() 读取 HoverMixin 提供的 isHovering()，并显示或隐藏工具提示。 A few months later, somebody wants to make the tooltip direction configurable. In an effort to avoid code duplication, they add support for a new optional method called getTooltipOptions() to TooltipMixin. By this time, components that show popovers also use HoverMixin. However popovers need a different hover delay. To solve this, somebody adds support for an optional getHoverOptions() method and implements it in TooltipMixin. Those mixins are now tightly coupled. 几个月后，有人想让工具提示方向可配置。为了避免代码重复，他们对 TooltipMixin 增加了一个新的可选方法 getTooltipOptions() 的支持。到这个时候，另一个显示弹出层悬停的组件也使用 HoverMixin。然而，此组件需要不同的悬停延迟。为了解决这个问题，有人增加了对可选的 getTooltipOptions() 方法的支持，并在 TooltipMixin 中实现它。这些 mixins 现在紧密耦合。 This is fine while there are no new requirements. However this solution doesn’t scale well. What if you want to support displaying multiple tooltips in a single component? You can’t define the same mixin twice in a component. What if the tooltips need to be displayed automatically in a guided tour instead of on hover? Good luck decoupling TooltipMixin from HoverMixin. What if you need to support the case where the hover area and the tooltip anchor are located in different components? You can’t easily hoist the state used by mixin up into the parent component. Unlike components, mixins don’t lend themselves naturally to such changes. 这还好没有任何新的需求。然而，这个解决方案不能很好地扩展，如果你想支持在单个组件中显示多个工具提示怎么办？你不能在组件中定义相同的 mixin 两次。如果工具提示需要在引导中自动显示，而不是悬停展示？祝你从 HoverMixin 的解耦 TooltipMixin 好运。如果你需要支持悬停区域和工具提示锚位于不同组件的情况，该怎么办？你不能轻易地将 mixins 使用的状态提升到父组件中。与组件不同，mixins 并不适用于这些更改。 Every new requirement makes the mixins harder to understand. Components using the same mixin become increasingly coupled with time. Any new capability gets added to all of the components using that mixin. There is no way to split a “simpler” part of the mixin without either duplicating the code or introducing more dependencies and indirection between mixins. Gradually, the encapsulation boundaries erode, and since it’s hard to change or remove the existing mixins, they keep getting more abstract until nobody understands how they work. 每一个新的要求使得 mixins 更难理解。使用相同 mixin 的组件随时间变得越来越多。任何 mixin 的新的功能被添加到使用该 mixin 的所有组件。没有办法拆分mixin 的“更简单”的部分，而不需要复制代码或在 mixins 之间引入更多的依赖性和间接性。逐渐地，封装的边界被侵蚀，由于很难改变或删除现有的 mixins，它们不断变得更抽象，直到没有人了解它们如何工作。 These are the same problems we faced building apps before React. We found that they are solved by declarative rendering, top-down data flow, and encapsulated components. At Facebook, we have been migrating our code to use alternative patterns to mixins, and we are generally happy with the results. You can read about those patterns below. 这些是我们在 React 之前构建应用程序所遇到的同样的问题。我们发现它们通过声明性渲染，自上而下的数据流和封装的组件来解决。在 Facebook，我们一直在使用替代模式从 mixins 迁移我们的代码，通常，对迁移的结果都很满意。你可以阅读下面的这些模式。 从 Mixins 迁移（Migrating from Mixins）Let’s make it clear that mixins are not technically deprecated. If you use React.createClass(), you may keep using them. We only say that they didn’t work well for us, and so we won’t recommend using them in the future. 让我们清楚的是，mixins 在技术上不被淘汰。如果你使用 React.createClass()，可以继续使用它们。我们只是说它对我们没有好处，所以我们不建议使用它们。 Every section below corresponds to a mixin usage pattern that we found in the Facebook codebase. For each of them, we describe the problem and a solution that we think works better than mixins. The examples are written in ES5 but once you don’t need mixins, you can switch to ES6 classes if you’d like. 下面的每个部分对应于我们在 Facebook 代码库中找到的 mixin 使用模式。对于它们中的每个，我们描述它们问题和我们认为比 mixins 更好的解决方案。这些例子是在ES5中编写的，但是一旦你不需要 mixin，你可以根据需要切换到 ES6 的类语法。 We hope that you find this list helpful. Please let us know if we missed important use cases so we can either amend the list or be proven wrong! 我们希望你发现此列表有帮助。如果我们错过重要的用例，请让我们知道，我们可以修改列表或修正错误！ 性能优化（Performance Optimizations）One of the most commonly used mixins is PureRenderMixin. You might be using it in some components to prevent unnecessary re-renders when the props and state are shallowly equal to the previous props and state: 最常用的 mixins 之一是 PureRenderMixin。当 props 和 state 和之前 props 和 state 浅相等时，你可能会在某些组件中使用它来防止不必要的重新渲染 var PureRenderMixin = require(&#x27;react-addons-pure-render-mixin&#x27;);var Button = React.createClass(&#123; mixins: [PureRenderMixin], // ...&#125;); 解决方案To express the same without mixins, you can use the shallowCompare function directly instead: 不使用 mioxins 要实现相同的功能，你可以直接使用 shallowCompare 替代： var shallowCompare = require(&#x27;react-addons-shallow-compare&#x27;);var Button = React.createClass(&#123; shouldComponentUpdate: function(nextProps, nextState) &#123; return shallowCompare(this, nextProps, nextState); &#125;, // ...&#125;); If you use a custom mixin implementing a shouldComponentUpdate function with different algorithm, we suggest exporting just that single function from a module and calling it directly from your components. 如果你使用自定义 mixin 来实现具有不同算法的 shouldComponentUpdate 函数，我们建议从模块导出该函数，并直接从组件中调用它。 We understand that more typing can be annoying. For the most common case, we plan to introduce a new base class called React.PureComponent in the next minor release. It uses the same shallow comparison as PureRenderMixin does today. 我们知道更多的输入字符可能会令人烦恼。对于最常见的情况，我们计划在下一个次要版本中引入一个名为 React.PureComponent 的新基类。它使用与现在的 PureRenderMixin 相同的浅比较。（注：该基类在v15.3.0 版本已经被引入） 订阅和副作用（Subscriptions and Side Effects）The second most common type of mixins that we encountered are mixins that subscribe a React component to a third-party data source. Whether this data source is a Flux Store, an Rx Observable, or something else, the pattern is very similar: the subscription is created in componentDidMount, destroyed in componentWillUnmount, and the change handler calls this.setState(). 我们遇到的第二种最常见的混合类型是将 React 组件订阅到第三方数据源的 mixins 。无论此数据源是 Flux Store，Rx Observable 还是其他内容，这些模式非常相似：在 componentDidMount 中创建订阅，在 componentWillUnmount 中销毁，调用 this.setState() 更改。 var SubscriptionMixin = &#123; getInitialState: function() &#123; return &#123; comments: DataSource.getComments() &#125;; &#125;, componentDidMount: function() &#123; DataSource.addChangeListener(this.handleChange); &#125;, componentWillUnmount: function() &#123; DataSource.removeChangeListener(this.handleChange); &#125;, handleChange: function() &#123; this.setState(&#123; comments: DataSource.getComments() &#125;); &#125;&#125;;var CommentList = React.createClass(&#123; mixins: [SubscriptionMixin], render: function() &#123; // Reading comments from state managed by mixin. var comments = this.state.comments; return ( &lt;div&gt; &#123;comments.map(function(comment) &#123; return &lt;Comment comment=&#123;comment&#125; key=&#123;comment.id&#125; /&gt; &#125;)&#125; &lt;/div&gt; ) &#125;&#125;);module.exports = CommentList; 解决方案If there is just one component subscribed to this data source, it is fine to embed the subscription logic right into the component. Avoid premature abstractions. 如果只有一个组件订阅该数据源，将订阅逻辑嵌入到组件中是很好的。避免过早抽象。 If several components used this mixin to subscribe to a data source, a nice way to avoid repetition is to use a pattern called “higher-order components”. It can sound intimidating so we will take a closer look at how this pattern naturally emerges from the component model. 如果几个组件使用这个 mixin 来订阅数据源，避免重复的一个好方法是使用一个称为 高阶组件 的模式。它听起来很吓人，所以我们将仔细看看这个模式如何从组件模型中自然出现。 高阶组件说明(Higher-Order Components Explained)Let’s forget about React for a second. Consider these two functions that add and multiply numbers, logging the results as they do that: 让我们暂时先忘记 React。考虑这两个函数，它们做加法和乘法，并打印日志记录结果： function addAndLog(x, y) &#123; var result = x + y; console.log(&#x27;result:&#x27;, result); return result;&#125;function multiplyAndLog(x, y) &#123; var result = x * y; console.log(&#x27;result:&#x27;, result); return result;&#125; These two functions are not very useful but they help us demonstrate a pattern that we can later apply to components. 这两个功能并不是非常有用，但它们可以帮助我们展示给我们可以应用于组件的模式。 Let’s say that we want to extract the logging logic out of these functions without changing their signatures. How can we do this? An elegant solution is to write a higher-order function, that is, a function that takes a function as an argument and returns a function. 假设我们想从这些函数中提取记录逻辑，而不改变它们的签名。我们该怎么做呢？一个优雅的解决方案是写一个 高阶函数，即一个将一个函数作为一个参数并返回一个函数的高级函数。 Again, it sounds more intimidating than it really is: 这次，听起来更吓人： function withLogging(wrappedFunction) &#123; // Return a function with the same API... return function(x, y) &#123; // ... that calls the original function var result = wrappedFunction(x, y); // ... but also logs its result! console.log(&#x27;result:&#x27;, result); return result; &#125;;&#125; The withLogging higher-order function lets us write add and multiply without the logging statements, and later wrap them to get addAndLog and multiplyAndLog with exactly the same signatures as before: withLogging 高阶函数可以让我们在没有日志记录语句的情况下编写加法和乘法，然后将它们打包成与以前完全相同的签名来获取 addAndLog 和 multiplyAndLog： function add(x, y) &#123; return x + y;&#125;function multiply(x, y) &#123; return x * y;&#125;function withLogging(wrappedFunction) &#123; return function(x, y) &#123; var result = wrappedFunction(x, y); console.log(&#x27;result:&#x27;, result); return result; &#125;;&#125;// Equivalent to writing addAndLog by hand:// 等价于之前手写的 addAndLog 函数var addAndLog = withLogging(add);// Equivalent to writing multiplyAndLog by hand:// 等价于之前手写的 multiplyAndLog 函数var multiplyAndLog = withLogging(multiply); Higher-order components are a very similar pattern, but applied to components in React. We will apply this transformation from mixins in two steps. 高阶组件是非常相似的模式，但是应用于 React 中的组件。我们将从两个步骤中从 mixins 中应用这个转换。 As a first step, we will split our CommentList component in two, a child and a parent. The child will be only concerned with rendering the comments. The parent will set up the subscription and pass the up-to-date data to the child via props. 第一步，我们将把我们的 CommentList 组件分成两部分，一个子组件和一个父组件。子组件只会关注渲染评论。父母将设置订阅，并通过 props 将最新数据传递给子组件。 // This is a child component.// It only renders the comments it receives as props.var CommentList = React.createClass(&#123; render: function() &#123; // Note: now reading from props rather than state. var comments = this.props.comments; return ( &lt;div&gt; &#123;comments.map(function(comment) &#123; return &lt;Comment comment=&#123;comment&#125; key=&#123;comment.id&#125; /&gt; &#125;)&#125; &lt;/div&gt; ) &#125;&#125;);// This is a parent component.// It subscribes to the data source and renders &lt;CommentList /&gt;.var CommentListWithSubscription = React.createClass(&#123; getInitialState: function() &#123; return &#123; comments: DataSource.getComments() &#125;; &#125;, componentDidMount: function() &#123; DataSource.addChangeListener(this.handleChange); &#125;, componentWillUnmount: function() &#123; DataSource.removeChangeListener(this.handleChange); &#125;, handleChange: function() &#123; this.setState(&#123; comments: DataSource.getComments() &#125;); &#125;, render: function() &#123; // We pass the current state as props to CommentList. return &lt;CommentList comments=&#123;this.state.comments&#125; /&gt;; &#125;&#125;);module.exports = CommentListWithSubscription; There is just one final step left to do. 只剩最后一步。 Remember how we made withLogging() take a function and return another function wrapping it? We can apply a similar pattern to React components. 还记得我们用 withLogging() 接收一个函数并返回一个包装它的函数吗？我们可以将类似的模式应用于 React 组件。 We will write a new function called withSubscription(WrappedComponent). Its argument could be any React component. We will pass CommentList as WrappedComponent, but we could also apply withSubscription() to any other component in our codebase. 我们将编写一个名为 withSubscription(WrappedComponent) 的新函数。它的参数可以是任何 React 组件。我们将传递 CommentList 作为WrappedComponent（被包装得组件），但是我们也可以将它们应用于我们的代码库中的任何其他组件。 This function would return another component. The returned component would manage the subscription and render &lt;WrappedComponent /&gt; with the current data. 此函数将返回另一个组件。返回的组件将管理订阅并使用当前数据渲染 &lt;WrappedComponent /&gt;。 We call this pattern a “higher-order component”. 我们把这个模式叫做高阶组件。 The composition happens at React rendering level rather than with a direct function call. This is why it doesn’t matter whether the wrapped component is defined with createClass(), as an ES6 class or a function. If WrappedComponent is a React component, the component created by withSubscription() can render it. 组合发生在 React 渲染级别，而不是直接调用函数。这就是为什么被包装组件或者用 createClass() 定义的，或者 ES6 类或是函数式组件是毫无关系。如果 WrappedComponent 是一个 React 组件，则使用 withSubscription() 创建的组件都可以可以渲染它。 // This function takes a component...function withSubscription(WrappedComponent) &#123; // ...and returns another component... return React.createClass(&#123; getInitialState: function() &#123; return &#123; comments: DataSource.getComments() &#125;; &#125;, componentDidMount: function() &#123; // ... that takes care of the subscription... DataSource.addChangeListener(this.handleChange); &#125;, componentWillUnmount: function() &#123; DataSource.removeChangeListener(this.handleChange); &#125;, handleChange: function() &#123; this.setState(&#123; comments: DataSource.getComments() &#125;); &#125;, render: function() &#123; // ... and renders the wrapped component with the fresh data! return &lt;WrappedComponent comments=&#123;this.state.comments&#125; /&gt;; &#125; &#125;);&#125; Now we can declare CommentListWithSubscription by applying withSubscription to CommentList: 现在我们可以通过将 withSubscription 应用于 CommentList 来声明 CommentListWithSubscription： var CommentList = React.createClass(&#123; render: function() &#123; var comments = this.props.comments; return ( &lt;div&gt; &#123;comments.map(function(comment) &#123; return &lt;Comment comment=&#123;comment&#125; key=&#123;comment.id&#125; /&gt; &#125;)&#125; &lt;/div&gt; ) &#125;&#125;);// withSubscription() returns a new component that// is subscribed to the data source and renders// &lt;CommentList /&gt; with up-to-date data.var CommentListWithSubscription = withSubscription(CommentList);// The rest of the app is interested in the subscribed component// so we export it instead of the original unwrapped CommentList.module.exports = CommentListWithSubscription; 已解决，再次回顾一下（Solution, Revisited）Now that we understand higher-order components better, let’s take another look at the complete solution that doesn’t involve mixins. There are a few minor changes that are annotated with inline comments: 现在我们更好地了解了高阶组件，让我们再来看一下不涉及 mixins 的完整解决方案。有一些小的更改用内联注释说明： function withSubscription(WrappedComponent) &#123; return React.createClass(&#123; getInitialState: function() &#123; return &#123; comments: DataSource.getComments() &#125;; &#125;, componentDidMount: function() &#123; DataSource.addChangeListener(this.handleChange); &#125;, componentWillUnmount: function() &#123; DataSource.removeChangeListener(this.handleChange); &#125;, handleChange: function() &#123; this.setState(&#123; comments: DataSource.getComments() &#125;); &#125;, render: function() &#123; // Use JSX spread syntax to pass all props and state down automatically. return &lt;WrappedComponent &#123;...this.props&#125; &#123;...this.state&#125; /&gt;; &#125; &#125;);&#125;// Optional change: convert CommentList to a functional component// because it doesn&#x27;t use lifecycle hooks or state.function CommentList(props) &#123; var comments = props.comments; return ( &lt;div&gt; &#123;comments.map(function(comment) &#123; return &lt;Comment comment=&#123;comment&#125; key=&#123;comment.id&#125; /&gt; &#125;)&#125; &lt;/div&gt; )&#125;// Instead of declaring CommentListWithSubscription,// we export the wrapped component right away.module.exports = withSubscription(CommentList); Higher-order components are a powerful pattern. You can pass additional arguments to them if you want to further customize their behavior. After all, they are not even a feature of React. They are just functions that receive components and return components that wrap them. 高阶组件是一个强大的模式。如果你想进一步自定义它们的行为，你可以向它们传递其他参数。毕竟，他们甚至不是React的一个特征。它们只是接收组件并返回包装组件的函数。 Like any solution, higher-order components have their own pitfalls. For example, if you heavily use refs, you might notice that wrapping something into a higher-order component changes the ref to point to the wrapping component. In practice we discourage using refs for component communication so we don’t think it’s a big issue. In the future, we might consider adding ref forwarding to React to solve this annoyance. 像任何解决方案一样，高阶组件都有自己的缺陷。例如，如果你大量使用 refs（推荐本人另一篇文章：React - Refs），你可能会注意到，将某些内容包装到更高阶的组件中会将 ref 更改为指向包装组件。实际上，我们不鼓励使用 ref 进行组件通信，所以我们不认为这是一个大问题。在将来，我们可能会考虑添加ref 转发 到 React 来解决这个烦恼。 渲染逻辑(Rendering Logic)The next most common use case for mixins that we discovered in our codebase is sharing rendering logic between components. 我们在代码库中发现的 mixins 的另一个最常见的用例是在组件之间共享渲染逻辑。 Here is a typical example of this pattern: 以下是此模式的典型示例： var RowMixin = &#123; // Called by components from render() renderHeader: function() &#123; return ( &lt;div className=&#x27;row-header&#x27;&gt; &lt;h1&gt; &#123;this.getHeaderText() /* Defined by components */&#125; &lt;/h1&gt; &lt;/div&gt; ); &#125;&#125;;var UserRow = React.createClass(&#123; mixins: [RowMixin], // Called by RowMixin.renderHeader() getHeaderText: function() &#123; return this.props.user.fullName; &#125;, render: function() &#123; return ( &lt;div&gt; &#123;this.renderHeader() /* Defined by RowMixin */&#125; &lt;h2&gt;&#123;this.props.user.biography&#125;&lt;/h2&gt; &lt;/div&gt; ) &#125;&#125;); Multiple components may be sharing RowMixin to render the header, and each of them would need to define getHeaderText(). 多个组件可能共享 RowMixin 来渲染头部，并且每个组件都需要定义 getHeaderText()。 解决方案If you see rendering logic inside a mixin, it’s time to extract a component! 如果你在 mixin 中看到渲染逻辑，现在是时候提取组件了！ Instead of RowMixin, we will define a &lt;RowHeader&gt; component. We will also replace the convention of defining a getHeaderText() method with the standard mechanism of top-data flow in React: passing props. 与使用 RowMixin 相比，我们将定义一个 &lt;RowHeader&gt; 组件。我们还将使用 React 中的顶级数据流（props）的标准机制来替换定义 getHeaderText() 方法。 Finally, since neither of those components currently need lifecycle hooks or state, we can declare them as simple functions: 最后，既然这些组件当前都不需要生命周期钩子或 state，我们可以将它们声明为简单的函数式组件： function RowHeader(props) &#123; return ( &lt;div className=&#x27;row-header&#x27;&gt; &lt;h1&gt;&#123;props.text&#125;&lt;/h1&gt; &lt;/div&gt; );&#125;function UserRow(props) &#123; return ( &lt;div&gt; &lt;RowHeader text=&#123;props.user.fullName&#125; /&gt; &lt;h2&gt;&#123;props.user.biography&#125;&lt;/h2&gt; &lt;/div&gt; );&#125; Props keep component dependencies explicit, easy to replace, and enforceable with tools like Flow and TypeScript. Props使组件依赖性保持明确，易于替换，并可通过 Flow 和 TypeScript 等工具强制执行。 Note:Defining components as functions is not required. There is also nothing wrong with using lifecycle hooks and state—they are first-class React features. We use functional components in this example because they are easier to read and we didn’t need those extra features, but classes would work just as fine. 注意：定义组件为函数式组件并不是必须的。使用生命周期钩子和 state 也没有错，他们是一流的 React 功能。我们在这个例子中使用函数式组件，因为它们更容易阅读，并且我们不需要这些额外的功能，当然使用类组件也可以正常工作。 上下文（Context）Another group of mixins we discovered were helpers for providing and consuming React context. Context is an experimental unstable feature, has certain issues, and will likely change its API in the future. We don’t recommend using it unless you’re confident there is no other way of solving your problem. 我们发现的另一组 mixin 是提供和消费 React context（推荐本人另一篇总结React - Context） 的帮助者。上下文是一个实验性的不稳定特征，具有一定的问题，并且将来可能会改变其 API。我们不建议使用它，除非你确信没有其他方法来解决你的问题。 Nevertheless, if you already use context today, you might have been hiding its usage with mixins like this: 然而，如果你已经使用了上下文，那么你可能已经用这样的 mixins 隐藏了它的使用： var RouterMixin = &#123; contextTypes: &#123; router: React.PropTypes.object.isRequired &#125;, // The mixin provides a method so that components // don&#x27;t have to use the context API directly. // mixin 提供了一个方法，确保组件不必直接操作 context 的 API push: function(path) &#123; this.context.router.push(path) &#125;&#125;;var Link = React.createClass(&#123; mixins: [RouterMixin], handleClick: function(e) &#123; e.stopPropagation(); // This method is defined in RouterMixin. this.push(this.props.to); &#125;, render: function() &#123; return ( &lt;a onClick=&#123;this.handleClick&#125;&gt; &#123;this.props.children&#125; &lt;/a&gt; ); &#125;&#125;);module.exports = Link; 解决方案We agree that hiding context usage from consuming components is a good idea until the context API stabilizes. However, we recommend using higher-order components instead of mixins for this. 我们认同在 Context API 稳定之前，隐藏使用组件 Context API 是一个好主意。但是，我们建议使用更高阶的组件而不是 mixins。 Let the wrapping component grab something from the context, and pass it down with props to the wrapped component: 让包装组件从 context 中抓取东西，并使用 props 将其传递给被包装组件： function withRouter(WrappedComponent) &#123; return React.createClass(&#123; contextTypes: &#123; router: React.PropTypes.object.isRequired &#125;, render: function() &#123; // The wrapper component reads something from the context // and passes it down as a prop to the wrapped component. var router = this.context.router; return &lt;WrappedComponent &#123;...this.props&#125; router=&#123;router&#125; /&gt;; &#125; &#125;);&#125;;var Link = React.createClass(&#123; handleClick: function(e) &#123; e.stopPropagation(); // The wrapped component uses props instead of context. this.props.router.push(this.props.to); &#125;, render: function() &#123; return ( &lt;a onClick=&#123;this.handleClick&#125;&gt; &#123;this.props.children&#125; &lt;/a&gt; ); &#125;&#125;);// Don&#x27;t forget to wrap the component!module.exports = withRouter(Link); If you’re using a third party library that only provides a mixin, we encourage you to file an issue with them linking to this post so that they can provide a higher-order component instead. In the meantime, you can create a higher-order component around it yourself in exactly the same way. 如果你正在使用仅提供 mixin 的第三方库，我们建议你提交链接到此帖子的问题，以便他们可以提供更高级的组件。在此期间，你可以以完全相同的方式在其周围创建高阶组件。 功能方法(Utility Methods)Sometimes, mixins are used solely to share utility functions between components: 有时，mixins 仅用于在组件之间共享功能函数： var ColorMixin = &#123; getLuminance(color) &#123; var c = parseInt(color, 16); var r = (c &amp; 0xFF0000) &gt;&gt; 16; var g = (c &amp; 0x00FF00) &gt;&gt; 8; var b = (c &amp; 0x0000FF); return (0.299 * r + 0.587 * g + 0.114 * b); &#125;&#125;;var Button = React.createClass(&#123; mixins: [ColorMixin], render: function() &#123; var theme = this.getLuminance(this.props.color) &gt; 160 ? &#x27;dark&#x27; : &#x27;light&#x27;; return ( &lt;div className=&#123;theme&#125;&gt; &#123;this.props.children&#125; &lt;/div&gt; ) &#125;&#125;); 解决方案Put utility functions into regular JavaScript modules and import them. This also makes it easier to test them or use them outside of your components: 将功能程序函数放入常规的 JavaScript 模块并导入。这也使得更容易测试它们或在组件之外使用它们： var getLuminance = require(&#x27;../utils/getLuminance&#x27;);var Button = React.createClass(&#123; render: function() &#123; var theme = getLuminance(this.props.color) &gt; 160 ? &#x27;dark&#x27; : &#x27;light&#x27;; return ( &lt;div className=&#123;theme&#125;&gt; &#123;this.props.children&#125; &lt;/div&gt; ) &#125;&#125;); 其他使用案例（Other Use Cases）Sometimes people use mixins to selectively add logging to lifecycle hooks in some components. In the future, we intend to provide an official DevTools API that would let you implement something similar without touching the components. However it’s still very much a work in progress. If you heavily depend on logging mixins for debugging, you might want to keep using those mixins for a little longer. 有时，人们使用 mixins 来选择性地将日志记录添加到某些组件中的生命周期钩子中。在将来，我们打算提供一个官方的 official DevTools API，可以让你实现类似的操作，而不必触及组件。然而，这仍然是一项正在进行的工作。如果你严重依赖日志 mixins 来进行调试，那么你可能希望继续使用这些混合。 If you can’t accomplish something with a component, a higher-order component, or a utility module, it could be mean that React should provide this out of the box. File an issue to tell us about your use case for mixins, and we’ll help you consider alternatives or perhaps implement your feature request. 如果你无法使用组件，高阶组件或功能模块完成某些操作，则可能意味着 React 应提供额外的操作。在此提出问题，告诉我们你的关于 mixins 的用例，我们将帮助你考虑你的功能请求的替代方案，或者可能的实现方案。 Mixins are not deprecated in the traditional sense. You can keep using them with React.createClass(), as we won’t be changing it further. Eventually, as ES6 classes gain more adoption and their usability problems in React are solved, we might split React.createClass() into a separate package because most people wouldn’t need it. Even in that case, your old mixins would keep working. Mixins 在传统场景下并不过期。你任然可以通过使用 React.createClass() 继续使用它们，因为我们不会进一步改变它们。最终，随着 ES6 类得到更多的采用，在 React 中的可用性问题得到解决，我们可能将 React.createClass() 分解成一个单独的包，因为大多数人不需要它。即使在这种情况下，你的旧的 mixins 也会继续工作。 We believe that the alternatives above are better for the vast majority of cases, and we invite you to try writing React apps without using mixins. 我们认为，在绝大多数情况下，上述替代方案更好，我们邀请你尝试在不使用 mixins 的情况下编写 React 应用程序。","categories":[{"name":"翻译","slug":"翻译","permalink":"http://tcatche.site/categories/%E7%BF%BB%E8%AF%91/"}],"tags":[{"name":"react","slug":"react","permalink":"http://tcatche.site/tags/react/"},{"name":"翻译","slug":"翻译","permalink":"http://tcatche.site/tags/%E7%BF%BB%E8%AF%91/"}]},{"title":"React - 高阶组件（Higher-Order Components）","slug":"react-higher-order-components","date":"2017-07-21T07:15:00.000Z","updated":"2020-07-22T02:19:41.783Z","comments":true,"path":"2017/07/react-higher-order-components/","link":"","permalink":"http://tcatche.site/2017/07/react-higher-order-components/","excerpt":"","text":"原文：Higher-Order Components 高阶组件（HOC）是 React 中用于重用组件逻辑的高级技术。 HOC 本身不是 React API的一部分。它们是从 React 的组合特性产生的一种模式。 具体来说，高阶组件就是一个接受一个组件作为参数，并返回一个新组件的函数。 const EnhancedComponent = higherOrderComponent(WrappedComponent); 就如组件将 props 转换为 UI ，高阶组件将一个组件转换为另一个组件。 HOC 在第三方 React 库中很常见，例如 Redux 的 connect 和Relay的 createContainer。 在这篇文章，我们讨论为什么高阶组件很有用并且怎样写高阶组件。 使用 HOC 来解决交叉问题 我们以前建议将 mixins 作为处理交叉问题的方法。我们已经意识到，比他们的价值，mixins 创造更多的麻烦。阅读了解 为什么我们离开 mixins，以及如何转换现有组件。 组件是 React 中代码复用的重要单元。但是，你会发现某些模式并不适合传统组件。 例如，假设你有一个 CommentList 组件订阅了外部数据源渲染评论的列表： class CommentList extends React.Component &#123; constructor() &#123; super(); this.handleChange = this.handleChange.bind(this); this.state = &#123; // &quot;DataSource&quot; is some global data source comments: DataSource.getComments() &#125;; &#125; componentDidMount() &#123; // Subscribe to changes DataSource.addChangeListener(this.handleChange); &#125; componentWillUnmount() &#123; // Clean up listener DataSource.removeChangeListener(this.handleChange); &#125; handleChange() &#123; // Update component state whenever the data source changes this.setState(&#123; comments: DataSource.getComments() &#125;); &#125; render() &#123; return ( &lt;div&gt; &#123;this.state.comments.map((comment) =&gt; ( &lt;Comment comment=&#123;comment&#125; key=&#123;comment.id&#125; /&gt; ))&#125; &lt;/div&gt; ); &#125;&#125; 然后，又编写一个订阅博客文章的组件，它有着类似的模式： class BlogPost extends React.Component &#123; constructor(props) &#123; super(props); this.handleChange = this.handleChange.bind(this); this.state = &#123; blogPost: DataSource.getBlogPost(props.id) &#125;; &#125; componentDidMount() &#123; DataSource.addChangeListener(this.handleChange); &#125; componentWillUnmount() &#123; DataSource.removeChangeListener(this.handleChange); &#125; handleChange() &#123; this.setState(&#123; blogPost: DataSource.getBlogPost(this.props.id) &#125;); &#125; render() &#123; return &lt;TextBlock text=&#123;this.state.blogPost&#125; /&gt;; &#125;&#125; CommentList 和 BlogPost 不一样，它们调用 DataSource 上的不同方法，渲染不同的输出，但是它们的大部分实现实现相同的： 在组件挂载的时候绑定监听数据源 DataSource 变化的事件监听器。 在监听器内部，当数据源发生变化的时候调用 setState。 在组件卸载的时候，一出这个监听器。 你可以想象，在一个大型的应用程序中，这种订阅 DataSource 和调用 setState 的模式会多次发生。我们想要一个抽象的组件，允许我们定义这种逻辑，并将它们分享到许多组件，这就是高阶组件的优点。 我们可以写一个函数创建像 CommentList 和 BlogPost 这样订阅 DataSource 的组件，这个参数接收一个. 这个函数接收一个子组件作为其第一个参数参数，这个子组件接收订阅的数据为 prop ，我们给这个函数命名为 withSubscription： const CommentListWithSubscription = withSubscription( CommentList, (DataSource) =&gt; DataSource.getComments());const BlogPostWithSubscription = withSubscription( BlogPost, (DataSource, props) =&gt; DataSource.getBlogPost(props.id)); 第一个参数是被包装的组件，第二个参数通过提供 DataSource 和当前的 props 可以获得我们感兴趣的数据。 当 CommentListWithSubscription 和 BlogPostWithSubscription 被渲染，CommentList 和 BlogPost 将会被传入一个使用当前的 DataSource 获取到的 data 的 prop： // This function takes a component...function withSubscription(WrappedComponent, selectData) &#123; // ...and returns another component... return class extends React.Component &#123; constructor(props) &#123; super(props); this.handleChange = this.handleChange.bind(this); this.state = &#123; data: selectData(DataSource, props) &#125;; &#125; componentDidMount() &#123; // ... that takes care of the subscription... DataSource.addChangeListener(this.handleChange); &#125; componentWillUnmount() &#123; DataSource.removeChangeListener(this.handleChange); &#125; handleChange() &#123; this.setState(&#123; data: selectData(DataSource, this.props) &#125;); &#125; render() &#123; // ... and renders the wrapped component with the fresh data! // Notice that we pass through any additional props return &lt;WrappedComponent data=&#123;this.state.data&#125; &#123;...this.props&#125; /&gt;; &#125; &#125;;&#125; 注意，HOC 并不会修改输入组件，也不会使用继承来复制其行为。相反，HOC 通过将原始组件 包装 在容器组件中来组合， HOC 是一种具有零副作用的纯函数。 就是这样！包装的组件接收容器的所有属性 ，以及用于渲染其输出的新属性 data。 HOC不关心数据怎样使用或为什么使用，被包装的组件不关心数据来自哪里。 正因为 withSubscription 是一个普通的功能，你可以添加任意数量的参数。例如，你可能希望使 data 属性的名称可配置，以进一步隔离 HOC 与包装组件。或者你可以接受配置 shouldComponentUpdate 或配置数据源的参数。这些都是可能的，因为 HOC 完全控制包装后组件的定义。 与组件一样，withSubscription 与包装组件之间的联系完全是基于 props 的。这样可以轻松地将一个 HOC 换成不同的 HOC，只要它们为包装的组件提供相同的 props。例如，更改数据获取库，这很有用。 不要突变原始组件，使用组合代替抵制在 HOC 内部修改组件原型（或以其他方式突变组件）的诱惑。 function logProps(InputComponent) &#123; InputComponent.prototype.componentWillReceiveProps = function(nextProps) &#123; console.log(&#x27;Current props: &#x27;, this.props); console.log(&#x27;Next props: &#x27;, nextProps); &#125;; // The fact that we&#x27;re returning the original input is a hint that it has // been mutated. return InputComponent;&#125;// EnhancedComponent will log whenever props are receivedconst EnhancedComponent = logProps(InputComponent); 这样做有几个问题。一个是输入组件不能与增强组件分开使用。更重要的是, 如果你应用另一个 HOC 去 增强组件，而其也改变了 componentWillReceiveProps，则第一个 HOC 的功能将被覆盖。同时，这样的 HOC 也不能工作在没有生命周期方法的函数式组件上。 这类突变的 HOC 是一个很低层级的抽象，消费者必须知道它们是如何实现的, 以避免与其他的 HOC 发生冲突。 和突变相比较，HOC 应使用组合, 将输入组件包装在容器组件中： function logProps(WrappedComponent) &#123; return class extends React.Component &#123; componentWillReceiveProps(nextProps) &#123; console.log(&#x27;Current props: &#x27;, this.props); console.log(&#x27;Next props: &#x27;, nextProps); &#125; render() &#123; // Wraps the input component in a container, without mutating it. Good! return &lt;WrappedComponent &#123;...this.props&#125; /&gt;; &#125; &#125;&#125; 这个 HOC 具有与突变版本相同的功能，同时可以避免发生冲突。它与类和函数组件同样兼容。而且因为它是一个纯函数，它可以与其他 HOC ，甚至与它自己组合。 你可能已经注意到 HOC 和称为 容器组件 的模式之间的相似。容器组件是将职责分离到高级别和低级别关注点的策略的一部分。容器管理诸如订阅和状态的东西，并将道具传递给处理诸如渲染UI之类的组件。 HOC 使用容器作为其实现的一部分。你可以将 HOC 作为参数化容器组件定义。 约定：跳过不相关的 props ，直接将其传递给被包裹的组件HOC 向组件添加功能。他们不应该大幅改变其接收的对象，并期望从 HOC 返回的组件与被包装的组件具有相似的界面。 HOC 应跳过与其无关的 props，大多数 HOC 包含一个看起来如下的渲染方法： render() &#123; // Filter out extra props that are specific to this HOC and shouldn&#x27;t be // passed through // 过滤出被指定给 HOC 使用的额外的 props 和 HOC 应当跳过的 props const &#123; extraProp, ...passThroughProps &#125; = this.props; // Inject props into the wrapped component. These are usually state values or // instance methods. const injectedProp = someStateOrInstanceMethod; // Pass props to wrapped component return ( &lt;WrappedComponent injectedProp=&#123;injectedProp&#125; &#123;...passThroughProps&#125; /&gt; );&#125; 这个约定有助于确保HOC尽可能灵活和可重用。 约定：最大化组合不是所有的 HOC 看起来都一样。有时候，他们只接受一个参数：包装组件。 const NavbarWithRouter = withRouter(Navbar); 通常，HOC 接受额外参数。在 Relay 的这个例子中，配置对象用于指定组件的数据依赖关系： const CommentWithRelay = Relay.createContainer(Comment, config); HOC最常见的签名如下所示： // React Redux&#x27;s `connect`const ConnectedComment = connect(commentSelector, commentActions)(Comment); 如果你把它分开了，那就更容易看到发生了什么。 // connect is a function that returns another functionconst enhance = connect(commentListSelector, commentListActions);// The returned function is an HOC, which returns a component that is connected// to the Redux storeconst ConnectedComment = enhance(CommentList); 换句话说， connect 是一个高阶函数，返回一个高阶组件。 这张表可能看起来很混乱或不必要，但它有一个有用的属性。单参数的 HOC 像由 connect 函数返回的一样有签名 Component =&gt; Component. 输出类型与输入类型相同的函数很容易组合在一起。 // Instead of doing this...const EnhancedComponent = connect(commentSelector)(withRouter(WrappedComponent))// ... you can use a function composition utility// compose(f, g, h) is the same as (...args) =&gt; f(g(h(...args)))const enhance = compose( // These are both single-argument HOCs connect(commentSelector), withRouter)const EnhancedComponent = enhance(WrappedComponent) （同样的属性也允许 connect 和其他增强型 HOC 用作装饰器，装饰器是一个实验性 JavaScript 提案）。 组合（compose） 工具被很多第三方库提供，包括 lodash (as lodash.flowRight)、 Redux 和 Ramda. 约定：包装 displayName 方便调试由 HOC 创建的容器组件与其他组件一样显示在 React Developer Tools 中。为了方便调试，选择一个显示名称（displayName），通知它是 HOC 的结果。 常见的命名方式是用 HOC 的名字包裹被包装组件的显示名称。因此，如果你的高阶组件以 withSubscription 命名，包装组件的显示名称为 CommentList，使用显示名称 WithSubscription(CommentList): function withSubscription(WrappedComponent) &#123; class WithSubscription extends React.Component &#123;/* ... */&#125; WithSubscription.displayName = `WithSubscription($&#123;getDisplayName(WrappedComponent)&#125;)`; return WithSubscription;&#125;function getDisplayName(WrappedComponent) &#123; return WrappedComponent.displayName || WrappedComponent.name || &#x27;Component&#x27;;&#125; 注意事项高阶组件有几个注意事项，如果你是React的新手，可能不会注意到。 不要在渲染方法中使用 HOCReact 的 diff 算法 (被称为 reconciliation) 使用组件标识来确定它是应该更新现有的子树还是将其丢弃并挂载一个新的。 如果 render 函数返回的组件和上一次渲染的组件是绝对相等的(===) ， React 通过和新的子树比较来递归更新子树。如果它们不相等，则先前的子树将被完全卸载。 通常，你不需要考虑这个。但是对于HOC来说重要，因为这意味着你不能在组件的 render 方法中将 HOC 应用于组件： render() &#123; // A new version of EnhancedComponent is created on every render // EnhancedComponent1 !== EnhancedComponent2 // 每次渲染都被创建一个新的 EnhancedComponent // EnhancedComponent1 !== EnhancedComponent2 const EnhancedComponent = enhance(MyComponent); // That causes the entire subtree to unmount/remount each time! // 这会导致整个子树每次卸载/重新挂载！ return &lt;EnhancedComponent /&gt;;&#125; 这个问题不仅是性能的问题，重新挂载组件会导致该组件及其所有子项的状态丢失。 相反，将 HOC 应用于组件定义之外，以便生成的组件只能创建一次。这样，它的标识在渲染中是一致的，这正是是你想要的。 在需要动态应用 HOC 的罕见情况下，你还可以在组件的生命周期方法或其构造函数中执行此操作。 静态方法必须复制有时，在 React 组件上定义一个静态方法很有用。例如，中继容器暴露了一个静态方法 getFragment，以便于构建 GraphQL 片段。 当你将 HOC 应用于组件时，原始组件将以容器组件包装。这意味着新组件没有原始组件的任何静态方法。 // Define a static methodWrappedComponent.staticMethod = function() &#123;/*...*/&#125;// Now apply an HOCconst EnhancedComponent = enhance(WrappedComponent);// The enhanced component has no static methodtypeof EnhancedComponent.staticMethod === &#x27;undefined&#x27; // true To solve this, you could copy the methods onto the container before returning it: 要解决这个问题，你可以在返回之前将该方法复制到容器上： function enhance(WrappedComponent) &#123; class Enhance extends React.Component &#123;/*...*/&#125; // Must know exactly which method(s) to copy :( Enhance.staticMethod = WrappedComponent.staticMethod; return Enhance;&#125; 但是，这需要你准确地知道哪些方法需要复制。你可以使用 hoist-non-react-statics 来自动复制所有非 React 的静态方法： import hoistNonReactStatic from &#x27;hoist-non-react-statics&#x27;;function enhance(WrappedComponent) &#123; class Enhance extends React.Component &#123;/*...*/&#125; hoistNonReactStatic(Enhance, WrappedComponent); return Enhance;&#125; 另一个可能的解决方案是将静态方法与组件本身分开导出。 // Instead of...MyComponent.someFunction = someFunction;export default MyComponent;// ...export the method separately...export &#123; someFunction &#125;;// ...and in the consuming module, import bothimport MyComponent, &#123; someFunction &#125; from &#x27;./MyComponent.js&#x27;; Refs 没有通过虽然高阶组件是通过传递所有的 props 到被包装的组件，但是不可能传递 refs 属性。因为 refs 和 key 一样并不是真正的属性，它是由 React 特别处理的。如果你添加一个 ref 引用到 HOC 产生的组件上，则 ref 将引用最外层的容器组件的实例，而不是被包装的组件。 如果你发现自己面临这个问题，理想的解决方案是找出如何避免使用 ref。有时候，React 新手的用户依赖 refs，在这种情况下，有 prop 会更好地工作。 也就是说，有些时候，refs 是必要的“逃生舱口”——然而 React 不会提供支持。input 元素获得焦点是命令式控制组件的一个示例。在这种情况下，一个解决方案是传递一个 ref 回调作为一个普通的 prop ，给它一个不同的名字： function Field(&#123; inputRef, ...rest &#125;) &#123; return &lt;input ref=&#123;inputRef&#125; &#123;...rest&#125; /&gt;;&#125;// Wrap Field in a higher-order componentconst EnhancedField = enhance(Field);// Inside a class component&#x27;s render method...&lt;EnhancedField inputRef=&#123;(inputEl) =&gt; &#123; // This callback gets passed through as a regular prop this.inputEl = inputEl &#125; &#125;/&gt;// Now you can call imperative methodsthis.inputEl.focus(); This is not a perfect solution by any means. We prefer that refs remain a library concern, rather than require you to manually handle them. We are exploring ways to solve this problem so that using an HOC is unobservable. 这不是一个完美的解决办法。我们正在探索解决这个问题的方法，以便使用 HOC 是不可观察的。","categories":[{"name":"翻译","slug":"翻译","permalink":"http://tcatche.site/categories/%E7%BF%BB%E8%AF%91/"}],"tags":[{"name":"react","slug":"react","permalink":"http://tcatche.site/tags/react/"},{"name":"翻译","slug":"翻译","permalink":"http://tcatche.site/tags/%E7%BF%BB%E8%AF%91/"}]},{"title":"关于文档加载状态相关的事件探讨","slug":"dom_load_status_events","date":"2017-07-14T07:46:00.000Z","updated":"2018-08-01T10:41:24.000Z","comments":true,"path":"2017/07/dom_load_status_events/","link":"","permalink":"http://tcatche.site/2017/07/dom_load_status_events/","excerpt":"","text":"在开发的时候，经常有些操作需要等 DOM 完成后才执行，比如为某个按钮绑定事件、为防止抖动，在页面内容加载完成后才展示页面。这里我们看一下和页面加载有关的一些事件。 window.onload在文档装载完成后会触发 onload 事件。此时，在文档中的所有对象都在 DOM 中，所有图片，脚本，链接以及子框都完成了装载。 如果在 onload 的事件函数里面，再次监听 onload 事件，那么，是不会再次触发函数的。 function addOnload(callback) &#123; if (window.addEventListener )&#123; return window.addEventListener(&quot;load&quot;, callback, false); &#125; else &#123; return window.attachEvent(&quot;onload&quot;, callback); &#125;&#125;function onload1() &#123; console.log(&quot;First onload executed.&quot;); addOnload(onload2);&#125;function onload2() &#123; console.log(&quot;Second onload not executed.&quot;); &#125;addOnload(onload1);// &quot;First onload executed.&quot; 如上，因此，对于异步加载的JS，为了保证能在 onload 里面触发，可以先判断 document.readystate === &quot;complete&quot;，如果成功，则立即执行函数： function addOnload(callback) &#123; if ( &quot;complete&quot; == document.readyState ) &#123; callback(); &#125; else if (window.addEventListener )&#123; return window.addEventListener(&quot;load&quot;, callback, false); &#125; else &#123; return window.attachEvent(&quot;onload&quot;, callback); &#125;&#125;function onload1() &#123; console.log(&quot;First onload executed.&quot;); addOnload(onload2);&#125;function onload2() &#123; console.log(&quot;Now, second onload also executed.&quot;); &#125;addOnload(onload1);// &quot;First onload executed.&quot;// &quot;Now, second onload also executed.&quot; onload 需要等所有的资源加载完成才执行，当资源过多过大时，onload 会出现比较严重的延迟问题，严重影响用户体验。 DOMContentLoaded当初始 HTML 文档被完全加载和解析时，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架完成加载。 window.onload = function () &#123; console.log(&#x27;onload 后输出&#x27;);&#125;document.addEventListener(&quot;DOMContentLoaded&quot;, function(event) &#123; console.log(&#x27;DOMContentLoaded 先输出&#x27;);&#125;);// &quot;DOMContentLoaded 先输出&quot;// &quot;onload 后输出&quot; 如果 script 标签中包含 defer，那么 HTML 文档构建不受影响，而 DOMContentLoaded 只有在 defer 脚本执行结束后才会被触发。 如果 script 标签中包含 async，则 HTML 文档构建不受影响，解析完毕后，DOMContentLoaded 触发，而不需要等待 async 脚本执行、样式表加载等等。 JQuery 等框架中的 ready 方法实际上主要就是采用 DOMContentLoaded 实现的,而 load 方法监听的是 onload 事件。 该方法在 IE 9- 以下不被支持，但是可以采用下面几节介绍的内容实现。 onreadystatechange 事件该事件提供与文档的加载状态有关的信息。支持 onreadystatechange 事件的每个对象都有一个 readyState 属性，它的属性包含以下五个值： uninitialized 尚未初始化，对象已经存在但尚未初始化。 loading 正在加载中，对象正在加载数据。 loaded 加载完毕，对象加载数据完成。 interactive 可交互，可以操作 DOM 对象了，但还没有完全加载。 complete 完成，对象已经加载完毕。 当这个属性的值变化时，document 对象上的 readystatechange 事件将被触发。如下，回调函数被执行2次：· document.onreadystatechange = function () &#123; console.log(document.readyState);&#125;// &quot;interactive&quot;// &quot;complete&quot; 如果在文档的不同状态绑定事件，可以用来模拟 onload 和 近似模拟 DOMContentLoaded 事件。 模拟 onload 事件： document.onreadystatechange = function () &#123; if (document.readyState === &quot;complete&quot;) &#123; initApplication(); &#125;&#125; 不严格情况下能模拟 DOMContentLoaded： document.onreadystatechange = function () &#123; if (document.readyState === &quot;interactive&quot;) &#123; initApplication(); &#125;&#125; 实际上 DOMContentLoaded 的执行时机是要比设置 document.readyState = &quot;interactive&quot; 晚的，大概顺序为 interactive 状态 -&gt; 运行defer 脚本和其他阻塞脚本 -&gt; DOMContentLoaded &gt; 运行 async 脚本 -&gt; complete 。具体参考document.readystate of “interactive” vs. ondomcontentloaded?因此最后一节的模拟 DOMContentLoaded 的实现并未采用这个事件来完成。 doScrollIE 还有个特有的方法 doScroll，当页面未加载完成时，该方法会报错。 document.documentElement.doScroll(&quot;left&quot;); 通过间隔调用，直到 doScroll 不再报错时，就代表 DOM 加载完成了，可以用来检测 DOM 是否加载完成。 自定义 DOMContentLoaded 事件根据上面内容可以提供一个兼容性较好的 DOMContentLoaded 实现： function domReady(fn)&#123; // 现代浏览器，支持 DOMContentLoaded 事件 if(document.addEventListener) &#123; document.addEventListener(&#x27;DOMContentLoaded&#x27;, fn, false); &#125; // IE else &#123; // 确保当页面是在iframe中加载时，事件依旧会被安全触发 document.attachEvent(&#x27;onreadystatechange&#x27;, function() &#123; // 如果此时 document 已经 load，立即执行 if(document.readyState == &#x27;complete&#x27;) &#123; document.onreadystatechange = null; fn(); &#125; &#125;); // 如果页面不在 iframe 中时，轮询调用 doScroll 方法检测 DOM 是否加载完毕 if(document.documentElement.doScroll &amp;&amp; typeof window.frameElement === &quot;undefined&quot;) &#123; try &#123; document.documentElement.doScroll(&#x27;left&#x27;); &#125; catch(error)&#123; setTimeout(arguments.callee, 20); return false; &#125;; fn(); &#125; &#125;&#125;; 更具体可以参考各个主流框架的实现 主流JS框架中DOMReady事件的实现 参考 浅谈DOMContentLoaded事件及其封装方法 document.readyState document.readystate of “interactive” vs. ondomcontentloaded? 主流JS框架中DOMReady事件的实现","categories":[{"name":"js","slug":"js","permalink":"http://tcatche.site/categories/js/"}],"tags":[{"name":"DOM","slug":"DOM","permalink":"http://tcatche.site/tags/DOM/"}]},{"title":"前端表单校验的设计思考","slug":"form-validator-design","date":"2017-07-13T07:54:00.000Z","updated":"2018-08-01T10:41:24.000Z","comments":true,"path":"2017/07/form-validator-design/","link":"","permalink":"http://tcatche.site/2017/07/form-validator-design/","excerpt":"","text":"在 Web 开发中经常需要面临表单校验的问题，通常需要前后端结合设计，本文就前端表单校验的模式进行简单的探讨。 常规的 if…else最常见的关于表单校验的方式就是 if...else 的嵌套了吧，比如我们有个表单有三个文本域：姓名、年龄和邮箱： &lt;div class=&#x27;form&#x27;&gt; &lt;div class=&quot;form-item&quot;&gt; &lt;div class=&#x27;label&#x27;&gt; &lt;span&gt;用户名：&lt;/span&gt; &lt;input id=&#x27;name&#x27; name=&#x27;用户名&#x27; type=&quot;text&quot; /&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;form-item&quot; &gt; &lt;div class=&#x27;label&#x27;&gt; &lt;span&gt;年龄：&lt;/span&gt; &lt;input id=&#x27;age&#x27; name=&#x27;年龄&#x27; type=&quot;text&quot; /&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;form-item&quot; &gt; &lt;div class=&#x27;label&#x27;&gt; &lt;span&gt;邮箱：&lt;/span&gt; &lt;input id=&#x27;mail&#x27; name=&#x27;邮箱&#x27; type=&quot;text&quot; /&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;button id=&#x27;submit&#x27; &gt;提交&lt;/button&gt; 我们需要对其进行校验，要求所有字段不能为空，年龄必须是数字切位于 0-100 之间： const isNotEmpty = value =&gt; value !== &#x27;&#x27;;const isNumber = value =&gt; /^[0-9]*$/.test(value);const isBetween = (value, min, max) =&gt; &#123; if (max === undefined) &#123; max = Number.MAX_VALUE; &#125; if (min === undefined) &#123; min = Number.MIN_VALUE; &#125; return value &gt; min &amp;&amp; value &lt; max;&#125;const isEmail = value =&gt; &#123;console.log(value);return /^\\w+([+-.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)*$/.test(value);&#125;document.getElementById(&#x27;submit&#x27;).addEventListener(&#x27;click&#x27;, validate);function validate() &#123; let eleName = document.getElementById(&#x27;name&#x27;); let eleAge = document.getElementById(&#x27;age&#x27;); let eleMail = document.getElementById(&#x27;mail&#x27;); if (!isNotEmpty(eleName.value)) &#123; alert(&#x27;姓名必须不为空&#x27;); return false; &#125; if (!isNumber(eleAge.value)) &#123; alert(&#x27;年龄必须为数字&#x27;); return false; &#125; if (!isBetween(eleAge.value, 0, 100)) &#123; alert(&#x27;年龄必须为数字&#x27;); return false; &#125; if (!isNotEmpty(eleMail.value)) &#123; alert(&#x27;邮箱不能为空&#x27;); return false; &#125; if (!isNumber(eleMail.value)) &#123; alert(&#x27;邮箱格式不正确&#x27;); return false; &#125;&#125;; 这个代码很明显，包含一大堆 if...else 语句，看起来啰里啰嗦的，如果修改规则还需要深入代码内部进行修改；复用性极差，如果还有一个表单还需要重新复制一大堆校验代码。 策略模式了解设计模式的话可以很容易想到策略模式，策略模式非常适合改写一大串的 if...else 语句。 通过策略模式该写的校验函数，结构十分清晰： function validate() &#123; // 获取form元素 let ele = document.getElementById(&#x27;formEle&#x27;); // 创建表单校验实例 let validator = new Validator(); // 编写校验配置 validator.add(ele.value, strategies); // 开始校验，并接收错误信息 let errorMsg = validator.validate() // 如果有错误信息输出，说明校验未通过 if(errorMsg !== true)&#123; alert(errorMsg) return false//阻止表单提交 &#125;&#125; 这样流程明显清晰多了，也方便复用，我们来看一下怎么实现 首先定义我们的添加校验规则的接口，对于一个值可能有多个校验函数，因此希望 strategies 是个数组，数组成员包含校验函数 validator、校验失败的错误信息 errorMsg、部分校验函数可能需要的额外参数 params： validator.add(ele.value, [&#123; validator: function, errorMsg: string, params: [parmas]&#125;, ...]); 然后就是执行的校验函数： validator.validate(); 这里我们开始实现 Validator 对象： class Validator &#123; // 缓存校验函数 _validators = [] // 缓存错误消息 _errorMsg = [] add(value, rules) &#123; for (let rule of rules) &#123; let &#123;validator, errorMsg=&#x27;&#x27;, params=[]&#125; = rule; // 使用 call 绑定校验函数所需的参数 this._validators.push(() =&gt; validator.call(null, value, ...params)); this._errorMsg.push(errorMsg); &#125; return this; // 支持链式调用 validator.add().add().add()... &#125; validate() &#123; for (let validateIndex in this._validators) &#123; let result = this._validators[validateIndex](); if (!result) &#123; return this._errorMsg[validateIndex]; &#125; &#125; return true; &#125;&#125; 调用代码： function validate()&#123; let eleName = document.getElementById(&#x27;name&#x27;); let eleAge = document.getElementById(&#x27;age&#x27;); let eleMail = document.getElementById(&#x27;mail&#x27;); let validator = new Validator(); validator.add(eleName.value, [&#123; validator: isNotEmpty, errorMsg: &#x27;姓名必须不为空&#x27; &#125;]).add(eleAge.value, [&#123; validator: isNumber, errorMsg: &#x27;年龄必须为数字&#x27; &#125;, &#123; validator: isBetween, errorMsg: &#x27;年龄必须为大于 0 并且小于 100&#x27;, params: [0, 100] &#125;]).add(eleMail.value, [&#123; validator: isNotEmpty, errorMsg: &#x27;邮箱不能为空&#x27; &#125;, &#123; validator: isEmail, errorMsg: &#x27;邮箱格式不正确&#x27; &#125;]) var result = validator.validate(); if(result)&#123; alert(result); return false; &#125; alert(&#x27;验证通过&#x27;);&#125; 全部代码在线示例：Code Pen 上面这种使用了组合、委托等思想，可以避免多种条件选择语句；同时将算法封装在独立的 strategy 中，使得它易于切换，易于理解，易于拓展。 但是提前绑定了要检验的值，当要校验的对象的值类型为非引用数值的时候，被校验的对象不会随之变更： let obj = &#123; name: &#x27;&#x27;,&#125;let validator = new Validator().add(obj.name, [&#123; validator: isNotEmpty, errorMsg: &#x27;姓名必须不为空&#x27;&#125;])console.log(validator.validate())// &quot;姓名必须不为空&quot;obj.name = &quot;Jack&quot;;console.log(validator.validate())// 期望为“true” 实际为“姓名必须不为空” 如上述代码，obj.name 已经被固定为 &#39;&#39; 当 obj.name 修改时并不能同步校验函数中的值，下一节提到的方案将会解决这个问题。 ProxyProxy 是 javascript 提供的用于在语言层面修改一些操作的默认行为，当然在读写值的时候增加一层校验非常方便. 这是一个修改对象默认读写值方法的示例： let obj = new Proxy(&#123;&#125;, &#123; get (target, key, receiver) &#123; console.log(`&quot;$&#123;key&#125;&quot; getter`); return Reflect.get(target, key, receiver); &#125;, set (target, key, value, receiver) &#123; console.log(`&quot;$&#123;key&#125;&quot; setter`); return Reflect.set(target, key, value, receiver); &#125;&#125;);obj.key = &#x27;value&#x27;;// &quot;key&quot; setterconsole.log(obj.key);// &quot;key&quot; getter// value 这样，我们可以创建一个校验器对象，然后使用表单的元素为其赋值的时候便会对其进行校验，这次表单校验函数的大体结构如下： function validate() &#123; let validators = &#123; name: strategies, age: strategies, email: strategies &#125;; // 创建表单校验对象实例 let formObj = validatorCreater(&#123;&#125;, validators); // 获取form元素 let ele = document.getElementById(&#x27;formEle&#x27;); // 开始校验，并处理失败信息 try &#123; formObj.key = ele.value &#125; catch(e) &#123; alert(e); return false; &#125; return true;&#125; 我们来逐个实现它的每一部分，首先是 validators 为了灵活，我们定义成类似于上一节的结构： let validators = &#123; name: [&#123; validator: isNotEmpty, errorMsg: &#x27;姓名必须不为空&#x27; &#125;], age: [&#123; validator: isNumber, errorMsg: &#x27;年龄必须为数字&#x27; &#125;, &#123; validator: isBetween, errorMsg: &#x27;年龄必须为大于 0 并且小于 100&#x27;, params: [0, 100] &#125;], email: [&#123; validator: isNotEmpty, errorMsg: &#x27;邮箱不能为空&#x27; &#125;, &#123; validator: isEmail, errorMsg: &#x27;邮箱格式不正确&#x27; &#125;]&#125;; 接下来我们实现 validatorCreater，validatorCreater 是在目标对象上创建一个有检验功能的代理： var validatorCreater = (target, validator) =&gt; new Proxy(target, &#123; // 保存校验器 _validator: validator, set(target, key, value, receiver) &#123; // 如果赋值的属性存在校验器，则进行校验 if (this._validator[key]) &#123; // 遍历其多个子校验器 for (validatorStrategy of this._validator[key])&#123; let &#123;validator, errorMsg=&#x27;&#x27;, params=[]&#125; = validatorStrategy; if (!validator.call(null, value, ...params)) &#123; // 校验失败抛出异常 throw new Error(errorMsg); return false; &#125; &#125; &#125; // 赋值语句放最后，如果失败不赋值，如果不存在校验器则赋值 return Reflect.set(target, key, value, receiver); &#125;&#125;); 这里说一下，setter 函数内部只能返回 true 或者 false，而系统内部消化了这个返回的布尔值结果，也就是说这个返回的 true 或者 false 我们是无法看的到，所以当校验失败的时候我们选择抛出异常处理更清晰。 提交表单的校验函数时用 try...catch 检查是否赋值成功： function validate() &#123; // 创建表单校验对象实例 let formObj = validatorCreater(&#123;&#125;, validators); // 获取form元素 let eleName = document.getElementById(&#x27;name&#x27;); let eleAge = document.getElementById(&#x27;age&#x27;); let eleMail = document.getElementById(&#x27;mail&#x27;); // 开始校验，并接收错误信息 try &#123; formObj.name = eleName.value; formObj.age = eleAge.value; formObj.email = eleMail.value; &#125; catch (e) &#123; alert(e.message); return false; &#125; alert(&#x27;验证通过&#x27;); return true;&#125; 全部代码在线示例：Code Pen 如果熟悉 Object.defineProperty 会想到 Object.defineProperty 也可以修改对象的 setter ，当然，也可以使用 Object.defineProperties 进行校验： var validatorCreater = (target, validator) =&gt; &#123; let obj = &#123;&#125;; let descriptors = &#123;&#125;; for (let key in validator) &#123; descriptors[key] = &#123; set(value) &#123; for (validatorStrategy of validator[key])&#123; let &#123;validator, errorMsg=&#x27;&#x27;, params=[]&#125; = validatorStrategy; if (!validator.call(null, value, ...params)) &#123; // 校验失败抛出异常 throw new Error(errorMsg); return false; &#125; &#125; this._value = value; return true; &#125;, get() &#123; return this._value; &#125; &#125; &#125; Object.defineProperties(obj, descriptors);&#125; 参考 探索两种优雅的表单验证——策略设计模式和ES6的Proxy代理模式","categories":[{"name":"js","slug":"js","permalink":"http://tcatche.site/categories/js/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://tcatche.site/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"使用 Atom 避免 ArrayBuffers 中的竞态条件 - Avoiding race conditions in SharedArrayBuffers with Atomics","slug":"avoiding-race-conditions-in-sharedarraybuffers-with-atomics","date":"2017-07-06T08:09:00.000Z","updated":"2018-08-01T10:41:24.000Z","comments":true,"path":"2017/07/avoiding-race-conditions-in-sharedarraybuffers-with-atomics/","link":"","permalink":"http://tcatche.site/2017/07/avoiding-race-conditions-in-sharedarraybuffers-with-atomics/","excerpt":"","text":"原文：Avoiding race conditions in SharedArrayBuffers with Atomics 本文译自Lin Clark 内存管理的卡通介绍系列，渣翻译，因此附上英文原文。 内存管理 ArrayBuffers 和 SharedArrayBuffers 的卡通介绍 使用 Atom 避免 ArrayBuffers 中的竞态条件 In the last article, I talked about how using SharedArrayBuffers could result in race conditions. This makes working with SharedArrayBuffers hard. We don’t expect application developers to use SharedArrayBuffers directly. 在上一篇文章中，我谈到了使用 SharedArrayBuffers 可能导致竞态条件。 这使得使用 SharedArrayBuffers 很难。我们不希望应用程序开发人员直接使用SharedArrayBuffers。 But library developers who have experience with multithreaded programming in other languages can use these new low-level APIs to create higher-level tools. Then application developers can use these tools without touching SharedArrayBuffers or Atomics directly. 但是，具有其他语言的多线程编程经验的类库开发人员可以使用这些新的底层 API 来创建更高级别的工具。应用程序开发人员可以直接使用这些更高级别的工具而不用直接接触 SharedArrayBuffers 或 Atomics。 Even though you probably shouldn’t work with SharedArrayBuffers and Atomics directly, I think it’s still interesting to understand how they work. So in this article, I’ll explain what kinds of race conditions concurrency can bring, and how Atomics help libraries avoid them. 即使你可能不直接使用 SharedArrayBuffers 和 Atomics，我认为了解它们是如何工作的是有趣的。 所以在本文中，我将介绍并发可以带来什么样的竞态条件，以及 Atomics 如何帮助库避免它们。 But first, what is a race condition? 但首先，什么是竞态条件？ 竞态条件：你以前见过的一个例子A pretty straightforward example of a race condition can happen when you have a variable that is shared between two threads. Let’s say one thread wants to load a file and the other thread checks whether it exists. They share a variable, fileExists, to communicate. 当一个变量在两个线程之间共享时，一个很直接的竞态示例就可能发生。假设一个线程想加载一个文件，另一个线程检查它是否存在 他们共享一个变量 fileExists 进行通信。 Initially, fileExists is set to false. 刚开始，fileExists 设置为 false。 As long as the code in thread 2 runs first, the file will be loaded. 只要线程2的代码首先运行，文件就被加载。 But if the code in thread 1 runs first, then it will log an error to the user, saying that the file does not exist. 但如果线程1中的代码首先运行，那么它将向用户记录一个错误，表示该文件不存在。 But that’s not the problem. It’s not that the file doesn’t exist. The real problem is the race condition. 但这不是问题，这并不是文件不存在的问题，真正的问题是竞争状况。 Many JavaScript developers have run into this kind of race condition, even in single-threaded code. You don’t have to understand anything about multithreading to see why this is a race. 许多 JavaScript 开发人员遇到过这种竞争状况，即使是单线程编码。先看看为什么这会引起竞争，你不必先理解多线程的内容。 However, there are some kinds of race conditions which aren’t possible in single-threaded code, but that can happen when you’re programming with multiple threads and those threads share memory. 然而，有些类型的竞态条件在单线程代码中是不可能的发生的，但是当你使用多线程进行编程并且这些线程共享内存时，可能会发生这些情况。 不同类别的竞态条件和 Atomics 对象如何帮忙解决Let’s explore some of the different kinds of race conditions you can have in multithreaded code and how Atomics help prevent them. This doesn’t cover all possible race conditions, but should give you some idea why the API provides the methods that it does. 我们来讨论一些你可能在多线程代码中碰到的不同类型的竞态条件，以及 Atomics 如何防止它们。这并不包括所有可能的竞态条件，但应该给你一些了解，了解为什么 API 提供处理它们方法。 Before we start, I want to say again: you shouldn’t use Atomics directly. Writing multithreaded code is a known hard problem. Instead, you should use reliable libraries to work with shared memory in your multithreaded code. 在我们开始之前，我想再说一遍：你不应该直接使用 Atomics。编写多线程代码是一个已知的难题。相反，你应该使用可靠的库在多线程代码中共享内存。 With that out of the way… 单一操作的竞赛条件Let’s say you had two threads that were incrementing the same variable. You might think that the end result would be the same regardless of which thread goes first. 假设你有两个线程递增同一变量。你可能认为无论哪个线程先操作，最终的结果将是一样的。 But even though, in the source code, incrementing a variable looks like a single operation, when you look at the compiled code, it is not a single operation. 即使在源代码中，增加一个变量看起来像一个操作，但当你查看编译后的代码时，它并不是一个单一的操作。 At the CPU level, incrementing a value takes three instructions. That’s because the computer has both long-term memory and short-term memory. (I talk more about how this all works in another article). 在 CPU 级别，增加一个值需要三条指令。这是因为计算机有长期存储和短期存储。（我在另一篇文章中更多地谈论这一切如何工作）。 All of the threads share the long-term memory. But the short-term memory—the registers—are not shared between threads. 所有线程共享长期存储。 但短期存储-寄存器不会在线程之间共享。 Each thread needs to pull the value from memory into its short-term memory. After that, it can run the calculation on that value in short-term memory. Then it writes that value back from its short-term memory to the long-term memory. 每个线程都需要将内存中的值从其内存中取出。之后，在短期存储中对该值进行计算。然后它将这个价值从短期存储中写回到长期存储。 If all of the operations in thread 1 happen first, and then all the operations in thread 2 happen, we will end up with the result that we want. 如果线程1中的所有操作先执行，然后线程2中的所有操作都执行，我们最终得到我们想要的结果。 But if they are interleaved in time, the value that thread 2 has pulled into its register gets out of sync with the value in memory. This means that thread 2 doesn’t take thread 1’s calculation into consideration. Instead, it just clobbers the value that thread 1 wrote to memory with its own value. 但是如果它们时间上交错执行，则线程 2 被拉入其寄存器的值与内存中实际的值不同步。这意味着线程2会忽略线程1的计算结果。相反，它用自己的值写入内存消除了线程1写的值。 One thing atomic operations do is take these operations that humans think of as being single operations, but which the computer sees as multiple operations, and makes the computer see them as single operations, too. 原子操作所做的一件事是转换那些人们认为是单一操作，而计算机视为多个操作的操作，转换它们，使计算机也将它们视为单个操作。 This is why they’re called atomic operations. It’s because they take an operation that would normally have multiple instructions—where the instructions could be paused and resumed—and it makes it so that they all happen seemingly instantaneously, as if it were one instruction. It’s like an indivisible atom. 这就是为什么它们被称为原子操作。这是因为它们将有多个指令——指令可以暂停和恢复——的操作，使这些操作全部发生在瞬间，就像是一个单独指令，这就像一个不可分割的原子。 Using atomic operations, the code for incrementing would look a little different. 使用原子操作，递增变量的代码看起来稍有不同。 Now that we’re using Atomics.add, the different steps involved in incrementing the variable won’t be mixed up between threads. Instead, one thread will finish its atomic operation and prevent the other one from starting. Then the other will start its own atomic operation. 现在我们使用的是 Atomics.add，递增变量所涉及的不同步骤不会在线程之间混合。相反，一个线程将完成其原子操作，并阻止另一个线程启动。然后另一个线程开始自己的原子操作。 The Atomics methods that help avoid this kind of race are: Atomics.add Atomics.sub Atomics.and Atomics.or Atomics.xor Atomics.exchange 有助于避免这种竞争的 Atomics 方法有： Atomics.add Atomics.sub Atomics.and Atomics.or Atomics.xor Atomics.exchange You’ll notice that this list is fairly limited. It doesn’t even include things like division and multiplication. A library developer could create atomic-like operations for other things, though. 你会注意到这个列表是相当有限的。它甚至不包括除法和乘法等。不过，库开发人员可以为其他操作创建类似的原子操作。 To do that, the developer would use [Atomics.compareExchange](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Atomics/compareExchange). With this, you get a value from the SharedArrayBuffer, perform an operation on it, and only write it back to the SharedArrayBuffer if no other thread has updated it since you first checked. If another thread has updated it, then you can get that new value and try again. 为此，开发人员可以使用Atomics.compareExchange。使用它，你可以从 SharedArrayBuffer 获取值，对其执行操作，并且只有在你首次检查后没有其他线程更新该值的情况下才将其写回 SharedArrayBuffer。 如果另一个线程已更新，那么你可以获得该新值，然后重试。 多个操作间的竞态条件So those Atomic operations help avoid race conditions during “single operations”. But sometimes you want to change multiple values on an object (using multiple operations) and make sure no one else is making changes to that object at the same time. Basically, this means that during every pass of changes to an object, that object is on lockdown and inaccessible to other threads. 这些原子操作有助于在“单次操作”期间避免竞态条件。但有时你想要更改对象上的多个值（使用多个操作），并确保没有其他人同时对该对象进行更改。这意味着在一个线程对对象的更改期间，该对象处于锁定状态，其他线程无法访问。 The Atomics object doesn’t provide any tools to handle this directly. But it does provide tools that library authors can use to handle this. What library authors can create is a lock. Atomics对象不提供任何工具来直接处理这个问题。但它提供了库作者可以用来处理这个问题的工具，库作者可以用这些工具创建锁。 If code wants to use locked data, it has to acquire the lock for the data. Then it can use the lock to lock out the other threads. Only it will be able to access or update the data while the lock is active. 如果代码想要使用锁定的数据，它必须获取数据的锁。然后它可以使用锁来锁定数据阻止其他线程使用。只有当数据锁是活动的时候，才能访问或更新数据。 To build a lock, library authors would use Atomics.wait and Atomics.wake, plus other ones such as Atomics.compareExchange and Atomics.store. If you want to see how these would work, take a look at this basic lock implementation. 要构建一个锁，库作者可以使用 Atomics.wait 和 Atomics.wake，以及其他诸如 Atomics.compareExchange 和Atomics.store。 如果你想看看它们是如何工作的，看看这个基本锁实现。 In this case, thread 2 would acquire the lock for the data and set the value of locked to true. This means thread 1 can’t access the data until thread 2 unlocks. 在这种情况下，线程2将获取数据锁，将数据的 locked 值设置为 true。这意味着线程1无法访问这些数据，直到线程2解锁这些数据。 If thread 1 needs to access the data, it will try to acquire the lock. But since the lock is already in use, it can’t. The thread would then wait—so it would be blocked—until the lock is available. 如果线程1需要访问数据，它将尝试获取锁。但是由于锁已经在使用，所以不能获得锁。线程1被阻止，然后等待直到锁可用。 Once thread 2 is done, it would call unlock. The lock would notify one or more of the waiting threads that it’s now available. 一旦线程2完成，它将调用解锁（unlock）。该锁将通知一个或多个在等待线程现在可用。 That thread could then scoop up the lock and lock up the data for its own use. 线程1可以使用锁锁定自己使用的数据。 A lock library would use many of the different methods on the Atomics object, but the methods that are most important for this use case are: Atomics.wait Atomics.wake 一个锁的库可以使用 Atomics 对象上的许多不同方法，但对于这类用例最重要的方法是： Atomics.wait Atomics.wake 指令重新排序引起的竞态条件There’s a third synchronization problem that Atomics take care of. This one can be surprising. 这是 Atomics 需要处理的第三个同步问题，这个问题令人惊奇。 You probably don’t realize it, but there’s a very good chance that the code you’re writing isn’t running in the order you expect it to. Both compilers and CPUs reorder code to make it run faster. 也许你没有意识到，但是你写的代码并不总是按照你期望的顺序运行。编译器和 CPU 为了运行速度更快，都会重新排序代码。 For example, let’s say you’ve written some code to calculate a total. You want to set a flag when the calculation is finished. 例如，假设你写了一些代码来计算总和，你想在计算结束时设置一个标志。 To compile this, we need to decide which register to use for each variable. Then we can translate the source code into instructions for the machine. 为了编译这个，我们需要判断每个变量使用哪个寄存器，然后可以将源代码转换为机器指令。 So far, everything is as expected. What’s not obvious if you don’t understand how computers work at the chip level (and how the pipelines that they use for executing code work) is that line 2 in our code needs to wait a little bit before it can execute. 到目前为止，一切都如预期。 我们的代码中的第2行需要稍等一下才能执行，如果你不了解计算机在芯片级别的工作原理（以及它们执行代码工作的流水线），你可能并不知道这一点。 Most computers break down the process of running an instruction into multiple steps. This makes sure all of the different parts of the CPU are busy at all times, so it makes the best use of the CPU. 大多数计算机将运行的指令分解成多个步骤。这样可以确保 CPU 的所有不同部分始终处于忙碌状态，这样充分利用 CPU。 Here’s one example of the steps an instruction goes through: Fetch the next instruction from memory Figure out what the instruction is telling us to do (aka decode the instruction), and get the values from the registers Execute the instruction Write the result back to the register 以下是一个指令执行步骤的例子： 从内存中读取下一条指令 找出指令告诉我们做什么（也就是解码指令），并从寄存器获取值 执行指令 将结果写回寄存器 So that’s how one instruction goes through the pipeline. Ideally, we want to have the second instruction following directly after it. As soon as it has moved into stage 2, we want to fetch the next instruction. 这就是指令如何通过流水线。理想情况下，我们希望在这条指令结束后直接执行第二条指令。然而实际上，一旦进入流水线阶段 2，就会获取下一条指令。 The problem is that there is a dependency between instruction #1 and instruction #2. 问题是指令1和指令2之间存在依赖关系。 We could just pause the CPU until instruction #1 has updated subTotal in the register. But that would slow things down. 我们可以先暂停 CPU ，直到指令1更新了寄存器中的 subTotal，但这样会减慢执行速度。 To make things more efficient, what a lot of compilers and CPUs will do is reorder the code. They will look for other instructions which don’t use subTotal or total and move those in between those two lines. 为了使执行更有效率，很多编译器和 CPU 都会重新排序代码。它们寻找不使用 subTotal 或 total 的其他指令，并将它们移动到两行之间。 This keeps a steady stream of instructions moving through the pipe. 这保证了稳定的指令流通过管道。 Because line 3 didn’t depend on any values in line 1 or 2, the compiler or CPU figures it’s safe to reorder like this. When you’re running in a single thread, no other code will even see these values until the whole function is done, anyway. 因为第3行不依赖于第1行或第2行中的任何值，所以编译器或 CPU 可以像这样重新排序。当你运行在单个线程中时，在整个功能完成之前，其他代码无论怎样都不会看到这些值。 But when you have another thread running at the same time on another processor, that’s not the case. The other thread doesn’t have to wait until the function is done to see these changes. It can see them almost as soon as they are written back to memory. So it can tell that isDone was set before total. 但是当另一个线程在同时运行另一个处理器上时，情况并非如此。另一个线程不需要等到功能全部完成才能看到这些更改。一旦它们被写回内存，另一个线程就能看到他们。所以可以说 isDone 实际是在total 之前设置的。 If you were using isDone as a flag that the total had been calculated and was ready to use in the other thread, then this kind of reordering would create race conditions. 如果你使用 isDone 作为一个标志，total已经被计算出来并准备在另一个线程中使用，那么这种重新排序就会创造竞态条件。 Atomics attempt to solve some of these bugs. When you use an Atomic write, it’s like putting a fence between two parts of your code. Atomics 试着解决一些这样的错误。当你使用 Atomic 写入时，就像在两个部分之间放一个围栏。 Atomic operations aren’t reordered relative to each other, and other operations aren’t moved around them. In particular, two operations that are often used to enforce ordering are: Atomics.load Atomics.store 原子操作相对于彼此不重新排序，其他操作也不会移动到其中间。特别地，经常用于强制顺序的两个操作是： Atomics.load Atomics.store All variable updates above Atomics.store in the function’s source code are guaranteed to be done before Atomics.store is done writing its value back to memory. Even if the non-Atomic instructions are reordered relative to each other, none of them will be moved below a call to Atomics.store which comes below in the source code. 函数源代码中所有的变量更改在 Atomics.store 将其值重写回内存之前都将保证完成更改。即使非原子指令相对于彼此被重新排序，它们也不会被移动到 Atomics.store 的调用之后。 And all variable loads after Atomics.load in a function are guaranteed to be done after Atomics.load fetches its value. Again, even if the non-atomic instructions are reordered, none of them will be moved above an Atomics.load that comes above them in the source code. 并且函数中所有变量加载保证在 Atomics.load 获取其值完成之后加载给变量。同样的，即使非原子指令被重新排序，它们也不会被移动到源代码 Atomics.load 之前获取值。 Note: The while loop I show here is called a spinlock and it’s very inefficient. And if it’s on the main thread, it can bring your application to a halt. You almost certainly don’t want to use that in real code. 注意：这里显示的 while 循环称为自旋锁，非常低效。如果它在主线程上，它可以使你的应用程序停止。 不要在真实的代码中使用它。 Once again, these methods aren’t really meant for direct use in application code. Instead, libraries would use them to create locks. 再次，这些方法并不意味着需要直接用在应用程序代码中。相反，库将使用它们来创建锁（而你直接调用库的结果即可）。 总结Programming multiple threads that share memory is hard. There are many different kinds of race conditions just waiting to trip you up. 共享内存的多线程编程很难，有很多不同种类的竞态条件陷阱。 This is why you don’t want to use SharedArrayBuffers and Atomics in your application code directly. Instead, you should depend on proven libraries by developers who are experienced with multithreading, and who have spent time studying the memory model. 这就是为什么你会不想直接在应用程序代码中使用 SharedArrayBuffers 和 Atomics。 相反，你应该依赖具有多线程经验的开发人员开发的经过验证的库，以及他们花时间研究的内存模型。 It is still early days for SharedArrayBuffer and Atomics. Those libraries haven’t been created yet. But these new APIs provide the basic foundation to build on top of. SharedArrayBuffer 和 Atomics 还处于早期阶段。 这些库尚未创建，但是这些新的API提供了基础。","categories":[{"name":"翻译","slug":"翻译","permalink":"http://tcatche.site/categories/%E7%BF%BB%E8%AF%91/"}],"tags":[{"name":"内存管理","slug":"内存管理","permalink":"http://tcatche.site/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"},{"name":"WebAssembly","slug":"WebAssembly","permalink":"http://tcatche.site/tags/WebAssembly/"}]},{"title":"TC39 提案说明","slug":"tc39-ecmascript-proposals","date":"2017-07-05T07:24:00.000Z","updated":"2021-08-10T03:35:21.472Z","comments":true,"path":"2017/07/tc39-ecmascript-proposals/","link":"","permalink":"http://tcatche.site/2017/07/tc39-ecmascript-proposals/","excerpt":"","text":"什么是 TC39？TC39 是技术委员会第 39 号，是 ECMAScript 规范下的 JavaScript 语言标准化的机构，负责开发 JavaScript 的委员会。 TC39 提案过程每个 ECMAScript 的提案都将经过以下阶段，从 Stage 0 开始，从一个阶段到下一个阶段的进展必须得到 TC39 的批准。 Stage 0: strawman提供 ECMAScript 自由演变的方案。 该阶段需要： 文件必须在 TC39 会议进行审查，然后将其添加到 Stage 0 提案的页面中。 Stage 1: proposal该功能的正式提案。 该阶段需要： 确定一个负责人来负责推动该提案。 描述清楚要解决的问题，解决方案中必须包含示例，API 以及关于相关的语义和算法。 潜在问题也应该指出来，例如与其他特性的关系，实现它所面临的挑战。 polyfill和demo也是必要的。 TC39 通过接受第一阶段的提议，审议、讨论并对该提案作出贡献。未来，预计将对该提案进行重大修改。 Stage 2: draft该版本是规范的第一个版本，使用正式的规范语言来精确描述语法和语义。 该阶段需要： 初始规范文本，涵盖了所有主要语义，语法和API，除了预期TODO，占位符。 委员会期望该功能得到发展，并最终纳入标准，并且从现在开始只能接收增量修改。 Stage 3: candidate第3阶段的提案是候选的天。 在这个阶段，该提案大多完成，需要根据实现和用户的反馈进一步推进。 该阶段需要： 完成规范文本 指定评审员已经签署了当前的规范文本 ECMAScript 编辑器已经签署了当前的规范文本 此后，只有在实现和使用过程中出现了重大问题提案才会被修改。 Stage 4: finished该提案已准备好纳入正式的 ECMAScript 标准。 该阶段需要： 测试262验收测试（大致为语言特征的单元测试，用 JavaScript 编写）。 两个符合规范的稳定的实现通过验收测试 实现具有重要的实践经验。 ECMAScript 的规范编辑必须在规范文本上签字。 该提案将尽快包含在 ECMAScript 规范中。当规范以年度批准为标准的时候，这个提案就被批准为一部分。 参考The TC39 process for ECMAScript featuresThe TC39 Process","categories":[{"name":"其它","slug":"其它","permalink":"http://tcatche.site/categories/%E5%85%B6%E5%AE%83/"}],"tags":[{"name":"规范","slug":"规范","permalink":"http://tcatche.site/tags/%E8%A7%84%E8%8C%83/"}]},{"title":"虚拟 DOM 内部是如何工作的？","slug":"the-inner-workings-of-virtual-dom-rajaraodv-medium","date":"2017-07-05T02:42:00.000Z","updated":"2018-08-01T10:41:24.000Z","comments":true,"path":"2017/07/the-inner-workings-of-virtual-dom-rajaraodv-medium/","link":"","permalink":"http://tcatche.site/2017/07/the-inner-workings-of-virtual-dom-rajaraodv-medium/","excerpt":"","text":"本文转载自：众成翻译译者：我是搬运工链接：http://www.zcfy.cc/article/3248原文：https://medium.com/@rajaraodv/the-inner-workings-of-virtual-dom-666ee7ad47cf 流程图展现VDOM在Preact中如何工作 虚拟DOM (VDOM 也叫 VNode)非常有魔力 ✨ 但是也非常复杂和难以理解😱. React, 在Preact和一些类似的JS库的核心代码中使用. 不幸的是我发现没有一篇好的文章或者文档简洁明了的来介绍它。 因此我决定自己写一篇. 注意: 这篇文章很长. 我已经添加尽可能多的图片来使其理解更简单一些，但是我发现这样的话，文章更长了. 我用的是 Preact’s 代码 和 VDOM，因为它很小，你可以在将来很舒适的阅读它。 但是我相信几乎所有的概念同样适用于React. 我希望你读完这篇文章后，能够很容易的理解像React或者Preact的库，甚至对你写出类似的库也是有帮助的 在这篇博客中，我将会举一些简单示例，并且复习一下不同的小知识，给你一个关于它们到底如何工作的概念。特别地，我会复习： Babel 和 JSX 创建一个VNode - 一个简单的虚拟DOM元素 处理组件及子组件 初始化渲染并且创建一个DOM元素 重新渲染 移除DOM元素 替换DOM元素 关于这个demo:这是一个简单过滤搜索应用， 仅包含有两个组件“FilteredList” 和 “List”。这个List组件渲染列表项（默认是“California” 和 “New York”）。这个应用有一个搜索的区域，可以根据字母来过滤列表项。非常的直观。 相关图片 应用代码: http://codepen.io/rajaraodv/pen/BQxmjj 大图高级一点儿，我们用JSX写了组件，可以通过babel的命令行工具将其转换为原生的JS.然后Preact的“h”函数将它转换为虚拟DOM树（也称为 VNode）。最后Preact的虚拟DOM算法，根据虚拟DOM创建一个真实的DOM，来构成我们的应用。 大图 在我们深入理解VDOM的生命周期之前，让我们理解下JSX，它为库提供了基础 Babel 和 JSX在React中，像Preact这样的库，没有HTML语法，取而代之的是一切皆Javascript。因此我们需要用Javascript来写HTML。但是用原生JS写DOM是一种噩梦。 😱 对于我们的应用，我们将会像下面这样书写HTML: 注意: 等会儿我会介绍“h” 这就是JSX的由来，JSX本质上允许我们在Javascript中书写HTML!并且允许我们在HTML中的{}号中使用JS的语法。 JSX帮助我们像下面这样很容易的书写组件： 将JSX树转换为JavascriptJSX很酷，但是不是合法的JS,但是根本上我们还是需要真实的DOM。JSX仅仅是帮助我们书写真实DOM的一种方法。除此之外，它毫无用处。 因此我们需要一种方法将JSX转换为正确的JSON对象（VDOM 也是一个“树”形的结构），我们需要将JSX作为创建真实DOM的基础。我们函数来做这样的事情. 在Preact中这个函数就是“h”函数.它作用和React中的React.createElement作用是一样的。 “h”是指 hyperscript - 一种可以通过JS来创建HTML的库。 但是怎样将JSX转换为“h”函数式的调用？这就是Babel的由来。Babel可以很轻松的遍历JSX的节点，然后将它们转换为“h”函数式的调用。 Babel JSX (React Vs Preact)在React中babel会将JSX转换为React.createElement函数调用 左边: JSX 右边: React 的JS版本 (点击放大) 我们可以像下面这样增加[Babel Pragma]配置，可以很轻松为Preact的函数的名字起任何一个你想起的名字。 Option 1://.babelrc&#123; &quot;plugins&quot;: [ [&quot;transform-react-jsx&quot;, &#123; &quot;pragma&quot;: &quot;h&quot; &#125;] ] &#125; Option 2://Add the below comment as the 1st line in every JSX file`/** @jsx h */` “h” —通过Babel的配置 (点击放大) 挂载到真实DOM组件的的render方法中的代码不仅被转换为“h”函数，而且开始挂载。 这是执行和一切的开始 //Mount to real DOMrender(&lt;FilteredList/&gt;, document.getElementById(‘app’)); //Converted to &quot;h&quot;:render(**h(FilteredList)**, document.getElementById(‘app’)); “h”函数的输出The “h” function takes the output of JSX and creates something called a “VNode” (React’s “createElement” creates ReactElement). A Preact’s “VNode” (or a React’s “Element”) is simply a JS object representation of a single DOM node with it’s properties and children. 看起来像下面这样: &#123; &quot;nodeName&quot;: &quot;&quot;, &quot;attributes&quot;: &#123;&#125;, &quot;children&quot;: []&#125; 举个例子，我们的应用的Input表单的VNode像这样： &#123; &quot;nodeName&quot;: &quot;input&quot;, &quot;attributes&quot;: &#123; &quot;type&quot;: &quot;text&quot;, &quot;placeholder&quot;: &quot;Search&quot;, &quot;onChange&quot;: &quot;&quot; &#125;, &quot;children&quot;: [] &#125; Note: “h” function doesn’t create the entire tree! It simply creates JS object for a given node. But since the “render” method already has the DOM JSX in a tree fashion, the end result will be a VNode with children and grand children that looks like a tree.注意“h”函数不会创建完整的树 它仅仅对于给定的node创建了一个JS对象。但是。 最后的结果将会是一个带有子元素和看起来像树的重要子元素的VNode. 参考代码: “h” :https://github.com/developit/preact/blob/master/src/h.js VNode: https://github.com/developit/preact/blob/master/src/vnode.js “render”: https://github.com/developit/preact/blob/master/src/render.js “buildComponentFromVNode: https://github.com/developit/preact/blob/master/src/vdom/diff.js#L102 好了，让我们看下虚拟DOM如何工作的？ Preact虚拟DOM的算法流程图下面的流程图展现了组件和子组件如何被Preact创建，更新，删除的。也展现了生命周期的不同阶段，对应的回调函数被调用，像“componentWillMount”。 注意： 我们会一步一步的复习每一部分，如果你会觉复杂，不用担心。 是的，立马理解所有的知识很难。让我们一步一步得通过浏览不同的情景，来复习流程图的不同部分。 注意： 当讨论到关键的生命周期的部分我将会用黄色高亮。 APP创建初始化对一个给定的组件创建一个VNode黄色高亮区域对于一个给定的组件创建虚拟DOM数，初始化处理循环。注意没有为子组件创建虚拟DOM（这是个不同的循环） 黄色区域展示了虚拟DOM的创建 下面这张图片展示了当我们应用第一次加载的时候发生了什么。这个库最终为主要组件“FilteredList”创建了一个带有子元素和属性的VNode。 注意： 它连着调用了生命周期方法“componentWillMount” 和 “render”.(看上面图片绿色的部分) (click to zoom) 这个时候，我们有了个“div”的父元素，它包含了子节点“input”和“list”。 引用: 大多数的生命周期事件，像componentWillMount,render等等: https://github.com/developit/preact/blob/master/src/vdom/component.js 如果不是一个组件，创建一个真实的DOM这一步，它仅会对父元素div创建一个真实的DOM，并且对于子节点（“input” 和 “List”）重复这一步骤。 黄色的循环部分展现了子组件的创建。 这一步，下面的图片中仅仅“div”被显示出来了。 引用: document.createElement: https://github.com/developit/preact/blob/master/src/dom/recycler.js 对所有的子元素重复这一步这一步，对所有的子元素将会重复这一步。在我们的应用中，会对“input” 和 “List” 重复。 对每一个子元素重复 处理子元素，并且把它加到父元素上.这一步我们将会处理子树。既然“input”有一个父元素“div”,我们将会把input作为一个子元素加到div中。然后停止，返回创建“List”（第二个div子元素）。 结束处理子树 这一步，我们的应用看起来像下面这样: 注意： “input”被创建后，由于没有任何一个子元素，不会理解循环和创建“List”。它会首先将“input”加入到父元素“div”中，然后返回处理“List”。 引用: appendChild: https://github.com/developit/preact/blob/master/src/vdom/diff.js 处理子组件（们）控制流程回到1.1，对“List”组件开始所有的。但是“List”是一个组件，它调用“List”组件的方法render，得到一组新的虚DOM，像下面这样 对一个子组件重复所有的操作 对List组件重复操作之后，返回VNode像下面这样： 引用: “buildComponentFromVNode: https://github.com/developit/preact/blob/master/src/vdom/diff.js#L102 对所有子节点重复上面四小节的步骤它会再一次对每一个节点重复上面的步骤。一旦它到达子节点，就会把它加入到节点的父节点，并且重复处理。 重复这一步骤，直到所有的父子节点被创建和添加。 下面的图片展示了每个节点的添加(提示： 深度优先) 真实的DOM树如何被虚拟DOM算法创建的。 结束处理这一步，结束处理。它仅对所有的组件调用了“componentDidMount”(从子组件到父组件)并且停止。 重要提示: 一旦所有所有做完之后，一个真实DOM的引用被添加到每个组件的实例上去。这个引用被用来更新（创建，更新，删除）比较，避免重复创建同样的DOM节点。 删除叶子节点当我们输入“cal” 关键字，确认。将会移除掉第二个list节点，保留所有的父节点。 让我们看下，怎么样看这个情景？ 像之前那样创建VNodes.当初始化渲染之后，未来的每一个变化都是一个更新。当需要创建VNodes时，更新的周期工作跟创建的周期非常的相似，并且再一次创建所有的VNodes。 既然是一个组件的更新（不是创建），每个组件和子组件都会调用“componentWillReceiveProps”, “shouldComponentUpdate”, 和 “componentWillUpdate” 另外, update cycle, 如果那些元素已经存在不会重复创建真实的DOM。 更新组件的生命周期 引用 removeNode: https://github.com/developit/preact/blob/master/src/dom/index.js#L9 insertBefore: https://github.com/developit/preact/blob/master/src/vdom/diff.js#L253 用引用的真实DOM，避免创建重复的nodes像之前提到的，在初始化加载期间，每个组件相对应我们创建的真实DOM树有一个引用。下面这张图片展现了这一刻我们的应用的引用。 显示每一个组件 和 之前的DOM的差异 当虚拟DOM被创建，每个虚拟DOM的属性都会跟真实DOM的属性进行比较如果真实DOM存在，循环处理将会进行下一步 真实DOM已经存在（在更新期间） 引用 innerDiffNode: https://github.com/developit/preact/blob/master/src/vdom/diff.js#L185 如果他们在真实的DOM中是额外的节点，移除他们下面的图片展现了真实DOM和虚拟DOM的差异 (click to zoom) 这里有一点儿不同。在真实节点中的“New York”节点被算法移除了像下面流程图那样。当所有工作进行完毕算法也会调用“componentDidUpdate”。 移除DOM节点生命周期 卸载整个组件让我们看看在filter组件中输入blabla，既然没有匹配到“California” 和 “New York”, 我们不会渲染子组件“List”,这意味着我们需要卸载整个组件。 如果没有结果的话List组件没有被移除 组件FilteredList的render方法 删除一个组件跟删除一个单一节点差不多，当我们删除一个相对于组件有引用的节点，框架会调用“componentWillUnmount”,然后安全的删除所有的DOM元素。当所有的元素从真实DOM移除，将会调用引用的组件的“componentDidUnmount”方法。 下面的图片显示在真实的DOM“ul”中，“List”组件的引用。 下面流程图的高亮部分展现了移除和卸载组件的过程 移除和卸载组件 引用 unmountComponent: https://github.com/developit/preact/blob/master/src/vdom/component.js#L250 最后一点:我希望这篇博文能够给你关于虚拟DOM如何工作足够的启示（至少在Preact中）。 虽然这些覆盖了主要的场景，但是我还没讲到代码的优化。 如果你发现问题，通知我，我非常乐意更新！如果你想知道更多，也请告诉我！ 就这样! 🙏🏼 👍 🎉🎉🎉 如果你喜欢这篇文章, please 1. 💚在Medium点喜欢 and 2. 在twitter上分享._🎉🎉🎉 你可以在这里找到我: https://twitter.com/rajaraodv","categories":[{"name":"转载","slug":"转载","permalink":"http://tcatche.site/categories/%E8%BD%AC%E8%BD%BD/"}],"tags":[{"name":"react","slug":"react","permalink":"http://tcatche.site/tags/react/"},{"name":"虚拟DOM","slug":"虚拟DOM","permalink":"http://tcatche.site/tags/%E8%99%9A%E6%8B%9FDOM/"}]},{"title":"WebAssembly 的现状和未来？ - Where is WebAssembly now and what’s next?","slug":"where-is-webassembly-now-and-whats-next","date":"2017-07-04T07:49:00.000Z","updated":"2018-08-01T10:41:24.000Z","comments":true,"path":"2017/07/where-is-webassembly-now-and-whats-next/","link":"","permalink":"http://tcatche.site/2017/07/where-is-webassembly-now-and-whats-next/","excerpt":"","text":"原文：Where is WebAssembly now and what’s next? 本文译自Lin Clark 关于 WebAssembly 的卡通介绍系列，渣翻译，因此附上英文原文 概述： WebAssembly 的漫画介绍 背景： 碰撞课程：即时（JIT）编译器 碰撞课程：汇编 现在的 WebAssembly： 创建和使用 WebAssembly 模块 是什么使 WebAssembly 很快？ 未来的 WebAssembly： WebAssembly 的现状和未来？ On February 28, the four major browsers announced their consensus that the MVP of WebAssembly is complete. This provides a stable initial version that browsers can start shipping. 2月28日，四大浏览器宣布达成共识，WebAssembly 的最小可行的产品（MVP，Minimum Viable Product）已经完成。提供了一个稳定的初始版本，浏览器可以开始装备。 This provides a stable core that browsers can ship. This core doesn’t contain all of the features that the community group is planning, but it does provide enough to make WebAssembly fast and usable. With this, developers can start shipping WebAssembly code. For earlier versions of browsers, developers can send down an asm.js version of the code. Because asm.js is a subset of JavaScript, any JS engine can run it. With Emscripten, you can compile the same app to both WebAssembly and asm.js. Even in the initial release, WebAssembly will be fast. But it should get even faster in the future, through a combination of fixes and new features. 这提供了一个浏览器可以使用的稳定的核心。该核心不包含社区组织计划的所有功能，但它确实足以使 WebAssembly 快速并且可用。 这样，开发人员可以开始使用 WebAssembly 代码。使用浏览器提供的早期版本，开发人员可以发送给它 asm.js 版本的代码。因为 asm.js 是 JavaScript 的一个子集，任何 JS 引擎都可以运行。 使用 Emscripten，你可以将同一的应用程序编译到 WebAssembly 和 asm.js。 即使是初始版本，WebAssembly 也很快。并且通过修复和组合新功能，将来能够更快。 改善浏览器中的 WebAssembly 性能 Some speed improvements will come as browsers improve WebAssembly support in their engines. The browser vendors are working on these issues independently. 随着浏览器改进引擎中的 WebAssembly 支持，其速度将有所改善。各家浏览器厂商正在处理下面这些问题。 JS 和 WebAssembly 之间更快的函数调用 Currently, calling a WebAssembly function in JS code is slower than it needs to be. That’s because it has to do something called “trampolining”. The JIT doesn’t know how to deal directly with WebAssembly, so it has to route the WebAssembly to something that does. This is a slow piece of code in the engine itself, which does setup to run the optimized WebAssembly code. 目前，在 JS 代码中调用 WebAssembly 函数比它需要的要慢。 那是因为它必须做一些叫做“蹦床”的东西。 JIT 不知道如何直接处理 WebAssembly，所以它必须将 WebAssembly 路由到某个地方处理。这是引擎本身中缓慢的一段代码，它会设置运行优化的 WebAssembly 代码。 This can be up to 100x slower than it would be if the JIT knew how to handle it directly. You won’t notice this overhead if you’re passing a single large task off to the WebAssembly module. But if you have lots of back-and-forth between WebAssembly and JS (as you do with smaller tasks), then this overhead is noticeable. 这种方式可能比 JIT 知道如何直接处理的速度要慢 100 倍。 如果你将单个大型任务传递到 WebAssembly 模块，则不会注意到此开销。 但是如果你在 WebAssembly 和 JS 之间有很多相互交互（就像使用较小的任务一样），那么这个开销是显而易见的。 更快的加载时间 JITs have to manage the tradeoff between faster load times and faster execution times. If you spend more time compiling and optimizing ahead of time, that speeds up execution, but it slows down start up. There’s a lot of ongoing work to balance up-front compilation (which ensures there is no jank once the code starts running) and the basic fact that most parts of the code won’t be run enough times to make optimization worth it. JIT 必须管理更快的加载时间和更快的执行时间之间的权衡。如果你提前花费更多时间进行编译和优化，则可以加快执行速度，但启动速度会减慢。 有很多正在进行的工作来平衡前端编译（确保代码开始运行后不会有任何崩溃），而事实上，大部分代码不会运行足够多的时间使其优化值得被进行。 Since WebAssembly doesn’t need to speculate what types will be used, the engines don’t have to worry about monitoring the types at runtime. This gives them more options, for example parallelizing compilation work with execution. Plus, recent additions to the JavaScript API will allow streaming compilation of WebAssembly. This means that the engine can start compiling while bytes are still being downloaded. In Firefox we’re working on a two-compiler system. One compiler will run ahead of time and do a pretty good job at optimizing the code. While that’s running code, another compiler will do a full optimization in the background. The fully-optimized version of the code will be swapped in when it’s ready. 由于 WebAssembly 不需要推测将要使用什么类型，引擎不必担心在运行时监视类型。这给了它们更多的选择，例如并行编译工作与执行。 此外，最新添加的 JavaScript API 将允许 WebAssembly 的流式编译。这意味着引擎可以在字节仍在下载时就开始编译。 在 Firefox 中，我们正在开发一个双编译器系统。一个编译器将提前运行，并在优化代码方面做得很好。当运行代码时，另一个编译器将在后台进行完全优化。完全优化的代码版本将在准备就绪时被交换。 Adding post-MVP features to the spec One of the goals of WebAssembly is to specify in small chunks and test along the way, rather than designing everything up front. This means there are lots of features that are expected, but haven’t been 100% thought-through yet. They will have to go through the specification process, which all of the browser vendors are active in. These features are called future features. Here are just a few. 一个 WebAssembly 的目标是在小部分中设计和测试，一路发展，而不是预先设计所有内容。 这意味着有许多预期的功能还没有 100% 的想法，它们需要经过所有浏览器供应商积极制定的规范流程。 这些就是未来的功能，这里仅仅列出少数。 直接与DOM工作 Currently, there’s no way to interact with the DOM. This means you can’t do something like element.innerHTML to update a node from WebAssembly. Instead, you have to go through JS to set the value. This can mean passing a value back to the JavaScript caller. On the other hand, it can mean calling a JavaScript function from within WebAssembly—both JavaScript and WebAssembly functions can be used as imports in a WebAssembly module. 目前，没有办法与 DOM 进行交互。这意味着你不能像 element.innerHTML 那样从 WebAssembly 更新节点。 相反，你必须通过 JS 去设置值。这可能意味着将值传回给 JavaScript 调用者。 另一方面，它也可以意味着从 WebAssembly 中调用 JavaScript 函数 —— JavaScript 和 WebAssembly 函数都可以在 WebAssembly 模块中用作导入。 Either way, it is likely that going through JavaScript is slower than direct access would be. Some applications of WebAssembly may be held up until this is resolved. 无论哪种方式，通过 JavaScript 可能会比直接访问 DOM 慢。一些 WebAssembly 的应用程序可能会被阻止，直到被解决。 共享内存并发 One way to speed up code is to make it possible for different parts of the code to run at the same time, in parallel. This can sometimes backfire, though, since the overhead of communication between threads can take up more time than the task would have in the first place. But if you can share memory between threads, it reduces this overhead. To do this, WebAssembly will use JavaScript’s new SharedArrayBuffer. Once that is in place in the browsers, the working group can start specifying how WebAssembly should work with them. 加快代码的一种方法是使代码的不同部分同时运行成为可能，也就是并行。这有时可能会起反作用，因为线程之间的通信开销可能比任务单独执行占用更多的时间。 但是，如果你可以在线程之间共享内存，可以减少这种开销。 为此，WebAssembly 将使用 JavaScript 的新 SharedArrayBuffer 功能。 一旦 SharedArrayBuffer 在浏览器中可用，工作组就可以开始指定 WebAssembly 如何与它们配合使用。 SIMD If you read other posts or watch talks about WebAssembly, you may hear about SIMD support. The acronym stands for single instruction, multiple data. It’s another way of running things in parallel. SIMD makes it possible to take a large data structure, like a vector of different numbers, and apply the same instruction to different parts at the same time. In this way, it can drastically speed up the kinds of complex computations you need for games or VR. This is not too important for the average web app developer. But it is very important to developers working with multimedia, such as game developers. 如果你阅读其它 WebAssembly 帖子或观看介绍，你可能会听到有关 SIMD 的支持。SIMD 缩写代表单指令，多数据。 这是并行运行的另一种方式。 SIMD 使得可以采用大量的数据结构，例如不同数字的向量，同时将相同的指令应用于不同的部分。这样，它可以大大加快游戏或 VR 所需的各种复杂的计算。 对于一般的网络应用开发人员来说，这并不重要。但对于开发多媒体的开发人员，比如游戏开发者来说，这是非常重要的。 异常处理 Many code bases in languages like C++ use exceptions. However, exceptions aren’t yet specified as part of WebAssembly. If you are compiling your code with Emscripten, it will emulate exception handling for some compiler optimization levels. This is pretty slow, though, so you may want to use the DISABLE_EXCEPTION_CATCHING flag to turn it off. Once exceptions are handled natively in WebAssembly, this emulation won’t be necessary. 许多语言的代码库如 C++ 使用了异常。 但是，异常还没有被指定为 WebAssembly 的一部分。 如果你正在使用 Emscripten 编译代码，它将模拟某些编译器优化级别的异常处理。 这很慢，但是你可能希望使用 DISABLE_EXCEPTION_CATCHING 标志来关闭它。 一旦在 WebAssembly 中原生的处理了异常，则不需要这种仿真。 其它改进 - 使开发人员更容易 Some future features don’t affect performance, but will make it easier for developers to work with WebAssembly. First-class source-level developer tools. Currently, debugging WebAssembly in the browser is like debugging raw assembly. Very few developers can mentally map their source code to assembly, though. We’re looking at how we can improve tooling support so that developers can debug their source code. Garbage collection. If you can define your types ahead of time, you should be able to turn your code into WebAssembly. So code using something like TypeScript should be compilable to WebAssembly. The only hitch currently, though, is that WebAssembly doesn’t know how to interact with existing garbage collectors, like the one built in to the JS engine. The idea of this future feature is to give WebAssembly first-class access to the builtin GC with a set of low-level GC primitive types and operations. ES6 Module integration. Browsers are currently adding support for loading JavaScript modules using the script tag. Once this feature is added, a tag like &lt;script src=url type=&quot;module&quot;&gt; could work even if url points to a WebAssembly module. 一些未来的功能不会影响性能，但会使开发人员更轻松地使用 WebAssembly。 一流的源代码开发工具。 目前，在浏览器中调试 WebAssembly 就像调试原始汇编。 正因为如此，只有很少有开发人员可以将它们的源代码在头脑中映射到汇编。 我们正在研究如何改进工具支持，以便开发人员可以调试其源代码。 垃圾回收。 如果您可以提前定义类型，您应该可以将代码转换为 WebAssembly。 所以使用像 TypeScript 这样的代码应该可以编译为 WebAssembly。 目前唯一的阻碍是 WebAssembly 不知道如何与现有的垃圾收集器（如内置在 JS 引擎的垃圾回收器）进行交互。 未来，这个功能的想法是使 WebAssembly 能够使用一组底层的 GC 原语类型和操作对内置 GC 进行访问。 ES6模块集成。 浏览器正在添加使用脚本标签加载 JavaScript 模块的支持。 添加此功能后，即使 url 指向 WebAssembly 模块，标签如&lt;script src = url type =“module”&gt;也可以工作。 总结 WebAssembly is fast today, and with new features and improvements to the implementation in browsers, it should get even faster. 今天的 WebAssembly 很快，并且随着浏览器新功能的实现和改进，会更快。","categories":[{"name":"翻译","slug":"翻译","permalink":"http://tcatche.site/categories/%E7%BF%BB%E8%AF%91/"}],"tags":[{"name":"WebAssembly","slug":"WebAssembly","permalink":"http://tcatche.site/tags/WebAssembly/"},{"name":"翻译","slug":"翻译","permalink":"http://tcatche.site/tags/%E7%BF%BB%E8%AF%91/"}]},{"title":"是什么使 WebAssembly 很快？ - What makes WebAssembly fast?","slug":"what-makes-webassembly-fast","date":"2017-07-03T07:25:00.000Z","updated":"2018-08-01T10:41:24.000Z","comments":true,"path":"2017/07/what-makes-webassembly-fast/","link":"","permalink":"http://tcatche.site/2017/07/what-makes-webassembly-fast/","excerpt":"","text":"原文：What makes WebAssembly fast? 本文译自Lin Clark 关于 WebAssembly 的卡通介绍系列，渣翻译，因此附上英文原文 概述： WebAssembly 的漫画介绍 背景： 碰撞课程：即时（JIT）编译器 碰撞课程：汇编 现在的 WebAssembly： 创建和使用 WebAssembly 模块 是什么使 WebAssembly 很快？ 未来的 WebAssembly： WebAssembly 的现状和未来？ In the last article, I explained that programming with WebAssembly or JavaScript is not an either/or choice. We don’t expect that too many developers will be writing full WebAssembly code bases. 在上一篇文章中，我说过使用 WebAssembly 或 JavaScript 进行编程不是二选一的选择。我们不希望太多的开发人员直接编写完整的 WebAssembly 代码库。 So developers don’t need to choose between WebAssembly and JavaScript for their applications. However, we do expect that developers will swap out parts of their JavaScript code for WebAssembly. 所以开发人员不需要为 Web 应用程序选择 WebAssembly 和 JavaScript。 但是，我们期望开发人员将部分 JavaScript 代码改为使用 WebAssembly 的。 For example, the team working on React could replace their reconciler code (aka the virtual DOM) with a WebAssembly version. People who use React wouldn’t have to do anything… their apps would work exactly as before, except they’d get the benefits of WebAssembly. 例如，在 React 上工作的团队可以使用 WebAssembly 版本替换他们的调节器代码（也称为虚拟DOM）。 使用 React 的人不需要做任何事情，他们的应用程序将会像以前那样正常工作，除了他们可以从 WebAssembly 获益。 The reason developers like those on the React team would make this swap is because WebAssembly is faster. But what makes it faster? 开发人员像 React 团队会切换到 WebAssembly 是因为其速度更快。但是什么使它更快？ 现在，JavaScript 性能如何？Before we can understand the differences in performance between JavaScript and WebAssembly, we need to understand the work that the JS engine does. 在了解 JavaScript 和 WebAssembly 之间的性能差异前，我们需要先了解 JS 引擎的工作。 This diagram gives a rough picture of what the start-up performance of an application might look like today. 这张图粗略展示了现在的应用程序的启动性能的大概样子。 The time that the JS engine spends doing any one of these tasks depends on the JavaScript the page uses. This diagram isn’t meant to represent precise performance numbers. Instead, it’s meant to provide a high-level model of how performance for the same functionality would be different in JS vs WebAssembly. JS 引擎处理这些任务中的时间取决于页面使用的 JavaScript。该图并不为了表示精确的性能数字。相反，提供一个 JS 和 WebAssembly 中相同功能的性能不同的高级模型。 Each bar shows the time spent doing a particular task. Parsing — the time it takes to process the source code into something that the interpreter can run. Compiling + optimizing — the time that is spent in the baseline compiler and optimizing compiler. Some of the optimizing compiler’s work is not on the main thread, so it is not included here. Re-optimizing — the time the JIT spends readjusting when its assumptions have failed, both re-optimizing code and bailing out of optimized code back to the baseline code. Execution — the time it takes to run the code. Garbage collection — the time spent cleaning up memory. 每个横条显示在特定任务上花费的时间： 解析（Parsing）：将源代码处理为解释器可以运行的内容所需的时间。 编译+优化（Compiling + optimizing）：在基线编译器和优化编译器中花费的时间。一些优化编译器的工作不在主线程，所以它不包括在这里。 重新优化（Re-optimizing）：JIT 在其假设失败时重新调整花费的时间，包括将优化代码重新优化和回滚优化代码到基准代码。 执行（Execution）：运行代码所需的时间。 垃圾回收（Garbage collection）：清理内存的时间。 One important thing to note: these tasks don’t happen in discrete chunks or in a particular sequence. Instead, they will be interleaved. A little bit of parsing will happen, then some execution, then some compiling, then some more parsing, then some more execution, etc. 一个要注意的重要内容：这些任务不是肚子执行或者以特定的顺序执行。相反，它们将被交错执行：一些解析发生，然后执行，然后编译，然后更多的解析，再然后更多的执行等。 The performance this breakdown brings is a big improvement from the early days of JavaScript, which would have looked more like this: 这是对早期的 JavaScript 的性能一个重大的改进，早期的 JavaScript 更像这样： In the beginning, when it was just an interpreter running the JavaScript, execution was pretty slow. When JITs were introduced, it drastically sped up execution time. 一开始，当它只是一个运行 JavaScript 的解释器时，执行速度相当缓慢。当 JIT 引入时，它大大加快了执行时间。 The tradeoff is the overhead of monitoring and compiling the code. If JavaScript developers kept writing JavaScript in the same way that they did then, the parse and compile times would be tiny. But the improved performance led developers to create larger JavaScript applications. 通过权衡监视和编译代码的开销。如果 JavaScript 开发人员按照他们所做的相同的方式编写 JavaScript，那么解析和编译时间将会很小。但改进的性能使开发人员能够创建更大的JavaScript 应用程序。 This means there’s still room for improvement. 这意味着还有改进的余地。 WebAssembly 比较起来如何？Here’s an approximation of how WebAssembly would compare for a typical web application. 这是 WebAssembly 和典型的 Web 应用程序的近似比较结果。 There are slight variations between browsers in how they handle all of these phases. I’m using SpiderMonkey as my model here. 浏览器在处理所有这些阶段的过程中有轻微的变化。我在这里使用 SpiderMonkey （SpiderMonkey 是 Mozilla 项目的一部分，是一个用 C 语言实现的 JavaScript 脚本引擎）作为我的模型。 获取文件（Fetching）This isn’t shown in the diagram, but one thing that takes up time is simply fetching the file from the server. 这一条并未在图中显示，但是从服务器获取文件需要花费一些时间。 Because WebAssembly is more compact than JavaScript, fetching it is faster. Even though compaction algorithms can significantly reduce the size of a JavaScript bundle, the compressed binary representation of WebAssembly is still smaller. 因为 WebAssembly 比 JavaScript 更紧凑，所以获取它更快。即使压缩算法可以显着减小 JavaScript 包的大小，WebAssembly 的二进制压缩表示仍然较小。 This means it takes less time to transfer it between the server and the client. This is especially true over slow networks. 这意味着在服务器和客户端之间传输它所需的时间更少，特别是在慢速网络中更加明显。 解析（Parsing）Once it reaches the browser, JavaScript source gets parsed into an Abstract Syntax Tree. 一旦文件下载到浏览器，JavaScript 源码将被解析为抽象语法树（AST）。 Browsers often do this lazily, only parsing what they really need to at first and just creating stubs for functions which haven’t been called yet. 浏览器经常这样做，只是解析它们期初真正需要的内容，为尚未被调用的功能只是创建存根（stubs）。 From there, the AST is converted to an intermediate representation (called bytecode) that is specific to that JS engine. 然后，AST 被转换为特定于该 JS 引擎的中间表示（称为字节码）。 In contrast, WebAssembly doesn’t need to go through this transformation because it is already an intermediate representation. It just needs to be decoded and validated to make sure there aren’t any errors in it. 与此相比，WebAssembly 不需要经历这种转换，因为它已经是一个中间表示，它只需要被解码和验证，以确保没有任何错误。 编译+优化（Compiling + optimizing）As I explained in the article about the JIT, JavaScript is compiled during the execution of the code. Depending on what types are used at runtime, multiple versions of the same code may need to be compiled. 正如我在关于 JIT 的文章中所解释的，JavaScript 是在执行代码期间编译的。根据运行时使用的类型，可能需要编译相同代码的多个版本。 Different browsers handle compiling WebAssembly differently. Some browsers do a baseline compilation of WebAssembly before starting to execute it, and others use a JIT. 不同的浏览器处理编译 WebAssembly 的方式不同。一些浏览器在开始执行 WebAssembly 之前进行基线编译，其他浏览器使用 JIT。 Either way, the WebAssembly starts off much closer to machine code. For example, the types are part of the program. This is faster for a few reasons: The compiler doesn’t have to spend time running the code to observe what types are being used before it starts compiling optimized code. The compiler doesn’t have to compile different versions of the same code based on those different types it observes. More optimizations have already been done ahead of time in LLVM. So less work is needed to compile and optimize it. 无论使用哪种方式，WebAssembly 都是从更接近机器代码的方式开始的。例如，这些类型是程序的一部分。这是因为以下几个原因： 在开始编译优化的代码之前，编译器不必花时间运行代码来观察正在使用的类型。 编译器不必根据它观察到的不同类型编译同一代码的不同版本。 更多的优化已经在 LLVM 中提前完成。所以只需要很少的工作来编译和优化它。 重新优化（Reoptimizing）Sometimes the JIT has to throw out an optimized version of the code and retry it. 有时 JIT 必须抛出一个优化版本的代码并重试。 This happens when assumptions that the JIT makes based on running code turn out to be incorrect. For example, deoptimization happens when the variables coming into a loop are different than they were in previous iterations, or when a new function is inserted in the prototype chain. 特别是当基于运行代码的 JIT 的假设运行的结果不正确时，会发生这种情况。 例如，当进入循环的变量与前一个迭代不同时，或者在原型链中插入新函数时，会发生 去优化（deoptimization）。 There are two costs to deoptimization. First, it takes some time to bail out of the optimized code and go back to the baseline version. Second, if that function is still being called a lot, the JIT may decide to send it through the optimizing compiler again, so there’s the cost of compiling it a second time. 去优化有两个代价。 首先，需要一些时间才能取消优化代码，返回到基准版本。 第二，如果这个功能还是被调用很多，JIT 可能会决定再次使优化编译器处理它，所以第二次有编译成本。 In WebAssembly, things like types are explicit, so the JIT doesn’t need to make assumptions about types based on data it gathers during runtime. This means it doesn’t have to go through reoptimization cycles. 在 WebAssembly 中，诸如类型之类的东西是显式的，所以 JIT 不需要根据运行时收集的数据对类型进行假设。这意味着它不必经过优化周期。 执行（Executing）It is possible to write JavaScript that executes performantly. To do it, you need to know about the optimizations that the JIT makes. For example, you need to know how to write code so that the compiler can type specialize it, as explained in the article on the JIT. 编写执行性能好的 JavaScript 是可能的。要做到这一点，你需要了解 JIT 所做的优化。比如，你需要知道如何编写代码，以便编译器可以将其特化，正如 JIT 的文章所提到的那样。 However, most developers don’t know about JIT internals. Even for those developers who do know about JIT internals, it can be hard to hit the sweet spot. Many coding patterns that people use to make their code more readable (such as abstracting common tasks into functions that work across types) get in the way of the compiler when it’s trying to optimize the code. 然而，大多数开发人员不了解 JIT 内部。即使对于了解 JIT 内部部分的开发人员，也很难做到最佳。许多编码模式，人们用来使他们的代码更易于阅读（例如将常见任务抽象为跨类型工作的函数），在编译器试图优化代码时，会阻碍编译器的优化。 Plus, the optimizations a JIT uses are different between browsers, so coding to the internals of one browser can make your code less performant in another. 此外，JIT 的优化在不同浏览器是不同的，因此对一个浏览器的优化的代码可能在另一个浏览器中性能更低。 Because of this, executing code in WebAssembly is generally faster. Many of the optimizations that JITs make to JavaScript (such as type specialization) just aren’t necessary with WebAssembly. 因此，在 WebAssembly 中执行代码通常更快。 JIT 对 JavaScript 的许多优化（如类型专业化）在 WebAssembly 中不需要。 In addition, WebAssembly was designed as a compiler target. This means it was designed for compilers to generate, and not for human programmers to write. 此外，WebAssembly 被设计为编译器目标。 这意味着它是为编译器而设计的，而不是为了编程人员编写。 Since human programmers don’t need to program it directly, WebAssembly can provide a set of instructions that are more ideal for machines. Depending on what kind of work your code is doing, these instructions run anywhere from 10% to 800% faster. 由于人类程序员不需要直接编程，WebAssembly 可以提供一组更适合机器的指令。 根据你的代码正在做什么样的工作，这些指令的运行速度可以快 10% 到 800%。 垃圾回收（Garbage collection）In JavaScript, the developer doesn’t have to worry about clearing out old variables from memory when they aren’t needed anymore. Instead, the JS engine does that automatically using something called a garbage collector. 在 JavaScript，开发人员不必考虑在不再需要时从内存中清除旧的变量。相反，JS 引擎会自动执行垃圾收集器。 This can be a problem if you want predictable performance, though. You don’t control when the garbage collector does its work, so it may come at an inconvenient time. Most browsers have gotten pretty good at scheduling it, but it’s still overhead that can get in the way of your code’s execution. 这可能是一个问题，如果你想要可预测的性能，但是。你不能控制垃圾收集器的工作，所以垃圾回收可能会在不方便的时候进行。大多数浏览器已经很好的安排了它，但它仍然是开销，可能阻碍你的代码的执行。 At least for now, WebAssembly does not support garbage collection at all. Memory is managed manually (as it is in languages like C and C++). While this can make programming more difficult for the developer, it does also make performance more consistent. 至少现在，WebAssembly 根本不支持垃圾自动回收。 内存被手动管理（如 C 和 C++语言）。 虽然这可以使开发人员的编程变得更加困难，但它也使性能更加一致。 总结WebAssembly is faster than JavaScript in many cases because: fetching WebAssembly takes less time because it is more compact than JavaScript, even when compressed. decoding WebAssembly takes less time than parsing JavaScript. compiling and optimizing takes less time because WebAssembly is closer to machine code than JavaScript and already has gone through optimization on the server side. reoptimizing doesn’t need to happen because WebAssembly has types and other information built in, so the JS engine doesn’t need to speculate when it optimizes the way it does with JavaScript. executing often takes less time because there are fewer compiler tricks and gotchas that the developer needs to know to write consistently performant code, plus WebAssembly’s set of instructions are more ideal for machines. garbage collection is not required since the memory is managed manually. WebAssembly在许多情况下比JavaScript更快，因为： 获取 WebAssembly 需要较少的时间，因为它比 JavaScript 更紧凑，即使在 JavaScript 压缩时也是如此。 解码 WebAssembly 比解析 JavaScript 要花费更少的时间。 编译和优化需要更少的时间，因为 WebAssembly 比 JavaScript 更接近机器代码，并且已经在服务器端进行了优化。 重新优化不会发生，因为 WebAssembly 具有内置的类型和其他信息，所以 JS 引擎不需要像使用 JavaScript 的方式推测何时对其优化。 执行通常需要更少的时间，因为开发人员需要知道编写一贯性能代码的编译器技巧和问题较少，而 WebAssembly 的一组指令对于机器更为理想。 不需要垃圾收集，因为手动管理内存。 This is why, in many cases, WebAssembly will outperform JavaScript when doing the same task. 这就是为什么在许多情况下，在执行相同任务时，WebAssembly 将胜过 JavaScript。 There are some cases where WebAssembly doesn’t perform as well as expected, and there are also some changes on the horizon that will make it faster. I’ll cover those in the next article. 在某些情况下，WebAssembly 不像预期的那样执行，而且未来，还有一些改变将使其更快。我将在下一篇文章中介绍。","categories":[{"name":"翻译","slug":"翻译","permalink":"http://tcatche.site/categories/%E7%BF%BB%E8%AF%91/"}],"tags":[{"name":"WebAssembly","slug":"WebAssembly","permalink":"http://tcatche.site/tags/WebAssembly/"},{"name":"翻译","slug":"翻译","permalink":"http://tcatche.site/tags/%E7%BF%BB%E8%AF%91/"}]},{"title":"创建和使用 WebAssembly 模块 - Creating and working with WebAssembly modules","slug":"creating-and-working-with-webassembly-modules","date":"2017-06-30T07:42:00.000Z","updated":"2018-08-01T10:41:24.000Z","comments":true,"path":"2017/06/creating-and-working-with-webassembly-modules/","link":"","permalink":"http://tcatche.site/2017/06/creating-and-working-with-webassembly-modules/","excerpt":"","text":"原文：Creating and working with WebAssembly modules 本文译自Lin Clark 关于 WebAssembly 的卡通介绍系列，渣翻译，因此附上英文原文 概述： WebAssembly 的漫画介绍 背景： 碰撞课程：即时（JIT）编译器 碰撞课程：汇编 现在的 WebAssembly： 创建和使用 WebAssembly 模块 是什么使 WebAssembly 很快？ 未来的 WebAssembly： WebAssembly 的现状和未来？ WebAssembly is a way to run programming languages other than JavaScript on web pages. In the past when you wanted to run code in the browser to interact with the different parts of the web page, your only option was JavaScript. So when people talk about WebAssembly being fast, the apples to apples comparison is to JavaScript. But that doesn’t mean that it’s an either/or situation—that you are either using WebAssembly, or you’re using JavaScript. WebAssembly 是一种在网页上运行 JavaScript 以外的编程语言的方法。过去，当你想在浏览器中运行代码与网页的不同部分进行交互时，你唯一的选择是JavaScript。 所以当人们谈论 WebAssembly 很快的时候，就是和 JavaScript 对比的。但是，这并不意味着这是一个二选一的问题：使用 WebAssembly，或者使用JavaScript。 In fact, we expect that developers are going to use both WebAssembly and JavaScript in the same application. Even if you don’t write WebAssembly yourself, you can take advantage of it. WebAssembly modules define functions that can be used from JavaScript. So just like you download a module like lodash from npm today and call functions that are part of its API, you will be able to download WebAssembly modules in the future. So let’s see how we can create WebAssembly modules, and then how we can use them from JavaScript. 事实上，我们期望开发人员将在同一应用程序中同时使用 WebAssembly 和 JavaScript。即使你不自己编写 WebAssembly，你也可以利用它。 WebAssembly 模块定义了可以在 JavaScript 使用的函数。就像从 npm 下载一个像 lodash 这样的模块，并且调用其 API 。将来，你也可以下载 WebAssembly 模块。 那么让我们来看看我们如何创建 WebAssembly 模块，然后如何用 JavaScript 来使用。 WebAssembly 在哪里适合？In the article about assembly, I talked about how compilers take high-level programming languages and translate them to machine code. 在关于汇编的文章中，我讨论了编译器如何将高级编程语言转换为机器代码。 Where does WebAssembly fit into this picture? You might think it is just another one of the target assembly languages. That is kind of true, except that each one of those languages (x86, ARM ) corresponds to a particular machine architecture. WebAssembly 在这张图片的哪个位置呢？ 也许你认为这只是另一种目标汇编语言。这是真的，除了这些语言（x86，ARM）中的每一种对应于特定的机器体系结构。 When you’re delivering code to be executed on the user’s machine across the web, you don’t know what your target architecture the code will be running on. So WebAssembly is a little bit different than other kinds of assembly. It’s a machine language for a conceptual machine, not an actual, physical machine. 当你为网络上的用户提供机器上执行的代码时，你并不知道代码将运行的目标体系结构。 WebAssembly 与其他类型的程序集有所不同，它是概念机器的机器语言，而不是实际的物理机器。 Because of this, WebAssembly instructions are sometimes called virtual instructions. They have a much more direct mapping to machine code than JavaScript source code. They represent a sort of intersection of what can be done efficiently across common popular hardware. But they aren’t direct mappings to the particular machine code of one specific hardware. WebAssembly 指令有时称为虚拟指令。它们比 JavaScript 源代码更直接的映射到机器代码。它们代表了常见的硬件可以有效地完成的那些普遍的工作。但是它们并不直接映射到一个特定硬件的特定机器代码。 The browser downloads the WebAssembly. Then, it can make the short hop from WebAssembly to that target machine’s assembly code. 浏览器下载 WebAssembly。然后，它可以从 WebAssembly 跳转到目标机器的汇编代码。 编译为.wasmThe compiler tool chain that currently has the most support for WebAssembly is called LLVM. There are a number of different front-ends and back-ends that can be plugged into LLVM.Note: Most WebAssembly module developers will code in languages like C and Rust and then compile to WebAssembly, but there are other ways to create a WebAssembly module. For example, there is an experimental tool that helps you build a WebAssembly module using TypeScript, or you can code in the text representation of WebAssembly directly. 当前对 WebAssembly 支持最多的编译器工具链称为 LLVM。有许多不同的前端和后端可以插入到 LLVM 中。注意：大多数 WebAssembly 模块开发人员将使用 C 和 Rust 等语言进行编码，然后编译到 WebAssembly，但还有其他方法可以创建 WebAssembly 模块。例如，有一个实验工具可以帮助你使用 TypeScript 构建 WebAssembly 模块，也可以直接在 WebAssembly 的文本表示中进行编码。 Let’s say that we wanted to go from C to WebAssembly. We could use the clang front-end to go from C to the LLVM intermediate representation. Once it’s in LLVM’s IR, LLVM understands it, so LLVM can perform some optimizations. To go from LLVM’s IR (intermediate representation) to WebAssembly, we need a back-end. There is one that’s currently in progress in the LLVM project. That back-end is most of the way there and should be finalized soon. However, it can be tricky to get it working today. There’s another tool called Emscripten which is a bit easier to use at the moment. It has its own back-end that can produce WebAssembly by compiling to another target (called asm.js) and then converting that to WebAssembly. It uses LLVM under the hood, though, so you can switch between the two back-ends from Emscripten. 假设我们想从 C 到 WebAssembly。我们可以使用 clang 前端把 C 转换到 LLVM 中间表示。一旦在 LLVM 的 IR 中，LLVM 就会理解它，LLVM 可以执行一些优化。 要从 LLVM 的 IR（中间表示）到 WebAssembly，我们需要一个后端，目前 LLVM 项目中的后端正在开发中，这个后端是最重要的，会尽快完成，然而，现在很难让它工作起来。 还有另外一个名为 Emscripten 的工具，现在更容易使用。它有自己的后端，可以通过编译到另一个目标（称为asm.js），然后把它（asm.js） 转换为 WebAssembly。它的底层使用了 LLVM ，所以你可以在两个后端之间切换。 Emscripten includes many additional tools and libraries to allow porting whole C/C++ codebases, so it’s more of a software developer kit (SDK) than a compiler. For example, systems developers are used to having a filesystem that they can read from and write to, so Emscripten can simulate a file system using IndexedDB. Regardless of the toolchain you’ve used, the end result is a file that ends in .wasm. I’ll explain more about the structure of the .wasm file below. First, let’s look at how you can use it in JS. Emscripten 包含许多其他工具和库，可以移植整个 C/C++ 代码库，它比编译器更像是软件开发工具包（SDK）。比如，系统开发人员习惯于读取和写入的文件系统，而 Emscripten 可以使用IndexedDB 来模拟文件系统。 不管你使用什么样的工具链，最终的结果是生成以 .wasm 结尾的文件。我将在下面详细解释 .wasm 文件的结构。首先，我们来看看如何在 JS 中使用它。 在JavaScript中加载.wasm模块The .wasm file is the WebAssembly module, and it can be loaded in JavaScript. As of this moment, the loading process is a little bit complicated. .wasm 文件是 WebAssembly 模块，可以在 JavaScript 中加载。目前，装载过程有点复杂。 function fetchAndInstantiate(url, importObject) &#123; return fetch(url).then(response =&gt; response.arrayBuffer() ).then(bytes =&gt; WebAssembly.instantiate(bytes, importObject) ).then(results =&gt; results.instance );&#125; You can see this in more depth in our docs. 详细用法可以参考文档 We’re working on making this process easier. We expect to make improvements to the toolchain and integrate with existing module bundlers like webpack or loaders like SystemJS. We believe that loading WebAssembly modules can be as easy as as loading JavaScript ones. There is a major difference between WebAssembly modules and JS modules, though. Currently, functions in WebAssembly can only use numbers (integers or floating point numbers) as parameters or return values. 我们正在努力使这个过程更容易。我们期望对工具链进行改进，并与现有的模块打包程序如 Webpack ，或 SystemJS 加载器整合。我们相信，加载 WebAssembly 模块可以像加载 JavaScript 一样简单。 但是，WebAssembly 模块和 JS 模块之间存在很大差异。目前，WebAssembly 中的函数只能使用数值（整数或浮点数）作为参数或返回值。 For any data types that are more complex, like strings, you have to use the WebAssembly module’s memory. If you’ve mostly worked with JavaScript, having direct access to memory isn’t so familiar. More performant languages like C, C++, and Rust, tend to have manual memory management. The WebAssembly module’s memory simulates the heap that you would find in those languages. 对于任何更复杂的数据类型（如字符串），必须使用 WebAssembly 模块的内存。 如果你主要使用 JavaScript，对直接访问内存并不是很熟悉。而有更好性能的语言，如 C，C++ 和 Rust，往往具有手动内存管理。WebAssembly 模块的内存模拟你会在这些语言中使用的堆。 To do this, it uses something in JavaScript called an ArrayBuffer. The array buffer is an array of bytes. So the indexes of the array serve as memory addresses. If you want to pass a string between the JavaScript and the WebAssembly, you convert the characters to their character code equivalent. Then you write that into the memory array. Since indexes are integers, an index can be passed in to the WebAssembly function. Thus, the index of the first character of the string can be used as a pointer. 为此，它使用 JavaScript 中的 ArrayBuffer（数组缓冲区）。数组缓冲区是一个字节数组，因此，数组的索引可以作为内存地址。 如果要在 JavaScript 和 WebAssembly 之间传递一个字符串，则将字符转换为等效的字符码。然后你写入内存数组。由于索引是整数，因此可以将索引传入 WebAssembly 函数。如此，字符串的第一个字符的索引可以用作指针。 It’s likely that anybody who’s developing a WebAssembly module to be used by web developers is going to create a wrapper around that module. That way, you as a consumer of the module don’t need to know about memory management. If you want to learn more, check out our docs on working with WebAssembly’s memory. 开发 WebAssembly 模块的人员很可能围绕该模块创建一个包装器给 Web 开发人员使用。这样，模块的使用者不需要了解内存管理。 如果你想了解更多信息，请查看我们在使用 WebAssembly 内存的文档。 .wasm文件的结构If you are writing code in a higher level language and then compiling it to WebAssembly, you don’t need to know how the WebAssembly module is structured. But it can help to understand the basics. If you haven’t already, we suggest reading the article on assembly (part 3 of the series). 如果你使用较高级别的语言编写代码，然后将其编译到 WebAssembly ，则无需知道 WebAssembly 模块的结构。但它可以帮助了解基础知识。 如果还没有阅读之前汇编的文章，我们建议你先阅读。 Here’s a C function that we’ll turn into WebAssembly: 这是一个C函数，我们会将其转换为 WebAssembly： int add42(int num) &#123; return num + 42;&#125; You can try using the WASM Explorer to compile this function. If you open up the .wasm file (and if your editor supports displaying it), you’ll see something like this. 你可以尝试使用 WASM Explorer 编译此功能。 如果你打开了 .wasm 文件（如果你的编辑器支持显示它），你会看到这样的内容： 00 61 73 6D 0D 00 00 00 01 86 80 80 80 00 01 6001 7F 01 7F 03 82 80 80 80 00 01 00 04 84 80 8080 00 01 70 00 00 05 83 80 80 80 00 01 00 01 0681 80 80 80 00 00 07 96 80 80 80 00 02 06 6D 656D 6F 72 79 02 00 09 5F 5A 35 61 64 64 34 32 6900 00 0A 8D 80 80 80 00 01 87 80 80 80 00 00 2000 41 2A 6A 0B That is the module in its “binary” representation. I put quotes around binary because it’s usually displayed in hexadecimal notation, but that can be easily converted to binary notation, or to a human readable format. For example, here’s what num + 42 looks like. 那就是“二进制”表示的的模块。我用引号把“二进制”括起来，因为它通常以十六进制表示法显示，但可以很容易地转换成二进制符号，或者以人类可读的格式。 例如，这里是 num + 42 的样子。 代码如何工作：堆栈器（How the code works: a stack machine）In case you’re wondering, here’s what those instructions would do. 如果你想知道，这些指令会做什么。 You might have noticed that the add operation didn’t say where its values should come from. This is because WebAssembly is an example of something called a stack machine. This means that all of the values an operation needs are queued up on the stack before the operation is performed. 你可能已经注意到，add 操作符没有说明其值来自哪里。这是因为 WebAssembly 是一个堆栈机器。这是说在在执行操作之前，操作需要的所有值都在堆栈中排队。 Operations like add know how many values they need. Since add needs two, it will take two values from the top of the stack. This means that the add instruction can be short (a single byte), because the instruction doesn’t need to specify source or destination registers. This reduces the size of the .wasm file, which means it takes less time to download. 像 add 之类的操作知道它们运算需要多少值。由于 add 运算需要两个，它将从堆栈的顶部获取两个值。这意味着 add 指令可以是短的（单个字节），因为指令不需要指定源寄存器或目标寄存器。这减少了 .wasm 文件的大小，意味着需要更少的时间来下载文件。 Even though WebAssembly is specified in terms of a stack machine, that’s not how it works on the physical machine. When the browser translates WebAssembly to the machine code for the machine the browser is running on, it will use registers. Since the WebAssembly code doesn’t specify registers, it gives the browser more flexibility to use the best register allocation for that machine. 即使 WebAssembly 是根据堆栈机器来指定的，但是这并不是它在物理机上的工作原理。当浏览器将 WebAssembly 代码没有指定寄存器，因此这使浏览器可以更灵活地使用该机器的最佳寄存器分配。 模块部分Besides the add42 function itself, there are other parts in the .wasm file. These are called sections. Some of the sections are required for any module, and some are optional. 除了 add42 函数本身，.wasm 文件中的其他部分。这些被称为 sections 。某些 sections 是必选的，任何模块都需要，有些 sections 是可选的。 Required: Type. Contains the function signatures for functions defined in this module and any imported functions. Function. Gives an index to each function defined in this module. Code. The actual function bodies for each function in this module. 必选的： Type: 包含定义在本模块的函数和导入函数的签名。 Function: 为此模块中定义的每个功能提供索引。 Code: 本模块中每个函数的实际函数体。 Optional: Export. Makes functions, memories, tables, and globals available to other WebAssembly modules and JavaScript. This allows separately-compiled modules to be dynamically linked together. This is WebAssembly’s version of a .dll. Import. Specifies functions, memories, tables, and globals to import from other WebAssembly modules or JavaScript. Start. A function that will automatically run when the WebAssembly module is loaded (basically like a main function). Global. Declares global variables for the module. Memory. Defines the memory this module will use. Table. Makes it possible to map to values outside of the WebAssembly module, such as JavaScript objects. This is especially useful for allowing indirect function calls. Data. Initializes imported or local memory. Element. Initializes an imported or local table. 可选的： Export: 使函数，内存，表格和全局变量可用于其他 WebAssembly 模块和 JavaScript。这允许单独编译的模块动态链接在一起。这是 WebAssembly 版本的 .dll。 Import: 指定从其他 WebAssembly 模块或 JavaScript 中导入的函数，内存，表和全局定义。 Start: 一种在加载 WebAssembly 模块时将自动运行的函数（基本上类似 main 函数）。 Global: 声明模块的全局变量。 Memory: 定义该模块将使用的内存。 Table: 可以映射到 WebAssembly 模块以外的值，例如 JavaScript 对象。这对于间接函数调用特别有用。 Data: 初始化导入的或本地内存。 Element: 初始化导入或本地表。 For more on sections, here’s a great in-depth explanation of how these sections work. 有关部分的更多内容，这里将详细介绍这些部分的工作原理。 下一节Now that you know how to work with WebAssembly modules, let’s look at why WebAssembly is fast. 现在，你已经知道如何使用 WebAssembly 模块，接下来我们来看看 WebAssembly 为什么很快。","categories":[{"name":"翻译","slug":"翻译","permalink":"http://tcatche.site/categories/%E7%BF%BB%E8%AF%91/"}],"tags":[{"name":"WebAssembly","slug":"WebAssembly","permalink":"http://tcatche.site/tags/WebAssembly/"}]},{"title":"碰撞课程：汇编 - A crash course in assembly","slug":"a-crash-course-in-assembly","date":"2017-06-30T02:56:00.000Z","updated":"2018-08-01T10:41:24.000Z","comments":true,"path":"2017/06/a-crash-course-in-assembly/","link":"","permalink":"http://tcatche.site/2017/06/a-crash-course-in-assembly/","excerpt":"","text":"原文：A crash course in just-in-time (JIT) compilers 本文译自Lin Clark 关于 WebAssembly 的卡通介绍系列，渣翻译，因此附上英文原文 概述： WebAssembly 的漫画介绍 背景： 碰撞课程：即时（JIT）编译器 碰撞课程：汇编 现在的 WebAssembly： 创建和使用 WebAssembly 模块 是什么使 WebAssembly 很快？ 未来的 WebAssembly： WebAssembly 的现状和未来？ To understand how WebAssembly works, it helps to understand what assembly is and how compilers produce it. In the article on the JIT, I talked about how communicating with the machine is like communicating with an alien. 要了解 WebAssembly 如何工作，先理解 assembly（汇编） 是什么，以及编译器如何生成它会很有帮助。 在上一篇关于 JIT 的文章中，我谈到了与机器的通信就像与外星人通信。 I want to take a look now at how that alien brain works—how the machine’s brain parses and understands the communication coming in to it. There’s a part of this brain that’s dedicated to the thinking—things like adding and subtracting, or logical operations. There’s also a part of the brain near that which provides short-term memory, and another part that provides longer-term memory. 我想看看这个外星人的大脑如何工作——机器的大脑如何解析和理解通信。 这个大脑中有一部分专注于思考，例如加法和减法，或逻辑操作。附近还有一部分提供短期记忆的大脑，还有另一部分提供长期记忆。 These different parts have names. The part that does the thinking is the Arithmetic-logic Unit (ALU). The short term memory is provided by registers. The longer term memory is the Random Access Memory (or RAM). 这三部分都有名字： 思考的部分是算术逻辑单元（ALU） 短期记忆由寄存器提供。 长期存储器是随机存取存储器（或 RAM ）。 The sentences in machine code are called instructions. What happens when one of these instructions comes into the brain? It gets split up into different parts that mean different things. The way that this instruction is split up is specific to the wiring of this brain. 机器码中的句子被称为指令。当这些中的一个指令进入大脑时会发生什么？ 它分成不同的部分，意味着不同的东西。这个指令分开的方式是针对这个大脑的布线。 For example, a brain that is wired like this might always take the first six bits and pipe that in to the ALU. The ALU will figure out, based on the location of ones and zeros, that it needs to add two things together. This chunk is called the “opcode”, or operation code, because it tells the ALU what operation to perform. 例如，像这样布线的大脑总是可以将前六位和管道连接到 ALU。 ALU将根据 1 和 0 的位置确认它需要将两者加在一起。 这个块被称为“操作码”或操作代码，因为它告诉 ALU 执行什么操作。 Then this brain would take the next two chunks of three bits each to determine which two numbers it should add. These would be addresses of the registers. 然后这个大脑会把接下来的代码块分成两个三位来确定它应该执行加法的两个数字。这些都是是寄存器的地址。 Note the annotations above the machine code here, which make it easier for us humans to understand what’s going on. This is what assembly is. It’s called symbolic machine code. It’s a way for humans to make sense of the machine code. You can see here there is a pretty direct relationship between the assembly and the machine code for this machine. Because of this, there are different kinds of assembly for the different kinds of machine architectures that you can have. When you have a different architecture inside of a machine, it is likely to require its own dialect of assembly. So we don’t just have one target for our translation. It’s not just one language called machine code. It’s many different kinds of machine code. Just as we speak different languages as people, machines speak different languages. 请注意这里的机器码上面的注释，这使得我们人类更容易了解发生了什么。这就是汇编语言的内容，它被称为符号机器代码。这是人类理解机器代码的方式。 你可以看到汇编语言和机器代码之间有一个非常直接的关系。正因为因此，对于不同类型的机器架构，会有不同类型的汇编语言。当你有一种不同的机器内部架构时，你可能需要自己的汇编语言方言。 所以我们不是只有一个翻译目标，它也不只是一种称为机器码的语言。实际上，有很多种不同的机器码，就像我们使用不同的语言一样，机器也说不同的语言。 With human to alien translation, you may be going from English, or Russian, or Mandarin to Alien Language A or Alien language B. In programming terms, this is like going from C, or C++, or Rust to x86 or to ARM. You want to be able to translate any one of these high-level programming languages down to any one of these assembly languages (which corresponds to the different architectures). One way to do this would be to create a whole bunch of different translators that can go from each language to each assembly. 通过人与外星人的翻译，您可能会从英语，俄语或普通话转换到到外星人语言A或外来语言B。在编程方面，这就像从 C 或 C++，或 Rust 到 x86 或 ARM。 你希望能够将这些高级编程语言中的任何一种转换为这些汇编语言中的任何一种（对应于不同架构）。这样做的一个方法是创建一大堆不同的翻译器，可以从每种语言转到每个程序集。 That’s going to be pretty inefficient. To solve this, most compilers put at least one layer in between. The compiler will take this high-level programming language and translate it into something that’s not quite as high level, but also isn’t working at the level of machine code. And that’s called an intermediate representation (IR). 这将是非常低效的。为了解决这个问题，大多数编译器在两者之间至少放置了一层中间层。编译器通常接收高级编程语言，并将其转换为不太高的级别，但也不能在机器代码级别工作。这就是所谓的中间表示（IR）。 This means the compiler can take any one of these higher-level languages and translate it to the one IR language. From there, another part of the compiler can take that IR and compile it down to something specific to the target architecture. The compiler’s front-end translates the higher-level programming language to the IR. The compiler’s backend goes from IR to the target architecture’s assembly code. 这意味着编译器可以处理这些更高级别的语言中的任何一种，将其转换为一种 IR 语言。随后，编译器的另一部分可以处理该 IR 将其编译为特定于目标架构的特定内容。 编译器的前端将高级编程语言转换为 IR 。编译器的后端将 IR 转换到目标架构的汇编代码。 That’s what assembly is and how compilers translate higher-level programming languages to assembly. In the next article, we’ll see how WebAssembly fits in to this. 这就是汇编和编译器如何将更高级的编程语言翻译成汇编的过程。在下一篇文章中，我们将看到 WebAssembly 如何和这相符。","categories":[{"name":"翻译","slug":"翻译","permalink":"http://tcatche.site/categories/%E7%BF%BB%E8%AF%91/"}],"tags":[{"name":"WebAssembly","slug":"WebAssembly","permalink":"http://tcatche.site/tags/WebAssembly/"}]},{"title":"碰撞课程：即时（JIT）编译器 - A crash course in just-in-time (JIT) compilers","slug":"a-crash-course-in-just-in-time-jit-compilers","date":"2017-06-29T07:12:00.000Z","updated":"2018-08-01T10:41:24.000Z","comments":true,"path":"2017/06/a-crash-course-in-just-in-time-jit-compilers/","link":"","permalink":"http://tcatche.site/2017/06/a-crash-course-in-just-in-time-jit-compilers/","excerpt":"","text":"原文：A crash course in just-in-time (JIT) compilers 本文译自Lin Clark 关于 WebAssembly 的卡通介绍系列，渣翻译，因此附上英文原文 概述： WebAssembly 的漫画介绍 背景： 碰撞课程：即时（JIT）编译器 碰撞课程：汇编 现在的 WebAssembly： 创建和使用 WebAssembly 模块 是什么使 WebAssembly 很快？ 未来的 WebAssembly： WebAssembly 的现状和未来？ JavaScript started out slow, but then got faster thanks to something called the JIT. But how does the JIT work? JavaScript 刚开始很慢，但是后来多亏 JIT 变得快了。但 JIT 是如何工作呢？ JavaScript 如何在浏览器中运行When you as a developer add JavaScript to the page, you have a goal and a problem. Goal: you want to tell the computer what to do. Problem: you and the computer speak different languages. 当你作为开发者，向页面添加 JavaScript 时，有一个目标和一个问题： 目标：你要告诉电脑做什么 问题：你和电脑使用不同的语言 You speak a human language, and the computer speaks a machine language. Even if you don’t think about JavaScript or other high-level programming languages as human languages, they really are. They’ve been designed for human cognition, not for machine cognition. So the job of the JavaScript engine is to take your human language and turn it into something the machine understands. I think of this like the movie Arrival, where you have humans and aliens who are trying to talk to each other. 你说人类语言，计算机说机器语言。即使你不将 JavaScript 或其他高级编程语言视为人类语言，但它们就是。它们被设计于人的认知，而不是机器认知。 所以 JavaScript 引擎的工作就是把你的人类语言（JavaScript）转化成机器所理解的东西。 我想这就像电影 Arrival，人类和外星人试图相互交谈。 In that movie, the humans and aliens don’t just do word-for-word translations. The two groups have different ways of thinking about the world. And that’s true of humans and machines too (I’ll explain this more in the next post). 在那部电影中，人类和外星人不仅仅是做单词翻译。这两个群体对世界有不同的思考方式。人类和机器也是如此（我将在下一篇文章中解释一下）。 So how does the translation happen? In programming, there are generally two ways of translating to machine language. You can use an interpreter or a compiler. With an interpreter, this translation happens pretty much line-by-line, on the fly. 那么翻译如何发生呢？ 在编程中，通常有两种翻译成机器语言的方法：解释器或编译器。 使用解释器，翻译几乎一行一行的进行。 A compiler on the other hand doesn’t translate on the fly. It works ahead of time to create that translation and write it down. 而编译器并不能即时翻译，它需要提前工作来创建翻译并写下来。 There are pros and cons to each of these ways of handling the translation. 每种处理翻译的方法都有利弊。 解释器的利弊Interpreters are quick to get up and running. You don’t have to go through that whole compilation step before you can start running your code. You just start translating that first line and running it. Because of this, an interpreter seems like a natural fit for something like JavaScript. It’s important for a web developer to be able to get going and run their code quickly. And that’s why browsers used JavaScript interpreters in the beginning. 解释器可以快速启动和运行，在代码运行之前，你不需要经过整个的编译步骤。你可以直接从第一行开始翻译和运行。 正因为如此，解释器和 JavaScript 天然适合。对于Web开发人员来说，重要的是能够快速运行代码。 这就是浏览器一开始就使用 JavaScript 解释器的原因。 But the con of using an interpreter comes when you’re running the same code more than once. For example, if you’re in a loop. Then you have to do the same translation over and over and over again. 但解释器的弊端在于，当你运行同样的代码超过一次，比如你在循环中，你必须一遍又一遍地做同样的翻译。 编译器的利弊The compiler has the opposite trade-offs. It takes a little bit more time to start up because it has to go through that compilation step at the beginning. But then code in loops runs faster, because it doesn’t need to repeat the translation for each pass through that loop. Another difference is that the compiler has more time to look at the code and make edits to it so that it will run faster. These edits are called optimizations. The interpreter is doing its work during runtime, so it can’t take much time during the translation phase to figure out these optimizations. 编译器有相反的利弊。 它需要更多的时间才能开始运行，因为它在开始前需要整个的编译步骤。但是程序在循环中会运行很快，因为他不需要重复翻译循环中的每一行。 另一个不同点在于，解释器有更多的事件去产看代码并编辑，因此它会运行的更快。这些编辑称为优化。 而解释器在运行时工作，因此在翻译截断无法花费更多时间来优化。 JIT 翻译器：两个世界最好的As a way of getting rid of the interpreter’s inefficiency—where the interpreter has to keep retranslating the code every time they go through the loop—browsers started mixing compilers in. Different browsers do this in slightly different ways, but the basic idea is the same. They added a new part to the JavaScript engine, called a monitor (aka a profiler). That monitor watches the code as it runs, and makes a note of how many times it is run and what types are used. 浏览器解决解释器低效率——解释器每次循环时不断重新翻译——的方法，使用混合编译器。 不同的浏览器的实现方法是不一样的，但是它们的思想是一样的。它们向 JS 引擎添加了一个新部分，称之为监视器（也成为分析器）。监视器监视代码的运行，并记录运行次数以及使用类型。 At first, the monitor just runs everything through the interpreter. 首先，监视器通过翻译器运行所有内容。 If the same lines of code are run a few times, that segment of code is called warm. If it’s run a lot, then it’s called hot. 如果同一段代码运行好几次，这段代码被称为“暖代码（ warm code ）” ，如果被运行多次，则称之为“热代码（ hot code）”。 基线编译器（Baseline compiler）When a function starts getting warm, the JIT will send it off to be compiled. Then it will store that compilation. 当功能开始变暖时，JIT会将其发送出去编译，然后存储该编译。 Each line of the function is compiled to a “stub”. The stubs are indexed by line number and variable type (I’ll explain why that’s important later). If the monitor sees that execution is hitting the same code again with the same variable types, it will just pull out its compiled version. That helps speed things up. But like I said, there’s more a compiler can do. It can take some time to figure out the most efficient way to do things… to make optimizations. 函数的每一行都被编译为 Stub 。Stub 按行号和变量类型进行索引（稍后我将解释这为什么重要）。如果监视器看到使用同一变量类型的代码再次执行，那么它将拉出其编译的版本执行。 这有助于加快速度。但是像我说的那样，编译器可以做的更多。可能需要一些时间才能找出最有效的方式来做事情…来进行优化。 The baseline compiler will make some of these optimizations (I give an example of one below). It doesn’t want to take too much time, though, because it doesn’t want to hold up execution too long. However, if the code is really hot—if it’s being run a whole bunch of times—then it’s worth taking the extra time to make more optimizations. 基线编译器将进行一些这些优化（下面给出一个例子）。但是，它不会花费太多时间优化，因为它不希望执行太久。 然而，如果代码真的 hot，如果它被运行很多次，那么它花费额外的时间进行更多的优化是值得的。 优化编译器When a part of the code is very hot, the monitor will send it off to the optimizing compiler. This will create another, even faster, version of the function that will also be stored. 当代码的一部分非常 hot 时，显示器将发送给优化编译器，这将创建另一个甚至更快的版本，这个版本也将被存储。 In order to make a faster version of the code, the optimizing compiler has to make some assumptions. 为了编译出速度更快的代码，优化编译器必须做出一些假设。 For example, if it can assume that all objects created by a particular constructor have the same shape—that is, that they always have the same property names, and that those properties were added in the same order— then it can cut some corners based on that. The optimizing compiler uses the information the monitor has gathered by watching code execution to make these judgments. If something has been true for all previous passes through a loop, it assumes it will continue to be true. 例如，如果可以假定由特定构造函数创建的所有对象具有相同的特征，也就是说，它们经常会有相同的属性名，那些属性以相同的顺序添加，那么编译器可以根据这些削减一些角落。 优化编译器使用监视器收集的信息，通过观察代码执行来做出这些判断。如果所有先前的代码确实被循环执行，那么假设它将继续被执行。 But of course with JavaScript, there are never any guarantees. You could have 99 objects that all have the same shape, but then the 100th might be missing a property. So the compiled code needs to check before it runs to see whether the assumptions are valid. If they are, then the compiled code runs. But if not, the JIT assumes that it made the wrong assumptions and trashes the optimized code. 但是，JavaScript 当然是从来没有任何保证。可能有 99 个对象都具有相同的特征，但是第 100 个可能会丢失一个属性。 所以编译的代码需要在运行之前检查以确定假设是否有效。如果是，则编译的代码运行。但如果没有，JIT 假定它做出了错误的假设，并且删除了优化的代码。 Then execution goes back to the interpreter or baseline compiled version. This process is called deoptimization (or bailing out). Usually optimizing compilers make code faster, but sometimes they can cause unexpected performance problems. If you have code that keeps getting optimized and then deoptimized, it ends up being slower than just executing the baseline compiled version. Most browsers have added limits to break out of these optimization/deoptimization cycles when they happen. If the JIT has made more than, say, 10 attempts at optimizing and keeps having to throw it out, it will just stop trying. 然后执行解释器或基线编译版本。这个过程叫做“去优化（ deoptimization ）”（或 bailing out ）。 通常优化编译器可使代码更快，但有时候会导致意外的性能问题。如果你的代码不断得到优化，然后去优化，最终会比仅执行基线编译版本慢。 大多数浏览器增加了限制，以便在发生这些优化/去优化周期时停止。如果 JIT 已经超过 10 次尝试优化/去优化，那么它将停止尝试。 优化示例：类型专业化There are a lot of different kinds of optimizations, but I want to take a look at one type so you can get a feel for how optimization happens. One of the biggest wins in optimizing compilers comes from something called type specialization. The dynamic type system that JavaScript uses requires a little bit of extra work at runtime. For example, consider this code: 有很多不同类型的优化，但是我想看看其中一种优化，以便你可以感受到如何进行优化。优化编译器的最大优势之一来自于类型专业化。 JavaScript 使用的动态类型在运行时需要一点额外的工作。例如，考虑这个代码： function arraySum(arr) &#123; var sum = 0; for (var i = 0; i &lt; arr.length; i++) &#123; sum += arr[i]; &#125;&#125; The += step in the loop may seem simple. It may seem like you can compute this in one step, but because of dynamic typing, it takes more steps than you would expect. Let’s assume that arr is an array of 100 integers. Once the code warms up, the baseline compiler will create a stub for each operation in the function. So there will be a stub for sum += arr[i], which will handle the += operation as integer addition. However,sum and arr[i] aren’t guaranteed to be integers. Because types are dynamic in JavaScript, there’s a chance that in a later iteration of the loop, arr[i] will be a string. Integer addition and string concatenation are two very different operations, so they would compile to very different machine code. 循环中的 += 步骤看起来很简单。看起来可以一步一步地计算出来，但是由于动态输入，所以需要比预期的更多的步骤。 我们假设 arr 是有 100 个整数的数组。一旦代码加热，基准编译器将为函数中的每个操作创建一个 stub 。所以将会有一个 sum += arr[i] 的存根，它将处理 += 操作作为整数加法。 然而，sum 和 arr[i] 不能保证是整数。因为 JavaScript 中的类型是动态的，所以在循环的后续迭代中有可能 arr[i] 将是一个字符串。整数加法和字符串连接是两个非常不同的操作，它们将编译为不同的机器代码。 The way the JIT handles this is by compiling multiple baseline stubs. If a piece of code is monomorphic (that is, always called with the same types) it will get one stub. If it is polymorphic (called with different types from one pass through the code to another), then it will get a stub for each combination of types that has come through that operation. This means that the JIT has to ask a lot of questions before it chooses a stub. JIT 处理这个的方式是编译多个基线 stub 。如果一段代码是单一的（也就是说，始终相同的类型调用），它将获得一个 stub 。如果它是多态的（使用不同类型调用，从一个代码调用到另一个），那么它将获得通过该操作的每种类型的组合的 stub 。 这意味着 JIT 在选择一个 stub 之前必须提出很多问题。 Because each line of code has its own set of stubs in the baseline compiler, the JIT needs to keep checking the types each time the line of code is executed. So for each iteration through the loop, it will have to ask the same questions. 因为每行代码在基准编译器中都有自己的一组 stub ，所以 JIT 需要在每次执行代码行时继续检查类型。所以对于循环的每次迭代，它不得不提出相同的问题。 The code would execute a lot faster if the JIT didn’t need to repeat those checks. And that’s one of the things the optimizing compiler does. In the optimizing compiler, the whole function is compiled together. The type checks are moved so that they happen before the loop. 如果 JIT 不需要重复这些检查，代码将执行得更快。这就是优化编译器所做的一项工作。 在优化编译器中，整个函数被编译在一起。类型检查被移动，以便它们在循环之前发生。 Some JITs optimize this even further. For example, in Firefox there’s a special classification for arrays that only contain integers. If arr is one of these arrays, then the JIT doesn’t need to check if arr[i] is an integer. This means that the JIT can do all of the type checks before it enters the loop. 一些 JIT 会进一步优化。例如，在 Firefox 中，只有包含整数的数组有一个特殊的分类。如果 arr 是这些数组之一，则 JIT 不需要检查 arr[i] 是否为整数，这意味着 JIT 可以在进入循环前执行所有类型检查。 总结That is the JIT in a nutshell. It makes JavaScript run faster by monitoring the code as it’s running it and sending hot code paths to be optimized. This has resulted in many-fold performance improvements for most JavaScript applications. 这就是简单描绘的 JIT，通过监视代码的运行并发送热代码优化，使 JavaScript 运行速度更快。这为大多数 JavaScript 应用程序带来许多性能提升。 Even with these improvements, though, the performance of JavaScript can be unpredictable. And to make things faster, the JIT has added some overhead during runtime, including: optimization and deoptimization memory used for the monitor’s bookkeeping and recovery information for when bailouts happen memory used to store baseline and optimized versions of a function 然而，即使有了这些改进，JavaScript 的性能也不可预知。为了使运行更快，JIT 在运行时增加了一些开销，包括： 优化和去优化 消耗内存存储监视器的记录和去优化时的恢复信​​息 消耗内存存储基准和优化版本功能 There’s room for improvement here: that overhead could be removed, making performance more predictable. And that’s one of the things that WebAssembly does. In the next article, I’ll explain more about assembly and how compilers work with it. 这里有改进的余地：可以消除开销，使性能更可预测。这是 WebAssembly 所做的事情之一。 在下一篇文章中，我将解释更多的 assembly 信息以及编译器如何和它一起工作。","categories":[{"name":"翻译","slug":"翻译","permalink":"http://tcatche.site/categories/%E7%BF%BB%E8%AF%91/"}],"tags":[{"name":"WebAssembly","slug":"WebAssembly","permalink":"http://tcatche.site/tags/WebAssembly/"},{"name":"JIT","slug":"JIT","permalink":"http://tcatche.site/tags/JIT/"}]},{"title":"WebAssembly 的漫画介绍 - A cartoon intro to WebAssembly","slug":"a-cartoon-intro-to-webassembly","date":"2017-06-29T02:39:00.000Z","updated":"2018-08-01T10:41:24.000Z","comments":true,"path":"2017/06/a-cartoon-intro-to-webassembly/","link":"","permalink":"http://tcatche.site/2017/06/a-cartoon-intro-to-webassembly/","excerpt":"","text":"原文：A cartoon intro to WebAssembly 本文译自Lin Clark 关于 WebAssembly 的卡通介绍系列，渣翻译，因此附上英文原文 概述： WebAssembly 的漫画介绍 背景： 碰撞课程：即时（JIT）编译器 碰撞课程：汇编 现在的 WebAssembly： 创建和使用 WebAssembly 模块 是什么使 WebAssembly 很快？ 未来的 WebAssembly： WebAssembly 的现状和未来？ WebAssembly is fast. You’ve probably heard this. But what is it that makes WebAssembly fast? In this series, I want to explain to you why WebAssembly is fast. 你可能听说过, WebAssembly 很快，但是它为什么很快呢？ 在这个系列，我会解释它为什么很快。 等等，那么什么是 WebAssemblyWebAssembly is a way of taking code written in programming languages other than JavaScript and running that code in the browser. So when people say that WebAssembly is fast, what they are comparing it to is JavaScript. Now, I don’t want to imply that it’s an either/or situation — that you’re either using WebAssembly or using JavaScript. In fact, we expect that developers will use both WebAssembly and JavaScript in the same application. But it is useful to compare the two, so you can understand the potential impact that WebAssembly will have. WebAssembly 是一种使其他语言而非 JavaScript 编写的代码在浏览器中运行的方式。所以当人们说 WebAssembly 快，是因为和 JavaScript 比较。 现在，我不想暗示这是一个二选一的情况：你要么使用 WebAssembly 或者使用 JavaScript。事实上，我们希望开发人员在同一个应用程序中同时使用 WebAssembly 和 JavaScript。 但是比较两者是有用的，你可以了解 WebAssembly 将具有的潜在影响。 一点关于性能的历史JavaScript was created in 1995. It wasn’t designed to be fast, and for the first decade, it wasn’t fast. Then the browsers started getting more competitive. JavaScript 是在 1995 年创建的。它并不被设计得很快，在第一个十年，它不是很快。 然后，浏览器开始变得更有竞争力了。 In 2008, a period that people call the performance wars began. Multiple browsers added just-in-time compilers, also called JITs. As JavaScript was running, the JIT could see patterns and make the code run faster based on those patterns. The introduction of these JITs led to an inflection point in the performance of JavaScript. Execution of JS was 10x faster. 2008 年，人们称之为表演战的时期开始了。多个浏览器添加了即时编译器，也称为 JIT 。当 JavaScript 运行时，JIT 可以看出模式，并根据这些模式使代码运行得更快。 JIT 的引入正是了 JavaScript 性能转折点。JS 的执行速度提高了 10 倍。 With this improved performance, JavaScript started being used for things no one ever expected it to be used for, like server-side programming with Node.js. The performance improvement made it feasible to use JavaScript on a whole new class of problems. We may be at another one of those inflection points now, with WebAssembly. 随着性能的改进，JavaScript 开始被用于以前没有人想过的地方，像使用 Node.js 的服务器端编程。性能改进使得使用 JavaScript 在一整个新类别的问题上变得可行。 现在有了 WebAssembly，我们可能会在另一个拐点。 So, let’s dive into the details to understand what makes WebAssembly fast. 所以，我们来详细了解一下是什么使 WebAssembly 快速。","categories":[{"name":"翻译","slug":"翻译","permalink":"http://tcatche.site/categories/%E7%BF%BB%E8%AF%91/"}],"tags":[{"name":"WebAssembly","slug":"WebAssembly","permalink":"http://tcatche.site/tags/WebAssembly/"},{"name":"JIT","slug":"JIT","permalink":"http://tcatche.site/tags/JIT/"}]},{"title":"碰撞课程：ArrayBuffers 和 SharedArrayBuffers - A cartoon intro to ArrayBuffers and SharedArrayBuffers","slug":"a-cartoon-intro-to-arraybuffers-and-sharedarraybuffers","date":"2017-06-28T09:01:00.000Z","updated":"2018-08-01T10:41:24.000Z","comments":true,"path":"2017/06/a-cartoon-intro-to-arraybuffers-and-sharedarraybuffers/","link":"","permalink":"http://tcatche.site/2017/06/a-cartoon-intro-to-arraybuffers-and-sharedarraybuffers/","excerpt":"","text":"原文：A cartoon intro to ArrayBuffers and SharedArrayBuffers 这是系列内三篇文章的第二篇： 内存管理 ArrayBuffers 和 SharedArrayBuffers 的卡通介绍 使用 Atom 避免 ArrayBuffers 中的竞态条件 概述In the last article, I explained how memory-managed languages like JavaScript work with memory. I also explained how manual memory management works in languages like C. 在上一篇文章中，我解释了像 JavaScript 这样的内存管理语言是如何工作的。我还解释了手动内存管理（比如 C 语言）如何工作。 Why is this important when we’re talking about ArrayBuffers and SharedArrayBuffers? It’s because ArrayBuffers give you a way to handle some of your data manually, even though you’re working in JavaScript, which has automatic memory management. 为什么这很重要，当我们谈论 ArrayBuffers 和 SharedArrayBuffers 时？ 因为 ArrayBuffers 为你提供了手动处理某些数据的方法，即使你使用的是自动内存管理的 JavaScript。 Why is this something that you would want to do? As we talked about in the last article, there’s a trade-off with automatic memory management. It is easier for the developer, but it adds some overhead. In some cases, this overhead can lead to performance problems. 为什么要这样做？ 正如我们在上一篇文章中谈到的那样，自动内存管理有这样的选择：对于开发人员更容易使用，但增加了一些开销，而在某些情况下，这种开销可能会导致性能问题。 For example, when you create a variable in JS, the engine has to guess what kind of variable this is and how it should be represented in memory. Because it’s guessing, the JS engine will usually reserve more space than it really needs for a variable. Depending on the variable, the memory slot may be 2–8 times larger than it needs to be, which can lead to lots of wasted memory. Additionally, certain patterns of creating and using JS objects can make it harder to collect garbage. If you’re doing manual memory management, you can choose an allocation and de-allocation strategy that’s right for the use case that you’re working on. 比如，当你在 JS 中创建变量时，JS 引擎必须猜测这是什么类型的变量，以及如何在内存中表示。这种猜测导致 JS 引擎通常会比为变量准备更多的空间。根据变量，内存占据的可能比需要大 2-8 倍，这会导致浪费大量的内存。 此外，创建和使用 JS 对象的某些模式，可能会使收集垃圾更难进行。如果你使用手动内存管理，则可以选择适用于你的情况的内存分配和释放策略。 Most of the time, this isn’t worth the trouble. Most use cases aren’t so performance sensitive that you need to worry about manual memory management. And for common use cases, manual memory management may even be slower. But for those times when you need to work at a low-level to make your code as fast as possible, ArrayBuffers and SharedArrayBuffers give you an option. 大多数时候，这不是个麻烦。大多数情况下对性能的要求并不敏感到需要手动内存管理。甚至对于一些常见情况下，手动内存管理可能会更慢。 但是对于那些需要在底层工作以使代码尽可能快的时候，ArrayBuffers 和 SharedArrayBuffers 为你提供了另一个选择。 ArrayBuffer 如何工作呢？It’s basically like working with any other JavaScript array. Except, when using an ArrayBuffer, you can’t put any JavaScript types into it, like objects or strings. The only thing that you can put into it are bytes (which you can represent using numbers). ArrayBuffer 基本上就像使用任何其他 JavaScript 数组。除了使用 ArrayBuffer 时，你不能将任何 JavaScript 类型放入其中，例如对象或字符串。唯一可以放入的是二进制字节（可以使用数字表示）。 One thing I should make clear here is that you aren’t actually adding this byte directly to the ArrayBuffer. By itself, this ArrayBuffer doesn’t know how big the byte should be, or how different kinds of numbers should be converted to bytes. The ArrayBuffer itself is just a bunch of zeros and ones all in a line. The ArrayBuffer doesn’t know where the division should be between the first element and the second element in this array. 有一点我需要明确指出，你并不能将这个字节直接添加到 ArrayBuffer 中。ArrayBuffer 本身不知道字节应该有多大，或者不同类型的数字如何转换成字节。 ArrayBuffer 本身就是一堆 0 和 1 全部放在一行。它并不知道这个数组中的第一个元素和第二个元素如何区分。 To provide context, to actually break this up into boxes, we need to wrap it in what’s called a view. These views on the data can be added with typed arrays, and there are lots of different kinds of typed arrays they can work with. For example, you could have an Int8 typed array which would break this up into 8-bit bytes. 为了提供上下文，实际上将其分成多个盒子（注：就是把这一整行的 01 分割成多个分组），我们需要将它包装在视图中。这些数据视图可以添加为类型化的数组，并且有很多不同类型的类型数组可以使用。 例如，你可以使用 Int8 类型的数组，将其分解为 8 位一组。 Or you could have an unsigned Int16 array, which would break it up into 16-bit bites, and also handle this as if it were an unsigned integer. 或者你可以使用无符号的 Int16 数组，它可以将其分解成 16 位一组，这样即使是无符号整数也可以处理。 You can even have multiple views on the same base buffer. Different views will give you different results for the same operations. 甚至可以在同一个基本 buffer 上拥有多个视图。在不同的仕途上执行相同的操作结果也不同。 For example, if we get elements 0 &amp; 1 from the Int8 view on this ArrayBuffer, it will give us different values than element 0 in the Uint16 view, even though they contain exactly the same bits. 例如，如果我们从这个 ArrayBuffer 的 Int8 视图可以获取元素 0 和 1，那么，在 Uint16 视图下，元素 0 将会返回不同的值，即使它们拥有完全相同的 bits。 In this way, the ArrayBuffer basically acts like raw memory. It emulates the kind of direct memory access that you would have in a language like C. You may be wondering why don’t we just give programmers direct access to memory instead of adding this layer of abstraction. Giving direct access to memory would open up some security holes. I will explain more about this in a future article. 这样，ArrayBuffer 基本上类似于原始内存，它可以模拟像 C 语言的直接的内存访问。 你可能会想，为什么我们不让程序员直接访问内存，而是添加这一层抽象。这是因为直接访问内存将会造成一些安全漏洞。我将在以后的文章对此解释更多。 什么是 SharedArrayBuffer？To explain SharedArrayBuffers, I need to explain a little bit about running code in parallel and JavaScript. 要介绍 SharedArrayBuffers，我需要介绍一下并行运行代码和 JavaScript。 You would run code in parallel to make your code run faster, or to make it respond faster to user events. To do this, you need to split up the work. In a typical app, the work is all taken care of by a single individual—the main thread. I’ve talked about this before… the main thread is like a full-stack developer. It’s in charge of JavaScript, the DOM, and layout. Anything you can do to remove work from the main thread’s workload helps. And under certain circumstances, ArrayBuffers can reduce the amount of work that the main thread has to do. 并行运行代码会使代码运行速度更快，或者使其对用户事件的响应更快。要做到这一点，你需要分离工作。 在典型的应用程序中，所有的工作都由单个人： 主线程来处理。主线程就像一个全栈开发者，它负责 JavaScript，DOM 和布局。 从主线程的工作负载中删除任何工作都会有帮助，在某些情况下，ArrayBuffers 可以减少主线程所需的工作量。 But there are times when reducing the main thread’s workload isn’t enough. Sometimes you need to bring in reinforcements… you need to split up the work. 但有时减少主线程的工作量是不够的。有时你需要引进援助，你需要分离工作。 In most programming languages, the way you usually split up the work is by using something called a thread. This is basically like having multiple people working on a project. If you have tasks that are pretty independent of each other, you can give them to different threads. Then, both those threads can be working on their separate tasks at the same time. In JavaScript, the way you do this is using something called a web worker. These web workers are slightly different than the threads you use in other languages. By default they don’t share memory. 在大多数编程语言中，分割工作的方式是使用线程，这就像有多个人在一个项目上工作。如果你有相互独立的任务，你可以分配给不同的线程。然后，这些线程就可以同时处理独立的任务。 在 JavaScript 中，你可以使用 web workers 做这些事。web workers 与其他语言中使用的线程略有不同，默认情况下，它们不共享内存。 This means if you want to share some data with the other thread, you have to copy it over. This is done with the function postMessage. postMessage takes whatever object you put into it, serializes it, sends it over to the other web worker, where it’s deserialized and put in memory. 这意味着如果要与其他线程共享数据，则必须复制，这是通过 postMessage 函数完成的。 postMessage 会把你放入的任何对象序列化，发送到其他 web worker，然后其他 web worker 反序列化并放入内存中。 That’s a pretty slow process. For some kinds of data, like ArrayBuffers, you can do what is called transferring memory. That means moving that specific block of memory over so that the other web worker has access to it. But then the first web worker doesn’t have access to it anymore. 这是一个很慢的过程。 对于一些类型的数据，像 ArrayBuffers ，你可以移动内存，这意味着移动该内存块，以便其他 web worker 可以访问它，但是第一个 web worker 将不能访问它了。 That works for some use cases, but for many use cases where you want to have this kind of high performance parallelism, what you really need is to have shared memory. This is what SharedArrayBuffers give you. 这适用于一些情况，但是对于想要具有高性能的并行，你真正需要的是共享内存。这正是 SharedArrayBuffers 可以提供的。 With the SharedArrayBuffer, both web workers, both threads, can be writing data and reading data from the same chunk of memory. This means they don’t have the communication overhead and delays that you would have with postMessage. Both web workers have immediate access to the data. There is some danger in having this immediate access from both threads at the same time though. It can cause what are called race conditions. 使用 SharedArrayBuffer ，这些 web workers ，线程都可以从同一块内存中写入数据和读取数据。这意味着不再有 PostMessage 通信的开销和延迟， web workers 可以立即访问数据。 这两个线程的同时访问内存会有一些危险，它可能引起竞争条件的问题。 I’ll explain more about those in the next article. 我将会在下一篇文章解释这个问题。 SharedArrayBuffers 现状怎样？SharedArrayBuffers will be in all of the major browsers soon. SharedArrayBuffers 即将在所有主流浏览器中。 They’ve already shipped in Safari (in Safari 10.1). Both Firefox and Chrome will be shipping them in their July/August releases. And Edge plans to ship them in their fall Windows update. 它们已经在 Safari 中运行（Safari 10.1中）。 Firefox 和 Chrome 都将在7月、8月发行。而 Edge 计划在他们秋天的 Windows 更新中发布。 Even once they are available in all major browsers, we don’t expect application developers to be using them directly. In fact, we recommend against it. You should be using the highest level of abstraction available to you. What we do expect is that JavaScript library developers will create libraries that give you easier and safer ways to work with SharedArrayBuffers. In addition, once SharedArrayBuffers are built into the platform, WebAssembly can use them to implement support for threads. Once that’s in place, you’d be able to use the concurrency abstractions of a language like Rust, which has fearless concurrency as one of its main goals. In the next article, we’ll look at the tools (Atomics) that these library authors would use to build up these abstractions while avoiding race conditions. 即使在所有主流浏览器都可用，我们也不希望应用程序开发人员直接使用它们。实际上，我们建议不要直接使用，应当使用它们的最高级别的抽象封装库。 我们希望 JavaScript 库的开发人员创建可以使你可以更轻松，更安全地使用 SharedArrayBuffers 的库。 在下一篇文章中，我们将介绍这些库作者建立的避免竞争条件的抽象的工具（Atomics）。","categories":[{"name":"翻译","slug":"翻译","permalink":"http://tcatche.site/categories/%E7%BF%BB%E8%AF%91/"}],"tags":[{"name":"内存管理","slug":"内存管理","permalink":"http://tcatche.site/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"},{"name":"WebAssembly","slug":"WebAssembly","permalink":"http://tcatche.site/tags/WebAssembly/"}]},{"title":"碰撞课程：内存管理 - A crash course in memory management","slug":"a-crash-course-in-memory-management","date":"2017-06-28T07:26:00.000Z","updated":"2018-08-01T10:41:24.000Z","comments":true,"path":"2017/06/a-crash-course-in-memory-management/","link":"","permalink":"http://tcatche.site/2017/06/a-crash-course-in-memory-management/","excerpt":"","text":"原文：A crash course in memory management 本文译自Lin Clark 内存管理的卡通介绍系列，渣翻译，因此附上英文原文。 内存管理 ArrayBuffers 和 SharedArrayBuffers 的卡通介绍 使用 Atom 避免 ArrayBuffers 中的竞态条件 概述To understand why ArrayBuffer and SharedArrayBuffer were added to JavaScript, you need to understand a bit about memory management. 想要了解为什么将 ArrayBuffer 和 SharedArrayBuffer 添加到 JavaScript 中，你需要了解一些内存管理。 You can think of memory in a machine as a bunch of boxes. I think of these like the mailboxes that you have in offices, or the cubbies that pre-schoolers have to store their things. If you need to leave something for one of the other kids, you can put it inside a box. 你可以将计算机的内存看做一堆盒子。就像你办公室的邮箱，或者是学龄前儿童的储物柜。 如果你想为其他孩子留下一些东西，你可以把它放在一个盒子里。 Next to each one of these boxes, you have a number, which is the memory address. That’s how you tell someone where to find the thing you’ve left for them. Each one of these boxes is the same size and can hold a certain amount of info. The size of the box is specific to the machine. That size is called word size. It’s usually something like 32-bits or 64-bits. But to make it easier to show, I’m going to use a word size of 8 bits. 在每个盒子的旁边都有一个数字，他就是内存地址，它用来告诉别人你放东西的位置。 这些盒子都有相同的尺寸，可以容纳一定量的信息。每个盒子的尺寸取决于物理机器，这个尺寸叫做字长。它通常是 32 位或 64位，但是为了更容易演示，我们使用8位的字长。 If we wanted to put the number 2 in one of these boxes, we could do it easily. Numbers are easy to represent in binary. 如果我们想把数字2放进其中一个盒子，这很容易做到，数字很​​容易用二进制表示。 What if we want something that’s not a number though? Like the letter H? We’d need to have a way to represent it as a number. To do that, we need an encoding, something like UTF-8. And we’d need something to turn it into that number… like an encoder ring. And then we can store it. 如果我们想要的东西不是数字呢，比如字母 H ？ 我们需要用一种方式把它表示为数字，为了做到这一步，我们需要对它编码，比如 UTF-8。我们需要一些东西把它转变成数字，比如编码器环，然后就可以存储它。 When we want to get it back out of the box, we’d have to put it through a decoder to translate it back to H. 当我们想要获得它的时候，把数字从盒子中取出来，放进解码器进行翻译，又变成了字母 H。 自动内存管理When you’re working in JavaScript you don’t actually need to think about this memory. It’s abstracted away from you. This means you don’t touch the memory directly. Instead, the JS engine acts as an intermediary. It manages the memory for you. 当你使用 JavaScript 时，实际上并不需要考虑内存。它是一个离你很远的抽象的概念，这意味着你不必直接操作内存。 相反的，JS 引擎充当中介，它替你管理内存。 So let’s say some JS code, like React, wants to create a variable. 让我们看一些 JS 代码，比如 React，想要创建一个变量。 What the JS engine does is run that value through an encoder to get the binary representation of the value. JS 引擎做事是运行编码器获得值的二进制表示。 And it will find space in the memory that it can put that binary representation into. This process is called allocating memory. 并且它在内存中找到可以存放这个二进制表示的值的空间，这个过程称为分配内存。 Then, the engine will keep track of whether or not this variable is still accessible from anywhere in the program. If the variable can no longer be reached, the memory is going to be reclaimed so that the JS engine can put new values there. 然后，引擎将跟踪该变量是否仍然可以从程序的任何地方访问。如果变量不能被访问，存放的内存将被回收，以便 JS 引擎可以存放新值。 This process of watching the variables—strings, objects, and other kinds of values that go in memory—and clearing them out when they can’t be reached anymore is called garbage collection. 这个观察变量（字符串，对象和内存中其他类型的值），并且当它们不能被访问的时候清除的过程被称为垃圾收集。 Languages like JavaScript, where the code doesn’t deal with memory directly, are called memory-managed languages. This automatic memory management can make things easier for developers. But it also adds some overhead. And that overhead can sometimes make performance unpredictable. 像 JavaScript 这类的代码不在代码中直接处理内存的语言，被称为内存管理语言。这种自动的内存管理可以使开发人员更轻松。但它增加了一些开销，而这种开销有时会使性能变得不可预测。 手动内存管理Languages with manually managed memory are different. For example, let’s look at how React would work with memory if it were written in C (which would be possible now with WebAssembly). 手动管理内存的语言则不同。比如，我们来看看如果使用 C 语言来写， React 怎样操作内存（现在可以通过 WebAssembly 来实现）。 C doesn’t have that layer of abstraction that JavaScript does on the memory. Instead, you’re operating directly on memory. You can load things from memory, and you can store things to memory. C 语言没有类似于 JavaScript 的在内存上的抽象层，而是直接在内存上操作。你可以从直接内存中加载内容，也可以直接将内容存储到内存中。 When you’re compiling C or other languages down to WebAssembly, the tool that you use will add in some helper code to your WebAssembly. For example, it would add code that does the encoding and decoding bytes. This code is called a runtime environment. The runtime environment will help handle some of the stuff that the JS engine does for JS. 当你将 C 语言或其他语言编译到 WebAssembly 时，你使用的工具将在 WebAssembly 中添加一些帮助代码。例如，添加编码和解码二进制字节的代码，这个代码被成为运行时环境，运行时环境将帮助处理一些之前 JS 引擎为 JS 做的事情。 But for a manually managed language, that runtime won’t include garbage collection. This doesn’t mean that you’re totally on your own. Even in languages with manual memory management, you’ll usually get some help from the language runtime. For example, in C, the runtime will keep track of which memory addresses are open in something called a free list. 但是对于一个手动管理内存的语言而言，该运行时环境将不包括垃圾回收。 这不意味着你需要自己做全部的事情，即使是手动内存管理的语言，也通常会在语言运行期获得帮助。比如，在 C 语言中，运行期会追踪哪些地址是可用的，并放在空闲列表中。 You can use the function malloc (short for memory allocate) to ask the runtime to find some memory addresses that can fit your data. This will take those addresses off of the free list. When you’re done with that data, you have to call free to deallocate the memory. Then those addresses will be added back to the free list. You have to figure out when to call those functions. That’s why it’s called manual memory management—you manage the memory yourself. 你可以使用 malloc （内存分配的简写）函数来要求在运行时找到一些可以存储你的数据的内存地址。这将把这些地址从空闲列表中删除。当你使用完这些数据后，您必须使用 free 函数释放内存。那么这些地址将重新被添加到空闲列表。 你必须弄清楚什么时候调用这些功能，这就是为什么它被称为手动内存管理：你需要自己管理内存。 As a developer, figuring out when to clear out different parts of memory can be hard. If you do it at the wrong time, it can cause bugs and even lead to security holes. If you don’t do it, you run out of memory. This is why many modern languages use automatic memory management—to avoid human error. But that comes at the cost of performance. I’ll explain more about this in the next article. 作为开发者，搞清楚什么时候清除不同部分的内存可能很难。如果在错误的时间进行操作，可能会导致错误，甚至导致安全漏洞，但是如果你不清除内存，你的内存就会耗尽。 这就是为什么许多现代语言使用自动内存管理的原因：为了避免人为的错误。但这是以牺牲性能为代价的，我将在下一篇文章中更详细地解释这一点。","categories":[{"name":"翻译","slug":"翻译","permalink":"http://tcatche.site/categories/%E7%BF%BB%E8%AF%91/"}],"tags":[{"name":"内存管理","slug":"内存管理","permalink":"http://tcatche.site/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"},{"name":"WebAssembly","slug":"WebAssembly","permalink":"http://tcatche.site/tags/WebAssembly/"}]},{"title":"Browser Console","slug":"web-browser-console","date":"2017-06-27T06:48:00.000Z","updated":"2018-08-01T10:41:24.000Z","comments":true,"path":"2017/06/web-browser-console/","link":"","permalink":"http://tcatche.site/2017/06/web-browser-console/","excerpt":"","text":"console 对象提供对浏览器控制台的接入，最常用的是 console.log()，但是实际上 console 对象上还有很多有用的函数可以帮助调试。 使用 console 对象可以执行这些任务： 输出一个定时器来帮助简单的基准测试 输出一个表，以便于阅读的格式显示数组或对象 使用 CSS 将颜色和其他样式选项应用于输出 console 并不是标准的特性，在不同浏览器上的工作方式是不一样的，这里主要针对 Chrome 和 Firefox 介绍一些大都会提供的接口特性。 输出文本这是最常用的一组接口，在各个框架也常使用的，在控制台输出日志，警告错误等。简单输出文本的接口有这四种： log info warn error 这四个接口的工作方法一致，接收多个参数，展示效果如下： 字符串替换字符串替换允许使用其他内容替换输出中的指定字符串，比如： console.log(&#x27;string %s&#x27;, &#x27;substitutions&#x27;);// string substitutions 支持的字符串替换有以下几种： %s ：使用字符串替换 %(d|i) ：使用整数替换 %(f|.nf) ：使用浮点数替换 %(o|O) ：元素被作为对象替换 %c ：应用提供的 css 看几个例子： var obj = &#123; hello: &#x27;hello&#x27; &#125;console.log(&#x27;this is an string %s&#x27;, obj);// this is an string [object Object] console.log(&#x27;this is an object %o&#x27;, obj);// this is an object Object &#123; hello: &quot;hello&quot; &#125;console.log(&#x27;int: %d, float: %f, float to int: %d&#x27;, 1, 1.5, 1.5);// int: 1, float: 1.500000, float to int: 1console.log(&#x27;format float: %.3f&#x27;, 1.5);// format float: 1.500 使用 %c 可以让文本呈现出指定的 css 样式，比如我们定义了成功的消息用红色背景，失败的消息用绿色背景： const success = [ &#x27;background: green&#x27;, &#x27;color: white&#x27;, &#x27;display: block&#x27;, &#x27;text-align: center&#x27;].join(&#x27;;&#x27;);const failure = [ &#x27;background: red&#x27;, &#x27;color: white&#x27;, &#x27;display: block&#x27;, &#x27;text-align: center&#x27;].join(&#x27;;&#x27;);console.info(&#x27;%c /dancing/bears was Successful!&#x27;, success);console.error(&#x27;%c /dancing/bats failed!&#x27;, failure); 当然注意到样式在不同浏览器下有很大的差别，有些样式在其他浏览器并不被支持。 断言（console.assert()） console.assert(assertion, obj1 [, obj2, …, objN]) 如果断言为 false ，则将一个错误消息写入控制台，写入方式是 console.error 。如果断言是 true ，不执行任何操作。 let isTrue = false;console.assert(isTrue, &#x27;This will display&#x27;);// This will displayisTrue = true;console.assert(isTrue, &#x27;This will not&#x27;);// 什么都不输出 树形展示对象（console.dir()） console.dir(object); 将一个 JavaScript 对象的属性和属性值显示成一个可交互的列表，点击折叠的小三角形可以查看各子属性的内容。 树形展示DOM 的 html 结构（console.dirxml()） console.dirxml(object); 显示一个明确的 XML/HTML 元素的包括所有后代元素的交互树。 如果无法作为一个 element 被显示，那么会以 JavaScript 对象的形式作为替代。点击折叠的小三角形可以查看各子属性的内容。 表格（console.table()） console.table(object) 把数组或者对象用表格呈现： console.table([&#x27;Javascript&#x27;, &#x27;PHP&#x27;, &#x27;Perl&#x27;, &#x27;C++&#x27;]); // on firefoxconsole.table([[&#x27;Javascript&#x27;, &#x27;PHP&#x27;, &#x27;Perl&#x27;, &#x27;C++&#x27;]]); // on chrome 呈现效果如下： 使用表格查看对象： function Person(firstName, lastName) &#123; this.firstName = firstName; this.lastName = lastName;&#125;var family = &#123;&#125;;family.mother = new Person(&quot;Jane&quot;, &quot;Smith&quot;);family.father = new Person(&quot;John&quot;, &quot;Smith&quot;);family.daughter = new Person(&quot;Emily&quot;, &quot;Smith&quot;); 呈现效果如下： 限制列： console.table(family, [&quot;firstName&quot;]); 分组（console.group()） console.group(label)console.groupCollapsed(label)console.groupEnd(label) 在 Web 控制台上创建一个新的分组，随后输出到控制台上的内容都会被添加一个缩进，表示该内容属于当前分组,直到调用 console.groupEnd() 之后,当前分组结束。 console.group(&#x27;outer&#x27;);console.log(&#x27;I will output&#x27;);console.group(&#x27;inner&#x27;);console.log(&#x27;more indents&#x27;)console.groupEnd(&#x27;inner&#x27;);console.log(&#x27;ohh look a bear&#x27;);console.groupEnd(&#x27;outer&#x27;); console.groupCollapsed 创建一个默认折叠的分组。 计时（console.time()） console.time(label)console.timeEnd(label) 追踪某一操作的执行时间，使用 timeEnd 结束： console.time(&#x27;loop&#x27;);for(var i = 0; i &lt; 100000000; i ++)&#123;&#125;;console.timeEnd(&#x27;loop&#x27;);// loop: 203.9521484375ms 计数（console.count()） console.count(label) 输出 count() 被调用的次数。此函数接受一个可选参数 label。 var user = &quot;&quot;;function greet() &#123; console.count(user); return &quot;hi &quot; + user;&#125;user = &quot;bob&quot;;greet();// bob: 1 user = &quot;alice&quot;;greet();// alice: 1 greet();// alice: 2 console.count(&quot;alice&quot;);// alice: 3 堆栈跟踪（console.trace()） console.trace(obj1[, obj2…]); 从函数调用的位置输出一个调用堆栈追踪： function foo() &#123; function bar() &#123; console.trace(); &#125; bar();&#125;foo(); 参考 MDN-Console How to get the most out of the JavaScript console","categories":[{"name":"js","slug":"js","permalink":"http://tcatche.site/categories/js/"}],"tags":[{"name":"bom","slug":"bom","permalink":"http://tcatche.site/tags/bom/"},{"name":"test","slug":"test","permalink":"http://tcatche.site/tags/test/"},{"name":"develop","slug":"develop","permalink":"http://tcatche.site/tags/develop/"}]},{"title":"apply.call、call.call、call.apply、call.bind","slug":"call-apply-bind","date":"2017-06-26T10:10:00.000Z","updated":"2021-09-01T07:03:08.603Z","comments":true,"path":"2017/06/call-apply-bind/","link":"","permalink":"http://tcatche.site/2017/06/call-apply-bind/","excerpt":"","text":"这三个函数都用于改变函数中 this 指向，但是稍有不同，可以分为两组：all/apply 和 bind。 call/applycall 和 apply 具有相似的行为，只是接收参数的方式不同，call 方法接收若干个参数的列表，而 apply 接收包含多个参数的数组或类数组对象： fun.call(thisArg[, arg1[, arg2[, …]]])fun.apply(thisArg, [argsArray]) polyfill为了更深一步了解这个函数，我们来尝试实现它, 我们要绑定这个函数到 thisArg 这个很简单，直接把函数作为 thisArg 的属性，调用即可： Function.prototype.myCall = function(thisArg) &#123; let fn = this; thisArg.fn = fn; let returnVal = thisArg.fn(); delete context.fn; return returnVal;&#125; 不过这个实现并没有考虑传入额外的参数的情况，如果要传入额外的参数，这里我们可以使用展开运算符 ...： Function.prototype.myCall = function(thisArg, ...args) &#123; let fn = this; thisArg.fn = fn; let returnVal = thisArg.fn(...args); delete context.fn; return returnVal;&#125; 当然，如果不允许用展开运算符的话，可以用 eval 组装语句： returnVal = eval(`thisArg[tmpKey]($&#123;args.join(&#x27;,&#x27;)&#125;)`); 如果熟悉 Function 的构造函数（new Function ([arg1[, arg2[, ...argN]],] functionBody)），也可以用其来实现，但是需要注意的是 Function 构造器生成的函数，并不会在创建它们的上下文中创建闭包；它们一般在全局作用域中被创建。当运行这些函数的时候，它们只能访问自己的本地变量和全局变量，这样当我们使用的时候必须把使用的变量（thisArg、argNames）存储到全局变量里，这样显然不是很方便，因此只是提一下这个思路： // thisArg 和 argNames 必须存储为全局变量，否则无法访问到window.thisArg = thisArg;window.argNames = args.map((item, index) =&gt; &#x27;arg&#x27; + index).join(&#x27;,&#x27;)let returnVal = new Function(argNames, &#x27;thisArg.fn(&#x27; + argNames + &#x27;)&#x27;)(...args); 这样我们就基本实现了这个功能，但是考虑到 thisArg.fn = fn 可能和 thisArg 原有的属性冲突，这里可以引入 Symbol： let tmpKey = Symbol(&#x27;myCall&#x27;);thisArg[tmpKey] = fn; 当然如果 Symbol 不允许使用，也可以轻松实现我们需要的不会冲突的键值： var getUniqueKey = function(obj) &#123; let uniqueKey = &#x27;symbol&#x27; + Math.random(); if (uniqueKey in obj) &#123; uniqueKey = getUniqueProperty(obj); &#125; return uniqueKey;&#125; 接下来我们考虑到可能会执行中出现错误，最终 delete thisArg[tmpKey] 没有被执行，我们可以将其放置到 try...catch...finally 语句中执行： try &#123; returnVal = thisArg[tmpKey](...args); // 或者使用 eval 执行 //returnVal = eval(`thisArg[tmpKey]($&#123;args.join(&#x27;,&#x27;)&#125;)`);&#125; catch (e) &#123; // 把异常抛出外部处理 throw e;&#125; finally &#123; // 确保删除该属性 delete thisArg[tmpKey];&#125; 这样已经基本实现了，最后，我们可以为其做参数的校验，最终，实现的完整代码如下： Function.prototype.myCall = function(thisArg, ...args) &#123; let fn = this; // this 不是 function 则抛出 TypeError 错误。 if (typeof fn !== &#x27;function&#x27;) &#123; throw new Error(&#x27;TypeError.&#x27;) &#125; // 值为 null 或 undefined 时，thisArg 指向全局对象 if (thisArg === null || thisArg === undefined) &#123; thisArg = window; &#125; // 值为原始值（数字，字符串，布尔值），thisArg 指向该原始值的自动包装对象 if (typeof thisArg === &#x27;boolean&#x27; || typeof thisArg === &#x27;number&#x27; || typeof thisArg === &#x27;string&#x27;) &#123; thisArg = Object(thisArg); &#125; // 为 thisArg 指定一个属性指向该函数，为了避免和原有属性冲突，使用 Symbol。 let returnVal, tmpKey = Symbol(&#x27;myCall&#x27;); thisArg[tmpKey] = fn; // 为了避免出现错误，将调用放到 try...catch 代码块中执行，并在 finally 中释放该属性。 try &#123; returnVal = thisArg[tmpKey](...args); // 或者使用 eval 执行 //returnVal = eval(`thisArg[tmpKey]($&#123;args.join(&#x27;,&#x27;)&#125;)`); &#125; catch (e) &#123; // 把异常抛出外部处理 throw e; &#125; finally &#123; // 确保删除该属性 delete thisArg[tmpKey]; &#125; return returnVal;&#125; 调用测试： var obj = &#123; name: &#x27;obj&#x27;&#125;;var obj2 = &#123; name: &#x27;obj2&#x27;, hello: function() &#123; console.log(&#x27;hello, &#x27; + this.name) &#125;&#125;obj2.hello.myCall(obj);// hello, obj 当然，这个实现只是一个思路，并不能适用于所有的场合，比如，当对象被密封 Object.isSealed 或者冻结 Object.isFrozen 的时候，thisArg[tmpKey] = fn 操作将会失败： Object.seal(obj);// Uncaught TypeError: thisArg[tmpKey] is not a function 不过，密封和冻结对象只针对当前对象，不影响其原型对象，可以将 thisArg[tmpKey] = fn 操作移动到其非密封和冻结原型对象上： let protoObject = thisArg；while (Object.isSealed(protoObject) || Object.isFrozen(protoObject)) &#123; protoObject = protoObject.__proto__ || &#123;&#125;;&#125;protoObject[tmpKey] = fn;// ...其他操作delete protoObject[tmpKey]; 还有，如果目标方法牵扯操作 Symbol 也可能受到影响。 在类数组上调用数组方法常见的类数组比如 arguments 等，只要拥有和数组一样的结构都可以调用数组的方法 function logArgs() &#123; console.log([].join.call(arguments, &#x27;,&#x27;));&#125;logArgs(1, 2, 3, 4);// 1,2,3,4 apply.call、call.apply、apply.apply、call.call之前在几个地方看到这种绕圈子的用法，绕了好久，这里以 Function.prototype.apply.call(log, console, args) 为例分析一下：1.Function.prototype.apply 等价于： funcApply.call(log, console, args)2.去掉 call 等价于：log.funcApply(console, args)3.去掉 apply 等价于 console.log(args) 也就是说，起的作用是，把第一个函数参数（log）的 this 指针 绑定到第二个对象参数上，并把第三个参数作为参数传入执行。 同理，apply 函数的第二个参数是数组，因此要这样使用：Function.prototype.call.apply(log, [console, args]) 当然 Function.prototype.call.call 和 Function.prototype.apply.apply 也是这样，不再详细解释，总结如下： Function.prototype.apply.call(func, thisArg, callFuncArgs);Function.prototype.call.call(func, thisArg, callFuncArgs);Function.prototype.call.apply(func, [thisArg, callFuncArgs]);Function.prototype.apply.apply(func, [thisArg, callFuncArgs]); var log = function() &#123; return console.log(&#x27;My log output: &#x27; + [].slice.call(arguments).join(&#x27;, &#x27;));&#125;Function.prototype.apply.call(log, console, [1, 2, 3]); // 第三个参数必须为数组或者省略Function.prototype.call.call(log, console, 1, 2, 3);Function.prototype.call.apply(log, [console, 1, 2, 3]); // 第二个参数必须为数组或者省略Function.prototype.apply.apply(log, [console, [1, 2, 3]]); // 第二个参数必须为数组或者省略,若为数组的则其二个参数也必须为数组或者省略 这个可以简化代码，不过大大降低了可读性，理解就好，比如，反柯里化的实现代码： Function.prototype.unCurry = function() &#123; var _fn = this; return function() &#123; return Function.prototype.call.apply(_fn, arguments); &#125;&#125;var push = Array.prototype.push.unCurry();var obj = &#123;&#125;;push(obj, &quot;a&quot;);console.log(obj); // Object &#123;0: &quot;a&quot;, length: 1&#125; 上述示例将 Array 的 push 函数推广到了对象上，在对象上调用 push 函数。 bindbind 同样是改变 this 指向的，和call/apply 不同点在于不会立即执行函数，而是提供了一个绑定了新的this值的函数。 polyfill可以直接使用 apply 方法实现： if (!Function.prototype.bind) &#123; Function.prototype.bind = function()&#123; var fn = this, presetArgs = [].slice.call(arguments); var context = presetArgs.shift(); return function() &#123; return fn.apply(context, presetArgs.concat([].slice.call(arguments))); &#125;; &#125;;&#125;; 但是考虑到可能作为构造函数使用，需要做一个改进： if (!Function.prototype.bind) &#123; Function.prototype.bind = function (oThis) &#123; if (typeof this !== &quot;function&quot;) &#123; // closest thing possible to the ECMAScript 5 // internal IsCallable function throw new TypeError(&quot;Function.prototype.bind - what is trying to be bound is not callable&quot;); &#125; var aArgs = Array.prototype.slice.call(arguments, 1), fToBind = this, fNOP = function () &#123;&#125;, fBound = function () &#123; // this instanceof fNOP ? this : oThis || this // 当作为构造函数时，this 指向当前对象，避免绑定到错误对象， return fToBind.apply(this instanceof fNOP ? this : oThis || this, aArgs.concat(Array.prototype.slice.call(arguments))); &#125;; // 避免 new 调用的时候无法得到原函数的原型属性 // 修改 fBound 的原型指向原有函数的原型的复制，避免修改新函数的原型影响到原有的函数的原型 fNOP.prototype = this.prototype; fBound.prototype = new fNOP(); return fBound; &#125;;&#125; 这里解释下其中的几个要点：1.typeof this !== &quot;function&quot; 检查保证要绑定的是个函数，否则抛出异常。 if (typeof this !== &quot;function&quot;) &#123; // closest thing possible to the ECMAScript 5 // internal IsCallable function throw new TypeError(&quot;Function.prototype.bind - what is trying to be bound is not callable&quot;);&#125; 2.bind 函数要求当函数被作为构造器的时候，忽略提供的 this 值，因此这里做一个检测，当 this instanceof fNOP 此时 this 指向的是 fBound 的原型，这种情况说明函数被作为构造函数调用，因此此时让 this 指向自身。仅当 this is not instanceof fNOP 才起作用. fBound = function () &#123; // this instanceof fNOP ? this : oThis || this // 当作为构造函数时，this 指向当前对象，避免绑定到错误对象， return fToBind.apply(this instanceof fNOP ? this : oThis || this, aArgs.concat(Array.prototype.slice.call(arguments)));&#125;; 3.之前的函数可能存在原型所以需要为新函数增加原型，但是为了避免修改新函数，设置原型为之前函数原型对象的拷贝： // 避免 new 调用的时候无法得到原函数的原型属性// 修改 fBound 的原型指向原有函数的原型的复制，避免修改新函数的原型影响到原有的函数的原型fNOP.prototype = this.prototype;fBound.prototype = new fNOP(); 当然这个实现并不完善，主要问题有：函数存在 prototype 属性、函数的length 不正确。 配合回调函数在一些回调函数中，如 setTimeout 中，this 关键字会指向全局对象，这个时候可以使用 bind 函数提前绑定 this 指向。 var obj = &#123; name: &#x27;obj&#x27;, sayHello:function() &#123; console.log(&#x27;hello, &#x27; + this.name); &#125;&#125;var name=&quot;window&quot;;setTimeout(obj.sayHello, 100);// hello, windowsetTimeout(obj.sayHello.bind(obj), 100);// hello, obj call.bind、bind.call、apply.bind、bind.apply与上面类似，用于把更改函数参数的 this 指针，Function.prototype.call.bind(func) 实际上等价于 func.call var arrayLikeToArray = Function.prototype.call.bind(Array.prototype.slice);var arrLike = &#123;0:&quot;a&quot;, 1:&quot;b&quot;, 2:&quot;c&quot;, length:3&#125;;var arr = arrayLikeToArray(arrLike);console.log(Object.prototype.toString.call(arr)) // &quot;[object Array]&quot; 同样的 Function.prototype.apply.bind 功能类似，不再说明。 这里再看一下 Function.prototype.bind.call，先看个例子： Function.prototype.bind.call(log, console)(1, 2, 3)//这等价于log.bind(console)(1, 2, 3); 可以改变一个函数的 this 到特定的对象上，并获得在这个对象执行这个操作的函数，如上述的 push 示例也可以这样改造成一个 obj 的专有 push 方法： var obj = &#123;&#125;;var pushToObj = Function.prototype.bind.call(Array.prototype.push, obj);pushToObj(&quot;a&quot;);console.log(obj); // Object &#123;0: &quot;a&quot;, length: 1&#125; 参考 MDN-Function.prototype.bind 可能遇到假的面试题：不用call和apply方法模拟实现ES5的bind方法","categories":[{"name":"js","slug":"js","permalink":"http://tcatche.site/categories/js/"}],"tags":[]},{"title":"Object.defineProperty","slug":"object-define-property","date":"2017-06-23T07:35:00.000Z","updated":"2018-08-01T10:41:24.000Z","comments":true,"path":"2017/06/object-define-property/","link":"","permalink":"http://tcatche.site/2017/06/object-define-property/","excerpt":"","text":"defineProperty 提供了精准控制一个对象属性的能力。一般情况下，我们为对象添加属性是通过赋值(obj.property = value)来创建对象的属性，这样的属性可以被 for...in 或 Object.keys 枚举，可以被改变，也可以被删除。而使用 Object.defineProperty 则允许改变这些额外细节的默认设置。 Object.defineProperty/Reflect.defineProperty###接口和参数 Object.defineProperty(obj, prop, descriptor)Reflect.defineProperty(obj, prop, descriptor) obj：要在其上定义属性的对象，如果参数不是对象，将抛出 TypeError 异常。 prop：要定义或修改的属性的名称。 descriptor：将被定义或修改的属性的描述符。 return：Object.defineProperty 返回传递给它的参数对象，Reflect.defineProperty 返回指示定义是否成功的 bool 值。 对象的属性描述符分为两种类型：数据描述符 和 存取控制符 ，描述符必须是这两者之一，不可同时存在 这两者有共有的属性：configurable 和 enumerable 。数据描述符除了这两个共有的属性，还有写控制和属性值两个属性：value 、writable。存取控制符除了这两个共有的属性，还有一对 getter-setter 函数定义数据的读写：get 、set 。 configurable当某属性的 configurable 描述符的值为 true 时，才允许修改其属性描述符。默认为 false。 如果描述符的 configurable 特性为 false（即该特性为 non-configurable ），那么除了 writable 外，其他特性都不能被修改，其 writable 特性也只能修改为 false ，并且数据和存取描述符也不能相互切换。 如果尝试修改不允许修改的属性，将会产生一个 TypeError 异常，若当前值与修改值相同，不报错。 var object = &#123;&#125;;// 设置 key1 属性为不可配置Object.defineProperty(object, &quot;key1&quot;, &#123; configurable: false, enumerable: true， writable: true&#125;);// 修改其他属性报错Object.defineProperty(object, &quot;key1&quot;, &#123; enumerable: false&#125;);// TypeError: Cannot redefine property: key1// 修改 writable 从 true 到 false 不报错Object.defineProperty(object, &quot;key1&quot;, &#123; writable: false&#125;);// 修改 writable 从 false 到 true 报错Object.defineProperty(object, &quot;key1&quot;, &#123; writable: true&#125;);// TypeError: Cannot redefine property: key1 enumerable当某属性的 enumerable 描述符的值为 true 时，该属性才能够出现在对象的枚举属性中。默认为 false。 该描述符影响 for...in、 Object.keys、Object.assign var object = &#123;&#125;;// 定义可枚举属性 key1Object.defineProperty(object, &quot;key1&quot;, &#123; enumerable: true&#125;);// 定义不可枚举属性 key2Object.defineProperty(object, &quot;key2&quot;, &#123; enumerable: false&#125;);Object.keys(object); //[&quot;key1&quot;] 如果想要获取不可枚举的属性集合，可以使用 Object.getOwnPropertyNames 。 Object.getOwnPropertyNames(object); // [&quot;key1&quot;, &quot;key2&quot;] writable当且仅当该属性的 writable 为 true 时，该属性才能被赋值运算符改变。**默认为 false**。 该属性控制字段的可写性。 var object = &#123;&#125;; Object.defineProperty(object, &quot;key&quot;, &#123; value: &#x27;value&#x27;, writable: false &#125;);console.log(object.key); // 打印 &#x27;value&#x27;object.key = &#x27;value2&#x27;; // 尝试赋值，没有出错console.log(object.key); // 打印 &#x27;value&#x27;， 赋值不起作用。 给 writable 为 false 的字段赋值，在非严格模式下会静默失败，在严格模式下会抛出 TypeError 异常： (function() &#123; &quot;use strict&quot; object.key = &#x27;value2&#x27;;&#125;)();// TypeError: Cannot assign to read only property &#x27;key&#x27; of object &#x27;#&lt;Object&gt;&#x27; 如果，属性的值是对象，即使 writable 为 false 其对象仍然可以修改： var object = Object.defineProperty(&#123;&#125;, &quot;arr&quot;, &#123; value: [1], writable: false &#125;);object.arr.push(2);console.log(object.arr); // [1, 2] value设置该属性对应的值。可以是任何有效的 JavaScript 值（数值，对象，函数等）。**默认为 undefined**。 get 和 set属性提供 getter 和 setter 的方法。 getter 方法返回值被用作属性值， setter 方法将接受唯一参数，并将该参数的新值分配给该属性。默认为 undefined 。 这两个函数提供了对象属性读写的“钩子”，通过它们，可以在属性读值和赋值的时候执行必要的操作，如下，为 key 属性增加了读写的日志记录： var object = Object.defineProperty(object, &#x27;key&#x27;, &#123; set(value) &#123; console.log(&quot;set value: &quot; + value); this._value = value; &#125;, get() &#123; console.log(&quot;get value: &quot; + this._value); return this._value; &#125;&#125;);object.key; // get value: undefinedobject.key = 5; // set value: 5object.key; // get value: 5 检查属性定义是否成功Reflect.defineProperty 和 Object.defineProperty 功能一样，区别在于返回值类型不一样，Object.defineProperty 返回一个对象或如果属性没有成功被定义，抛出一个 TypeError 。 而 Reflect.defineProperty 简单地返回一个 Boolean 表明是否该属性被成功定义了。 // Object 语句try (Object.defineProperty(target, property, attributes)) &#123; // 成功&#125; catche(e) &#123; // 失败&#125;// Reflect 语句if (Reflect.defineProperty(target, property, attributes)) &#123; // 成功&#125; else &#123; // 失败&#125; Object.getOwnPropertyDescriptor/Reflect.getOwnPropertyDescriptor Object.getOwnPropertyDescriptor(obj, prop)Reflect.getOwnPropertyDescriptor(obj, prop) 返回指定对象上一个自身属性对应的属性描述符。 Reflect.getOwnPropertyDescriptor 与 Object.getOwnPropertyDescriptor 的唯一不同在于如何处理非对象目标。如果方法的第一个参数不是一个对象（一个原始值），Reflect.getOwnPropertyDescriptor 将抛出 TypeError 错误，而 Object.getOwnPropertyDescriptor 会将非对象的第一个参数将被强制转换为一个对象处理。 Reflect.getOwnPropertyDescriptor(&quot;foo&quot;, 0);// TypeError: &quot;foo&quot; is not non-null objectObject.getOwnPropertyDescriptor(&quot;foo&quot;, 0);// &#123; value: &quot;f&quot;, writable: false, enumerable: true, configurable: false &#125; Object.defineProperties Object.defineProperties(obj, props) 方法直接在一个对象上定义新的属性或修改现有属性，并返回该对象。 var obj = &#123;&#125;;Object.defineProperties(obj, &#123; &quot;key1&quot;: &#123; value: true, writable: true &#125;, &quot;key2&quot;: &#123; value: &quot;Hello&quot;, writable: false &#125;&#125;);console.log(obj.key2) // &quot;Hello&quot; Object.getOwnPropertyDescriptors Object.getOwnPropertyDescriptor(obj, prop) 返回对象的所有自身属性的描述符，如果没有任何自身属性，则返回空对象，Object.getOwnPropertyDescriptor 的加强版。 var obj = &#123; a: 1, b: 2&#125;Object.getOwnPropertyDescriptors(obj);//&#123;// a: &#123;// value: 1,// writable: true,// enumerable: true,// configurable: true// &#125;,// b: &#123;// value: 2,// writable: true,// enumerable: true,// configurable: true// &#125;//&#125; 浅拷贝（shallow copy）和浅合并（shallow merge）上面提到 Object.assign 方法只能拷贝源对象的可枚举的自身属性，无法拷贝源对象的原型。使用该方法配合 Object.create 方法可以实现对象的浅拷贝（shallow copy）。 const shallowClone = (object) =&gt; Object.create( Object.getPrototypeOf(obj), Object.getOwnPropertyDescriptors(obj) ); 当然也可以用来浅合并对象（shallow merge） const shallowMerge = (target, source) =&gt; Object.defineProperties( target, Object.getOwnPropertyDescriptors(source)); 利用它实现 Mixins利用它实现 Mixins 也非常方便： let mix = (object) =&gt; (&#123; with: (...mixins) =&gt; mixins.reduce( (c, mixin) =&gt; Object.create( c, Object.getOwnPropertyDescriptors(mixin) ), object)&#125;);// multiple mixins examplelet a = &#123;a: &#x27;a&#x27;&#125;;let b = &#123;b: &#x27;b&#x27;&#125;;let c = &#123;c: &#x27;c&#x27;&#125;;let d = mix(c).with(a, b); Object.assign 的改进Object.assign 方法只会拷贝源对象自身的并且可枚举的属性到目标对象身上。该方法使用源对象的 [[Get]] 和目标对象的 [[Set]]，所以它会调用相关 getter 和 setter，而且访问器属性会被转换成数据属性，这样的拷贝是有副作用的。 这里我们对此做一个改进，使用 [[DefineOwnProperty]]/[[GetOwnProperty]] 这样就不会调用相关的 [[Get]]/[[Set]]，让它可以拷贝所有的属性，并不导致副作用。 var completeAssign = (target, ...sources) =&gt; sources.reduce((target, source) =&gt; &#123; let descriptors = Object.getOwnPropertyDescriptors(source); // 去掉不可枚举的属性，如果想要使其可以拷贝枚举属性，则去掉下面代码 Reflect.ownKeys(descriptors).forEach(key =&gt; &#123; if (!descriptors[key].enumerable) &#123; delete descriptors[key]; &#125; &#125;); return Object.defineProperties(target, descriptors); &#125;, target); polyfill这个函数的支持度较差，如果需要可以使用如下的 polyfill： if (!Object.hasOwnProperty(&#x27;getOwnPropertyDescriptors&#x27;)) &#123; Object.defineProperty( Object, &#x27;getOwnPropertyDescriptors&#x27;, &#123; configurable: true, writable: true, value: function getOwnPropertyDescriptors(object) &#123; return Reflect.ownKeys(object).reduce((descriptors, key) =&gt; &#123; return Object.defineProperty( descriptors, key, &#123; configurable: true, enumerable: true, writable: true, value: Object.getOwnPropertyDescriptor(object, key) &#125; ); &#125;, &#123;&#125;); &#125; &#125; );&#125; 和赋值运算符比较要注意，使用赋值运算符（=） 为对象的属性赋值和使用 defineProperty 的描述符并不一样： var object = &#123;&#125;;// 使用赋值运算符为对象赋值object.key1 = &#x27;value1&#x27;;// 使用 defineProperty 为对象赋值Object.defineProperty(object, &#x27;key2&#x27;, &#123; value:&#x27;value2&#x27;&#125;);console.log(Object.getOwnPropertyDescriptor(object, &#x27;key1&#x27;));// Object &#123;value: &quot;value1&quot;, writable: true, enumerable: true, configurable: true&#125;console.log(Object.getOwnPropertyDescriptor(object, &#x27;key2&#x27;));// Object &#123;value: &quot;value2&quot;, writable: false, enumerable: false, configurable: false&#125; 注意看，两种赋值方法的省略属性的默认值是不同的。 应用阻止属性被遍历有一些属性，我们并不想被遍历，这样可以修改其可枚举性，最常见的例子就是数组的 length 字段，根据ECMAScript® 2018 Language Specification，数组的 length 实际上就是一个不可枚举的字段，它具有这样的属性描述符： &#123; [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: false &#125;，我们也可以很容易定义一个这样的字段。 设置不可写的私有字段比如我有一个 math.js 库，里面有一些字段并不想被改变，虽然有很多方法，最简单的方法是让这个属性不可写： var circle = &#123; PI: 3.14, area: function(radius) &#123; return this.PI * radius * radius; &#125;&#125;Object.defineProperty(circle, &quot;PI&quot;, &#123; configurable: false, writable: false&#125;); 注意 configurable 要设置为 false ， 以免 writable 的值被修改。 双向数据绑定在一些类库，比如 Angular 和 Vue 都有着视图和数据模型之间的双向的数据绑定。当更新视图的时候，数据会发生变动，当更改数据的时候，视图也会随之变动。 这里我们来利用 defineProperty 实现这个一个功能：为对象的属性定义 get 和 set 方法，当调用 get 方法的时候，会从视图中获取值，当调用对象的 set 方法的时候，会把值更新到视图中，代码如下： 1.定义 html 结构： &lt;label&gt; &lt;span&gt;Name:&lt;/span&gt; &lt;input type=&quot;text&quot; id=&quot;name&quot; value=&quot;&quot; /&gt;&lt;/label&gt; 2.定义数据的 get 和 set 操作： let info = &#123;&#125;;Object.defineProperty(info, &#x27;name&#x27;, &#123; get: function() &#123; return document.getElementById(&#x27;name).value; &#125; set: function(val) &#123; document.getElementById(&#x27;name).value = val; &#125;&#125;); 这样就把 input 和 info.name 字段绑定到了一起。 属性校验通过访问控制符可以轻松设置属性赋值时候的校验： var person = &#123;&#125;;Object.defineProperty(person, &#x27;age&#x27;, &#123; set(age) &#123; if (age &lt; 0 || age &gt; 100) &#123; throw Error(`$&#123;age&#125; is not a valid value`); &#125; this._age = age; &#125;, get() &#123; return this._age; &#125;&#125;);erson.age = 1000; // Error: 1000 is not a valid valueperson.age = 50;console.log(person.age); // 50 参考MDN-definePropertytc39/proposal-object-getownpropertydescriptors","categories":[{"name":"js","slug":"js","permalink":"http://tcatche.site/categories/js/"}],"tags":[{"name":"扩展","slug":"扩展","permalink":"http://tcatche.site/tags/%E6%89%A9%E5%B1%95/"}]},{"title":"对象“冻结”，防止被修改","slug":"object-freeze","date":"2017-06-20T07:13:00.000Z","updated":"2018-08-01T10:41:24.000Z","comments":true,"path":"2017/06/object-freeze/","link":"","permalink":"http://tcatche.site/2017/06/object-freeze/","excerpt":"","text":"在有些应用场合下，我们希望我们的对象是不可以被修改的，比如我们提供给外一个服务，但是不想这个服务被修改，这就需要对象能够防止被修改。 在另外一些应用场合，比如 React 通常搭配使用的 immutable.js 采用不可变的数据结构，可以保证最大限度的降低副作用。 对象防止被修改有三个级别：阻止扩展、密封对象、冻结对象，本章内容，针对这些，总结如何使对象数据不可变。 阻止扩展如果一个对象可以添加新的属性，那么这个对象是可以扩展的，阻止扩展就是让这个对象不能被扩展，也就是说不能添加新的属性。 阻止扩展主要涉及这两组函数：Object.isExtensible(obj)/Reflect.isExtensible(obj)、Object.preventExtensions(obj)/Reflect.preventExtensions(obj)，前一组用于判断对象是否可以扩展，后一组用于阻止对象扩展。 Object.isExtensible(obj)/Reflect.isExtensible(obj)这两个函数都可以检查对象是否可以扩展： var empty = &#123;&#125;;Object.isExtensible(empty); // true Reflect.isExtensible(empty); // true Object.preventExtensions(empty); Object.isExtensible(empty); // false Reflect.isExtensible(empty); // false 这两种方法的不同点在于，如果参数不是对象，Object.isExtensible 会进行强制的类型转换，而 Reflect.isExtensible 会报错： Reflect.isExtensible(1);// TypeError: 1 is not an objectObject.isExtensible(1);// false Object.preventExtensions/Reflect.preventExtensions这两个函数用于将对象变的不可扩展，并返回原对象。 但是需要注意的是，不可扩展对象的属性可以被修改和删除，只是不能添加新的属性： var obj = &#123; a: &#x27;a&#x27;&#125;Object.preventExtensions(obj);Object.isExtensible(obj); // falseobj.a = &#x27;b&#x27;; // Object &#123;a: &quot;b&quot;&#125;delete obj.a // Object &#123;&#125; 还有，preventExtensions 只能阻止对象被添加自身属性，但可以为其原型添加属性，不过不允许将其原型重新指向另一个对象： var fixed = Object.preventExtensions(&#123;&#125;);fixed.__proto__.a = &#x27;a&#x27;;console.log(fixed.a); // afixed.__proto__ = &#123;&#125;// TypeError: #&lt;Object&gt; is not extensible 同样的，如果参数不是对象，Reflect.preventExtensions 会报错，Object.preventExtensions 会进行强制的类型转换： Reflect.preventExtensions(1);// TypeError: 1 is not an objectObject.preventExtensions(1);// false 在非严格模式下，为一个不可扩展对象的新属性赋值会静默失败，而严格模式下抛出 TypeError 异常： var nonExtensible = Object.preventExtensions(&#123;&#125;);(function fail() &#123; &quot;use strict&quot;; nonExtensible.newProperty = &quot;FAIL&quot;;&#125;());// TypeError: Cannot add property newProperty, object is not extensible 使用Object.defineProperty方法为一个不可扩展的对象添加新属性会抛出异常: Object.defineProperty(nonExtensible, &quot;new&quot;, &#123; value: 1 &#125;);// TypeError: Cannot define property new, object is not extensible 密封对象密封对象就是让对象不能添加新的属性，并且已有的属性不能被配置，也就是说不能删除已有属性，不能修改已有属性的可枚举性、可配置性、可写性，但 可能 可以修改已有属性的值的对象。密封对象主要涉及两个函数：Object.seal()、Object.isSealed()。 Object.isSealed本方法判断一个对象是否被密封： // 新建的对象默认不是密封的.var empty = &#123;&#125;;Object.isSealed(empty); // === false// 如果你把一个空对象变的不可扩展,则它同时也会变成个密封对象.Object.preventExtensions(empty);Object.isSealed(empty); // === true// 但如果这个对象不是空对象,则它不会变成密封对象,因为密封对象的所有自身属性必须是不可配置的.var hasProp = &#123; fee: &quot;fie foe fum&quot; &#125;;Object.preventExtensions(hasProp);Object.isSealed(hasProp); // === false// 如果把这个属性变的不可配置,则这个对象也就成了密封对象.Object.defineProperty(hasProp, &quot;fee&quot;, &#123; configurable: false &#125;);Object.isSealed(hasProp); // === true// 一个密封对象同时也必然是不可扩展的.Object.isExtensible(sealed); // === false 注意，在 ES5 中，如果参数不是一个对象类型（原始类型），将抛出一个 TypeError 异常。在 ES6 中， 非对象参数将被视为一个密封的普通对象，因此会返回 true。 // ES5 codeObject.isSealed(1);// TypeError: 1 is not an object // ES6 codeObject.isSealed(1);// true Object.seal密封一个对象会让这个对象变的不能添加新属性，且所有已有属性会变的不可配置，即属性不可被删除，数据属性不能被重新定义为访问其属性，但是值可能允许被修改： var obj = &#123; foo: &quot;foo&quot;&#125;;Object.seal(obj);// 仍然可以修改密封对象上的属性的值.obj.foo = &quot;bar&quot;; // Object &#123;foo: &quot;bar&quot;&#125;// 但你不能把一个数据属性重定义成访问器属性.Object.defineProperty(obj, &quot;foo&quot;, &#123; get: function() &#123; return &quot;g&quot;; &#125; &#125;); // 抛出TypeError异常 为密封对象添加属性或者删除属性会静默失败，在严格模式下会抛出 TypeError 异常： var obj = &#123; foo: &quot;foo&quot;&#125;;Object.seal(obj);obj.bar = &quot;bar&quot;; // 静默失败,新属性没有成功添加delete obj.foo; // 静默失败,属性没有删除成功console.log(obj); // Object &#123;foo: &quot;bar&quot;&#125;// ...在严格模式中,会抛出TypeError异常(function fail() &#123; &quot;use strict&quot;; delete obj.foo; // TypeError: Cannot delete property &#x27;foo&#x27; of #&lt;Object&gt;&#125;());(function fail() &#123; &quot;use strict&quot;; obj.bar = &quot;bar&quot;; // TypeError: Cannot add property bar, object is not extensible&#125;()); 密封对象不会影响从原型链上继承的属性，但原型属性的值也会不能修改。 冻结对象冻结对象的所有属性都不能被修改，任何尝试修改的操作都会失败，也就是说被冻结的对象是不可扩展（not extensible），不可配置（not configurable），并且所有的数据属性都不可写（not writable），换言之，这个对象是不可变的。 同样的，冻结操作也包含两个函数： Object.isFrozen()、Object.freeze() 。 Object.isFrozen看几个例子： // 一个对象默认是可扩展的,所以它也是非冻结的.assert(Object.isFrozen(&#123;&#125;) === false);// 一个不可扩展的空对象同时也是一个冻结对象.var vacuouslyFrozen = Object.preventExtensions(&#123;&#125;);assert(Object.isFrozen(vacuouslyFrozen) === true);// 一个非空对象默认也是非冻结的.var oneProp = &#123; p: 42 &#125;;assert(Object.isFrozen(oneProp) === false);// 让这个对象变的不可扩展,并不意味着这个对象变成了冻结对象,// 因为p属性仍然是可以配置的(而且可写的).Object.preventExtensions(oneProp);assert(Object.isFrozen(oneProp) === false);// ...如果删除了这个属性,则它会成为一个冻结对象.delete oneProp.p;assert(Object.isFrozen(oneProp) === true);// 一个不可扩展的对象,拥有一个不可写但可配置的属性,则它仍然是非冻结的.var nonWritable = &#123; e: &quot;plep&quot; &#125;;Object.preventExtensions(nonWritable);Object.defineProperty(nonWritable, &quot;e&quot;, &#123; writable: false &#125;); // 变得不可写assert(Object.isFrozen(nonWritable) === false);// 把这个属性改为不可配置,会让这个对象成为冻结对象.Object.defineProperty(nonWritable, &quot;e&quot;, &#123; configurable: false &#125;); // 变得不可配置assert(Object.isFrozen(nonWritable) === true);// 一个不可扩展的对象,拥有一个不可配置但可写的属性,则它仍然是非冻结的.var nonConfigurable = &#123; release: &quot;the kraken!&quot; &#125;;Object.preventExtensions(nonConfigurable);Object.defineProperty(nonConfigurable, &quot;release&quot;, &#123; configurable: false &#125;);assert(Object.isFrozen(nonConfigurable) === false);// 把这个属性改为不可写,会让这个对象成为冻结对象.Object.defineProperty(nonConfigurable, &quot;release&quot;, &#123; writable: false &#125;);assert(Object.isFrozen(nonConfigurable) === true);// 一个不可扩展的对象,值拥有一个访问器属性,则它仍然是非冻结的.var accessor = &#123; get food() &#123; return &quot;yum&quot;; &#125; &#125;;Object.preventExtensions(accessor);assert(Object.isFrozen(accessor) === false);// ...但把这个属性改为不可配置,会让这个对象成为冻结对象.Object.defineProperty(accessor, &quot;food&quot;, &#123; configurable: false &#125;);assert(Object.isFrozen(accessor) === true);// 使用Object.freeze是冻结一个对象最方便的方法.var frozen = &#123; 1: 81 &#125;;assert(Object.isFrozen(frozen) === false);Object.freeze(frozen);assert(Object.isFrozen(frozen) === true); 上述示例看起来有点绕，总结起来也就是说如果一个对象不可扩展，并且其所有属性都是不可配置的，那么这个对象是被密封的，如果同时，所有属性都是不可写的，那么这个对象同时是被冻结的。 一个冻结对象也是一个密封对象，当然，也是一个不可扩展的对象： // 一个冻结对象也是一个密封对象.assert(Object.isSealed(frozen) === true);// 当然,更是一个不可扩展的对象.assert(Object.isExtensible(frozen) === false); 同样的，在 ES5 中，如果参数不是一个对象类型，将抛出一个 TypeError 异常。在 ES6 中，非对象参数将被视为一个冻结的普通对象，因此会返回 true： // ES5 codeObject.isFrozen(1);// TypeError: 1 is not an object // ES6 codeObject.isFrozen(1);// true Object.freezeObject.freeze() 方法可以冻结一个对象， var obj = &#123; prop: function ()&#123;&#125;, foo: &quot;bar&quot;&#125;;// 可以添加新的属性,已有的属性可以被修改或删除obj.foo = &quot;baz&quot;;obj.lumpy = &quot;woof&quot;;delete obj.prop;var o = Object.freeze(obj);assert(Object.isFrozen(obj) === true);// 现在任何修改操作都会失败obj.foo = &quot;quux&quot;; // 静默失败obj.quaxxor = &quot;the friendly duck&quot;; // 静默失败,并没有成功添加上新的属性 同样的，对象被冻结后，任何尝试修改该对象的操作都会失败，非严格模式下静默失败，严格模式下会抛出异常，不再举例。 深冻结如果对象的一个属性的值是个对象，则这个对象中的属性是可以修改的，除非它也是个冻结对象，Object.freeze 只能“浅冻结”一个对象： obj = &#123; internal : &#123;&#125;&#125;;Object.freeze(obj);obj.internal.a = &quot;aValue&quot;;obj.internal.a; // &quot;aValue&quot;Object.isFrozen(obj.internal);// false 如果想让一个对象变的完全冻结，也就是对象的属性为对象的时候也冻结它，称之为“深冻结”可以使用下面函数： function deepFreeze (o) &#123; var prop, propKey; Object.freeze(o); // 首先冻结第一层对象. for (propKey in o) &#123; prop = o[propKey]; if (!o.hasOwnProperty(propKey) || !(typeof prop === &quot;object&quot;) || Object.isFrozen(prop)) &#123; // 跳过原型链上的属性和已冻结的对象. continue; &#125; deepFreeze(prop); //递归调用. &#125;&#125;obj2 = &#123; internal : &#123;&#125;&#125;;deepFreeze(obj2);obj2.internal.a = &quot;anotherValue&quot;;obj2.internal.a; // undefinedObject.isFrozen(obj2.internal) // true 总结这里综合比较一下三种冻结的特性： 阻止扩展 （不可被扩展，属性可以被修改、删除，不能添加） Object.isExtensible/Object.isExtensible Object.preventExtensions/Object.preventExtensions 密封 （不可被扩展，属性不可被配置，属性可能允许修改，不能添加、删除） Object.isSealed Object.seal 冻结 （不可被扩展，属性不可被配置，不可被修改、添加、删除） Object.isFrozen Object.freeze 这三种阻止扩展的方法是层层加强的： seal = configurable: false + preventExtensionsfreeze = writable: false + configurable: false + preventExtensionsfreeze = writable: false + seal 总而言之，如果一个对象不可扩展，并且其所有属性都是不可配置的，那么这个对象是被密封的，如果同时，所有属性都是不可写的，那么这个对象同时是被冻结的。 还有，需要注意的是，冻结操作一点被使用，则无法撤销。 参考本文示例和内容大量参考了各个接口的 MDN 的相关文档，不再一一列举。","categories":[{"name":"js","slug":"js","permalink":"http://tcatche.site/categories/js/"}],"tags":[{"name":"扩展","slug":"扩展","permalink":"http://tcatche.site/tags/%E6%89%A9%E5%B1%95/"}]},{"title":"React - Components, Elements, and Instances","slug":"react-components-elements-and-instances","date":"2017-06-19T07:19:00.000Z","updated":"2018-08-01T10:41:24.000Z","comments":true,"path":"2017/06/react-components-elements-and-instances/","link":"","permalink":"http://tcatche.site/2017/06/react-components-elements-and-instances/","excerpt":"","text":"组件（Components）、元素（Elements）和实例（Instances）之间的区别很容易被混淆，本文主要介绍了这几个概念的区别并详细说明了 React 管理 DOM 的思路。 传统组件自己管理实例（Managing the Instances）在传统的面向对象的 UI 编程中，你需要自己手动创建和管理各种组件的实例对象，比如，一个 Form 组件想要渲染一个 Button 子组件，需要实例化这个 Button 子组件，并且手动更新他们的内容： class Form extends TraditionalObjectOrientedView &#123; render() &#123; // Read some data passed to the view const &#123; isSubmitted, buttonText &#125; = this.attrs; if (!isSubmitted &amp;&amp; !this.button) &#123; // Form is not yet submitted. Create the button! this.button = new Button(&#123; children: buttonText, color: &#x27;blue&#x27; &#125;); this.el.appendChild(this.button.el); &#125; if (this.button) &#123; // The button is visible. Update its text! this.button.attrs.children = buttonText; this.button.render(); &#125; if (isSubmitted &amp;&amp; this.button) &#123; // Form was submitted. Destroy the button! this.el.removeChild(this.button.el); this.button.destroy(); &#125; if (isSubmitted &amp;&amp; !this.message) &#123; // Form was submitted. Show the success message! this.message = new Message(&#123; text: &#x27;Success!&#x27; &#125;); this.el.appendChild(this.message.el); &#125; &#125;&#125; 这只是一个伪代码，但是当使用类似 Backbone 的库以面向对象方式编写复合 UI 代码时，大概的结构就是这个样子。 每一个组件实例都需要保留它的 DOM 节点引用和子组件的实例，炳轩仔在合适的时机去创建、更新、删除这些实例。代码行数会随着组件的状态数量，以几何的速度增长。而且组件还需要访问它的子组件实例，这样耦合度非常高，难以解耦。 而 React 则采用了不同的方式： React 使用元素描述节点树（Elements Describe the Tree）在 react 中使用“元素”描述了节点树： An element is a plain object describing a component instance or DOM node and its desired properties.元素是一个简单对象（plain object），它描述了组件的示例或者DOM 节点以及它们所需要的属性。元素仅包含组件的类型、组件的属性和它的子元素或子组件。 元素不是实际存在的示例，相反，它用于告诉 react 想要展示在屏幕上的内容，不能在元素上调用任何方法，它仅仅是一个不可变的描述对象，包含两个字段：type: (string | ReactClass) 和 props: Object。 DOM 元素（DOM Elements）当元素的 type 字段值类型是字符串的时候，它描述了一个这个类型的 DOM 节点（此时 type 的值就是一个 tagName ，比如是 div）， props 则是这个节点的属性，如下元素： &#123; type: &#x27;button&#x27;, props: &#123; className: &#x27;button button-blue&#x27;, children: &#123; type: &#x27;b&#x27;, props: &#123; children: &#x27;OK!&#x27; &#125; &#125; &#125;&#125; 这个元素描述了如下的 HTML 结构： &lt;button class=&#x27;button button-blue&#x27;&gt; &lt;b&gt; OK! &lt;/b&gt;&lt;/button&gt; 注意元素是怎么嵌套的，当我们想要创建一个元素树的时候，指定一个或者多个元素作为容器的子元素。 需要知道的是这些元素仅仅是对内容的一种描述，并不是实际存在的实例，当它们被创建的时候，并不会被饮用任何屏幕上的的东西，你可以任意的创建和删除它们，不会对屏幕上的内容造成任何的影响。 React 元素非常容易遍历，不需要解析，而且比实际的 DOM 元素轻量的多，它们只是一些 plain object 。 组件元素（Component Elements）元素的 type 字段值类型可以是一个 React 组件相关联的函数或者类： &#123; type: Button, props: &#123; color: &#x27;blue&#x27;, children: &#x27;OK!&#x27; &#125;&#125; 这就是 react 的核心观念： An element describing a component is also an element, just like an element describing the DOM node. They can be nested and mixed with each other.一个描述组件的元素依然是元素，和描述 DOM 的元素没有任何区别，它们可以被互相嵌套和混合。 这个特性允许你定义一个 DangerButton 组件作为一个有特定 color 属性的 Button 组件，而不需要关心 Button 组件对应的 DOM 是 &lt;button&gt; 、 &lt;div&gt; 或者是其他： const DangerButton = (&#123; children &#125;) =&gt; (&#123; type: Button, props: &#123; color: &#x27;red&#x27;, children: children &#125;&#125;); 同时，你可以混搭 DOM 元素和组件元素在一个元素树中： const DeleteAccount = () =&gt; (&#123; type: &#x27;div&#x27;, props: &#123; children: [&#123; type: &#x27;p&#x27;, props: &#123; children: &#x27;Are you sure?&#x27; &#125; &#125;, &#123; type: DangerButton, props: &#123; children: &#x27;Yep&#x27; &#125; &#125;, &#123; type: Button, props: &#123; color: &#x27;blue&#x27;, children: &#x27;Cancel&#x27; &#125; &#125;]&#125;); 或者，可以使用 jsx ： const DeleteAccount = () =&gt; ( &lt;div&gt; &lt;p&gt;Are you sure?&lt;/p&gt; &lt;DangerButton&gt;Yep&lt;/DangerButton&gt; &lt;Button color=&#x27;blue&#x27;&gt;Cancel&lt;/Button&gt; &lt;/div&gt;); 这种混合搭配有助于保持组件之间的解耦，它们可以仅通过组合（composition）就可以表达组件间的 is-a 和 has-a 关系： Button 是（is-a）附带特定参数的 &lt;button&gt; DangerButton 是（is-a）附带特定参数的 Button 组件 DeleteAccount 是在 &lt;div&gt; 里包含（has-a） Button 和 DangerButton 组件封装元素树（Components Encapsulate Element Trees）当 React 遇到一个 type 属性是函数或者类的元素， React 就会把 props 传递给这个组件，并获取这个组件返回的元素，如下示例： &#123; type: Button, props: &#123; color: &#x27;blue&#x27;, children: &#x27;OK!&#x27; &#125;&#125; React 把 props 属性传递给 Button 组件，Button 组件返回它的元素： &#123; type: &#x27;button&#x27;, props: &#123; className: &#x27;button button-blue&#x27;, children: &#123; type: &#x27;b&#x27;, props: &#123; children: &#x27;OK!&#x27; &#125; &#125; &#125;&#125; React 会不断重复这个过程，知道它确切的了解了所有的组件对应的底层 DOM 元素，如最开始的 Form 示例，使用 React 可以被写成这个形式： const Form = (&#123; isSubmitted, buttonText &#125;) =&gt; &#123; if (isSubmitted) &#123; // Form submitted! Return a message element. return &#123; type: Message, props: &#123; text: &#x27;Success!&#x27; &#125; &#125;; &#125; // Form is still visible! Return a button element. return &#123; type: Button, props: &#123; children: buttonText, color: &#x27;blue&#x27; &#125; &#125;;&#125;; 就是这样，对于 React 组件而言， props 是输入，而元素或者元素树则是输出。 被组件返回的元素树可能包含描述 DOM 节点和描述其他组件的子元素，这可以让我们更自由的组合 UI 而不需要依赖它们内部的结构。 也就是说，React 会替我们完成实例的创建、更新和销毁的实例管理的工作，我们只需要使用组件返回元素来描述它们。 组件可以是类或者函数（Components Can Be Classes or Functions）在上述的示例中，Form ，Message 和 Button 都是 React 组件，React 组件有多种创建方式：写成函数、继承 React.Component 、 使用 React.createClass，这三种方式几乎一样： 1.使用函数创建组件： const Button = (&#123; children, color &#125;) =&gt; (&#123; type: &#x27;button&#x27;, props: &#123; className: &#x27;button button-&#x27; + color, children: &#123; type: &#x27;b&#x27;, props: &#123; children: children &#125; &#125; &#125;&#125;); 2.使用 React.createClass() 工厂方法： const Button = React.createClass(&#123; render() &#123; const &#123; children, color &#125; = this.props; return &#123; type: &#x27;button&#x27;, props: &#123; className: &#x27;button button-&#x27; + color, children: &#123; type: &#x27;b&#x27;, props: &#123; children: children &#125; &#125; &#125; &#125;; &#125;&#125;); 3.创建一个 ES6 的类，继承 React.Component： class Button extends React.Component &#123; render() &#123; const &#123; children, color &#125; = this.props; return &#123; type: &#x27;button&#x27;, props: &#123; className: &#x27;button button-&#x27; + color, children: &#123; type: &#x27;b&#x27;, props: &#123; children: children &#125; &#125; &#125; &#125;; &#125;&#125; 当然，当组件被定义为类的时候，回避当一位函数方法更加的强大，它可以存储一些本地状态，以及执行一些生命周期中的操作，比如在 DOM 被创建或删除的时候执行一些操作。 但是，函数组件虽然没有类组件强大，但是更加简洁，当不需要维护内部状态和声明周期的操作时，桁架建议使用函数组件。 不管是函数组件或者类组件，他们都是 React 组件，都以 Props 作为输入，以元素作为输出。 自上而下的和解(Top-Down Reconciliation)当调用： ReactDOM.render(&#123; type: Form, props: &#123; isSubmitted: false, buttonText: &#x27;OK!&#x27; &#125;&#125;, document.getElementById(&#x27;root&#x27;)); React 会提供这些 props 给 Form 组件，并获取 Form 返回的元素树，React 会以“更简单的原语”（simpler primitives）简化对你的元素树的理解，这个过程如下： 1.我们给 React 这个结构： &#123; type: Form, props: &#123; isSubmitted: false, buttonText: &#x27;OK!&#x27; &#125;&#125; 2.React 向 Form 组件查询元素树, Form 返回以下： &#123; type: Button, props: &#123; children: &#x27;OK!&#x27;, color: &#x27;blue&#x27; &#125;&#125; 3.React 向 Button 组件查询元素树, Button 返回以下，到了最底层结束： &#123; type: &#x27;button&#x27;, props: &#123; className: &#x27;button button-blue&#x27;, children: &#123; type: &#x27;b&#x27;, props: &#123; children: &#x27;OK!&#x27; &#125; &#125; &#125;&#125; 这个过程是被 React 称为 Reconciliation 过程的一部分，当你调用 ReactDOM.render() 或者 setState() 的时候会被执行。在这个过程结束后，React 知道了 DOM 树的结果，然后使用如 react-dom 或 react-native 的 renderer 根据应用必需的最小的变更内容更新``DOM视图（或者是React Native` 的特定平台视图）。 这种渐进式的“精炼”（refining）过程正是 React 应用很容易优化的原因，如果组件树的某一部分变得非常大的情况下，可以让 React 跳过这部分的“精炼”以及 diff 的过程（使用 shouldComponentUpdate ），如果 props 是不可更改的（immutable），比较它们的变化会非常的快，这也是 React 和 immutability 结合非常好的原因，并且可以使用最小的代价获得最大的优化。 你可能注意到这篇文章讲了大量的关于组件和元素的内容，但是并没有提到太多关于实例的内容。这是因为，和传统的面向对象的 UI 框架相比较，实例在 React 中并没有那么的重要。 只有当组件声明为类的时候才会拥有实例，但是从来不需要直接创建它的实例，React 会帮你创建和管理它的实例。只有在一些特殊的情况下，组件需要 访问实例 执行操作，比如，为一个表单元素获取焦点，而且这种行为通常是需要避免的。 总结（Summary）元素是一个简单对象，用于描述你想通过 DOM 节点或者其他组件展示在屏幕上的内容。元素可以在它们的属性中包含其他的元素。创建一个 React 元素的成本非常的低，一个元素一旦被创建，将不能修改。 实例是在组件上使用 this 获得的，它在存储本地状态和执行生命周期的事件非常有用。 函数式组件并不存在实例，类组件存在有实例，但是通常不需要我们管理，有 React 替我们管理这些实例。 创建 React 元素有 React.createElement()、React.createFactory()、JSX、函数式几种方法，不要在代码里用对象来写元素，只需要知道元素的本质是对象即可。 注意 出于安全的考虑，所有的 React 元素都需要声明一个额外的 $$typeof: Symbol.for(&#39;react.element&#39;) 字段，这个字段在上述的例子中都被忽略了。这边文章主要用于介绍上述概念，所以除非添加该字段或者使用 React.createElement 或 JSX 去修改上面的代码，否则上面的代码并不能正常的运行。 参考本文主要翻译了 React 的官方文档： React Components, Elements, and Instances，并根据个人理解和习惯稍有调整。","categories":[{"name":"js","slug":"js","permalink":"http://tcatche.site/categories/js/"}],"tags":[{"name":"react","slug":"react","permalink":"http://tcatche.site/tags/react/"}]},{"title":"window.requestAnimationFrame","slug":"request-frame-animate","date":"2017-06-12T07:49:00.000Z","updated":"2018-08-01T10:41:24.000Z","comments":true,"path":"2017/06/request-frame-animate/","link":"","permalink":"http://tcatche.site/2017/06/request-frame-animate/","excerpt":"","text":"对于动画而言，设置一个合适的更新周期是非常重要的，更新周期越短，动画则越平滑流畅，但是，间隔时间过短，则会对系统资源的消耗增加，另一方面，大多数显示器的刷新频率是 60HZ ，更新速度超过这个数值并没有什么意义，因为显示器不会刷新，因此动画的最佳执行时间间隔是 1000ms/60 约等于 16.7ms 执行一次更加合适。 而为 setTimeout 与 setInterval 设置这样的更新频率并不有效，它们的运行时间并不准确，如果它们之前有耗时的同步任务，则他们的执行时机会被大大的推迟，并不能做到准去的执行。 而 HTML5 新引入的专门处理动画的定时器 requestAnimationFrame 则是专门处理动画的周期执行函数，和 setTimeout 与 setInterval 相比，不需要指定运行的时间间隔，由浏览器决定函数的执行时机，可以保证执行效率和执行时效的需要。 特点和 setTimeout 与 setInterval 相比较， requestAnimationFrame 的方式的特点如下： requestAnimationFrame 是浏览器专门提供给处理动画用的 API，浏览器会对其进行专门的优化，在运行的时候，如果页面未激活，动画会自动被暂停，节约资源； 如果元素不可见，requestAnimationFrame 将不会进行回流和重绘； requestAnimationFrame 会把每一次执行的所有 DOM 操作集合起来，在一个渲染周期内完成重绘，从而使动画效果更加的流畅。 使用requestAnimationFrame 的使用和 setTimeout 类似，只不过不需要设置时间间隔 var step = function(timer) &#123; //do sth;&#125;var requestID = requestAnimationFrame(step); requestAnimationFrame 不能设置执行的时间间隔，调用一次则执行一次，如果需要类似于 setInterval 的多次执行，可在回调函数中调用 requestAnimationFrame ， 这样回调函数就会自动在下一个合适的时机被调用： var requestID = 0;var step = function(timer) &#123; //do sth; requestID = requestAnimationFrame(step);&#125;requestID = requestAnimationFrame(step); 返回的 requestID 是一个长整型非零值,作为每个 requestAnimationFrame 的唯一的标识符，可以将该值作为参数传给 window.cancelAnimationFrame() 来取消这个回调函数，如果多次执行 requestAnimationFrame 时，在每次执行的时候都需要更新 requestID ，否则无法取消 ： var i = 0var requestID = 0;var step = function(timer) &#123; console.log(i); i ++; if (i &gt; 100) &#123; cancelAnimationFrame(requestID) &#125; requestID = requestAnimationFrame(step);&#125;requestID = requestAnimationFrame(step); 浏览器兼容首先看一下浏览器的兼容性： 从图上可以看出，支持度已经比较高了，基本可以放心使用，对于不支持这个函数的浏览器，可以使用浏览器专用方法或者 setTimeout 替代： (function() &#123; var vendors = [&#x27;webkit&#x27;, &#x27;moz&#x27;]; for (var i = 0; i &lt; vendors.length &amp;&amp; !window.requestAnimationFrame; ++i) &#123; var vp = vendors[i]; window.requestAnimationFrame = window[vp+&#x27;RequestAnimationFrame&#x27;]; window.cancelAnimationFrame = (window[vp+&#x27;CancelAnimationFrame&#x27;] || window[vp+&#x27;CancelRequestAnimationFrame&#x27;]); &#125; window.requestAnimationFrame = window.requestAnimationFrame || function(callback) &#123; window.setTimeout(callback, 1000 / 60); &#125;; &#125;()); 上面这个实现比较简单，主要是用各个浏览器的私有方法，并对不存在该私有方法的浏览器采用 setTimeout 实现，其实现实际上和 requestAnimationFrame 并不一致，但已经可以保证应用在大多数的场合之下了，更加完善的被 Erik Möller 实现的 polyfill 代码如下： // Adapted from https://gist.github.com/paulirish/1579671 which derived from // http://paulirish.com/2011/requestanimationframe-for-smart-animating/// http://my.opera.com/emoller/blog/2011/12/20/requestanimationframe-for-smart-er-animating// requestAnimationFrame polyfill by Erik Möller.// Fixes from Paul Irish, Tino Zijdel, Andrew Mao, Klemen Slavič, Darius Bacon// MIT licenseif (!Date.now) Date.now = function() &#123; return new Date().getTime(); &#125;;(function() &#123; &#x27;use strict&#x27;; var vendors = [&#x27;webkit&#x27;, &#x27;moz&#x27;]; for (var i = 0; i &lt; vendors.length &amp;&amp; !window.requestAnimationFrame; ++i) &#123; var vp = vendors[i]; window.requestAnimationFrame = window[vp+&#x27;RequestAnimationFrame&#x27;]; window.cancelAnimationFrame = (window[vp+&#x27;CancelAnimationFrame&#x27;] || window[vp+&#x27;CancelRequestAnimationFrame&#x27;]); &#125; if (/iP(ad|hone|od).*OS 6/.test(window.navigator.userAgent) // iOS6 is buggy || !window.requestAnimationFrame || !window.cancelAnimationFrame) &#123; var lastTime = 0; window.requestAnimationFrame = function(callback) &#123; var now = Date.now(); var nextTime = Math.max(lastTime + 16, now); return setTimeout(function() &#123; callback(lastTime = nextTime); &#125;, nextTime - now); &#125;; window.cancelAnimationFrame = clearTimeout; &#125;&#125;()); 参考 MDN-window.requestAnimationFrame 深入理解定时器系列第二篇——被誉为神器的requestAnimationFrame Polyfill-requestAnimationFrame","categories":[{"name":"js","slug":"js","permalink":"http://tcatche.site/categories/js/"}],"tags":[{"name":"window","slug":"window","permalink":"http://tcatche.site/tags/window/"},{"name":"BOM","slug":"BOM","permalink":"http://tcatche.site/tags/BOM/"}]},{"title":"React - React.Children","slug":"react-children","date":"2017-06-09T08:09:00.000Z","updated":"2018-08-01T10:41:24.000Z","comments":true,"path":"2017/06/react-children/","link":"","permalink":"http://tcatche.site/2017/06/react-children/","excerpt":"","text":"如我们所了解的， this.props.children 的取值有三种情况，如果当前组件没有子组件，则返回 undefined ，如果有一个元素，则返回数据类型为 object，如果有多个元素则返回类型为 array ，这样每次都要写一大堆的判断语句，并针对不同的返回结果执行不同的操作，这样将会非常繁琐， 好在 React.Children 提供了一些工具方法处理 this.props.children 这个不透明的数据结构。 React.Children.map React.Children.map(children, function[(thisArg)]) 遍历 children 并返回一个数组，如果 children 是 null 或者 undefined 将返回 null 或者 undefined 而不是一个空数组 React.Children.forEach React.Children.forEach(children, function[(thisArg)]) 类似于 React.Children.map ，遍历 this.props.children 但是不返回一个数组。 React.Children.count React.Children.count(children) 返回子组件中的组件数目，等于 map 和 forEach 的回调函数被调用次数。 React.Children.only React.Children.only(children) 如果 children 中有一个唯一的元素或者组件，则返回 children 中唯一的子组件或元素，否则，如果没有组件或者组件数大于1，会报错。 class Application extends React.Component &#123; componentDidMount() &#123;22try &#123;222React.Children.only(this.props.children); console.log(&#x27;have 1 sub-components, no error.&#x27;)22&#125; catch (e) &#123; console.log(&quot;have &quot; + React.Children.count(this.props.children) + &quot; sub-components, error.&quot;)222console.log(e)22&#125;2&#125; render() &#123; return null; &#125;&#125;ReactDOM.render( &lt;Application &gt;&lt;/Application&gt;, document.getElementById(&#x27;app&#x27;));// have 0 sub-components, error.ReactDOM.render( &lt;Application &gt;&lt;span /&gt;&lt;/Application&gt;, document.getElementById(&#x27;app&#x27;));// have 1 sub-components, no error.ReactDOM.render( &lt;Application &gt;&lt;span /&gt;&lt;span /&gt;&lt;/Application&gt;, document.getElementById(&#x27;app&#x27;));// have 2 sub-components, error React.Children.toArray React.Children.toArray(children) 将 children 结构返回为一个数组，并为每一个元素分配 key 值，对于需要操作 children 集合的元素来说很方便。","categories":[{"name":"js","slug":"js","permalink":"http://tcatche.site/categories/js/"}],"tags":[{"name":"react","slug":"react","permalink":"http://tcatche.site/tags/react/"}]},{"title":"React - ReactDOM","slug":"react-reactdom","date":"2017-06-07T09:26:00.000Z","updated":"2018-08-01T10:41:24.000Z","comments":true,"path":"2017/06/react-reactdom/","link":"","permalink":"http://tcatche.site/2017/06/react-reactdom/","excerpt":"","text":"react-dom 包提供了可以在应用程序顶层使用的 DOM 特定方法，可以在 React 模型外使用的。大多数组件并不需要使用此模块。 浏览器支持支持所有的现代浏览器，包括 IE9 及以上。 不支持那些不支持 ES5 方法的旧浏览器，但是如果页面使用了 es5-shim 和 es5-sham 的 polyfills，应用仍然可以在这些旧的浏览器上运行。 接口ReactDOM 提供了三个接口： render() unmountComponentAtNode() findDOMNode() render ReactDOM.render(element, container, [callback]) element： 要渲染的 React 组件或者 DOM 元素 container： 渲染内容的容器 [callback]： 可选的回调函数参数，在组件渲染后执行 render 是最常用的一个接口，将 React 组件或者 DOM 元素渲染到指定的 DOM 容器中，并返回该组件的引用（无状态组件返回 null ）。 如果 React 元素已经被渲染到容器中，并且只在必要的时候才更新 DOM 以反映最新的 React 元素。 ReactDOM.render 方法控制传入容器的内容。该方法在第一次被调用时，任何容器内现有的 DOM 元素都将被替换。后来的调用将使用 React 的 DOM diffing 算法进行有效的更新。 ReactDOM.render 方法不修改容器节点，只修改容器的子节点。 ReactDOM.render 方法返回对 React 根组件 ReactComponent 实例的引用。但是这个返回的引用是历史接口，应该避免使用，因为 React 的未来版本可能异步的渲染组件。如果需要使用这个实例的引用则可以为其附加 ref 的回调函数。 unmountComponentAtNode ReactDOM.unmountComponentAtNode(container) 从指定的 DOM 容器中中删除已加载的 React 组件，并清理其事件处理程序和 state 。如果没有任何组件被加载在容器中则什么也不做。如果组件被从容器卸载则返回 true ， 如果容器内没有组件或者元素卸载则返回 false ： &lt;div id=&quot;app&quot;&gt;&lt;/app&gt;&lt;div id=&quot;app2&quot;&gt;&lt;/app&gt; ReactDOM.render(&lt;div /&gt;, document.getElementById(&#x27;app&#x27;));console.log(ReactDOM.unmountComponentAtNode(document.getElementById(&#x27;app&#x27;))) // trueconsole.log(ReactDOM.unmountComponentAtNode(document.getElementById(&#x27;app2&#x27;))) // false findDOMNode ReactDOM.findDOMNode(component) 如果一个组件已经被加载到 DOM 中，这将返回该组件对应的本地浏览器中的 DOM 元素，该方法对于从 DOM 读取值非常有用，例如读取表单域的值和计算 DOM 尺寸。在大多数情况下，应当使用 ref 而避免使用该方法，当组件的 render 方法返回的结果为 null 或者 false， 本方法返回 null。 ReactDOM.findDOMNode 方法是用于访问底层 DOM 节点的。在大多数情况下，不鼓励使用此方法，因为它会破坏组件的抽象。 ReactDOM.findDOMNode 方法只能被用在已经挂载的组件，也就是说组件已经被渲染到 DOM 中，如果组件未被渲染到 DOM 中调用此方法，比如在组件的 render 方法中调用此方法，会抛出异常。 ReactDOM.findDOMNode 方法不能被用在函数式组件上。 参考 本文主要参考 React 的官方文档（ReactDOM），并根据个人理解和习惯做了一些结构的调整。","categories":[{"name":"js","slug":"js","permalink":"http://tcatche.site/categories/js/"}],"tags":[{"name":"react","slug":"react","permalink":"http://tcatche.site/tags/react/"}]},{"title":"React - Refs","slug":"react-refs","date":"2017-06-07T07:49:00.000Z","updated":"2020-07-22T02:19:41.732Z","comments":true,"path":"2017/06/react-refs/","link":"","permalink":"http://tcatche.site/2017/06/react-refs/","excerpt":"","text":"通常情况下， React 使用 props 和子组件进行交互，如果需要修改子组件，则通过更新子组件的 props 来重新 render 子组件，但是在有些情况下，可能想要在 props 的数据流之外修改 props ，对于这种情况， React 提供了 refs 来允许不通过 props 的数据流对子组件修改。 Refs 应用场合refs 的几个应用场合： 管理元素焦点、文本选择或者媒体播放等等； 触发命令式动画 与第三方的类库整合 refs 是直接操作 DOM 元素的，因此在使用之前，最好考虑一下是否真的必须需要使用 refs ，是否可以使用 state 来代替使用 refs ， react 的文档建议避免在可声明的对象上使用 refs ， 比如对于 Dialog 组件，通过向其传递 isOpen 属性来控制其显示隐藏，而不是调用其 open() 或者 close() 方法。 使用 Refs 属性React 允许为组件或者 HTML 元素添加一个特殊的 ref 属性，ref 属性是一个回调函数，这个回调函数在组件或者 HTML 元素被挂载或者移除挂载后自动执行，当这个回调函数执行的时候，会把这个组件或者 HTML 的实际的 DOM 元素做为参数给它，如以下示例： class CustomTextInput extends React.Component &#123; constructor(props) &#123; super(props); this.focus = this.focus.bind(this); &#125; focus() &#123; // Explicitly focus the text input using the raw DOM API this.textInput.focus(); &#125; render() &#123; // Use the `ref` callback to store a reference to the text input DOM // element in an instance field (for example, this.textInput). return ( &lt;div&gt; &lt;input type=&quot;text&quot; ref=&#123;input =&gt; this.textInput = input&#125; /&gt; &lt;input type=&quot;button&quot; value=&quot;Focus the text input&quot; onClick=&#123;this.focus&#125; /&gt; &lt;/div&gt; ); &#125;&#125; React 在 input 实例化的时候调用 ref 函数，并把该 input 元素作为参数传递进去，当这个元素卸载的时候，也会调用这个函数，此时传递的参数是 null。 在元素上使用 ref 属性通常是为了在某些场合下操作这个 DOM 元素，如本例使用 ref=&#123;input =&gt; this.textInput = input&#125; 保存了这个 input 的 DOM 元素的引用，然后在点击按钮的时候使其获得焦点。 在类组件上添加 Refs 引用当 ref 引用被用在一个声明为类的组件上， 此时传递给 ref 回调函数的参数是这个组件的实例，如下示例，对组件 CustomTextUnput 进行了一层包裹，试该组件加载完成后的自动获得焦点： class AutoFocusTextInput extends React.Component &#123; componentDidMount() &#123; this.textInput.focus(); &#125; render() &#123; return ( &lt;CustomTextInput ref=&#123;(input) =&gt; &#123; this.textInput = input; &#125; &#125; /&gt; ); &#125;&#125; 在上述示例中，ref 指向的是子组件的示例对象，通过这个引用，可以访问子组件的 focus 方法的。注意，只有当 CustomTextUnput 被声明为一个类组件的时候才能正常工作： class CustomTextInput extends React.Component &#123; // ...&#125; 在函数式组件上不能使用 Refs函数式组件由于没有示例，因此不能对其使用 ref ，如果需要使用 ref 引用，则必须先将其转换为类组件： function MyFunctionalComponent() &#123; return &lt;input /&gt;;&#125;class Parent extends React.Component &#123; render() &#123; // This will *not* work! return ( &lt;MyFunctionalComponent ref=&#123;(input) =&gt; this.textInput = input&#125; /&gt; ); &#125;&#125; 虽然函数式组件上不能使用 ref 但是，可以在函数式组件内部使用，前提是使用在类组件或者 DOM 元素： function CustomTextInput(props) &#123; // textInput must be declared here so the ref callback can refer to it let textInput = null; function handleClick() &#123; textInput.focus(); &#125; return ( &lt;div&gt; &lt;input type=&quot;text&quot; ref=&#123;(input) =&gt; &#123; textInput = input; &#125; &#125; /&gt; &lt;input type=&quot;button&quot; value=&quot;Focus the text input&quot; onClick=&#123;handleClick&#125; /&gt; &lt;/div&gt; );&#125; 给父组件暴露 DOM 的Refs在很少的一些情况下，可能需要从父组件访问子组件的 DOM 元素，这种方式不推荐，因为破坏了组件的封装，但是在一些如触发子组件 DOM 的焦点，计算子组件的大小或位置场合下会需要。 根据前两节，直接给子组件增加 ref 是没有用的，这种方式只能获得自组件实例的引用而不是子组件，因此并无法操作子组件的 DOM 元素，而且这对函数式组件不起作用。相反的，这种情况下可以给子组件传递一个 prop ，通过这个 prop 给子组件传递 ref 的回调函数，然后在子组件内把这个 ref 绑定在自己的 DOM 元素上，通过这种方式，使父组件获得自足件的 DOM 元素引用，并且可以通过中间组件传递，而且，对于函数式组件也可以使用，具体看如下示例： function CustomTextInput(props) &#123; return ( &lt;div&gt; &lt;input ref=&#123;props.inputRef&#125; /&gt; &lt;/div&gt; );&#125;class Parent extends React.Component &#123; render() &#123; return ( &lt;CustomTextInput inputRef=&#123;el =&gt; this.inputElement = el&#125; /&gt; ); &#125;&#125; 在上面的示例中， Parent 组件通过 inputRef prop 传递自己的 ref 回调函数给 CustomTextInput ， CustomTextInput 使用 Parent 组件传递过来的 inputRef 为 input 元素绑定 ref，这样 Parent 组件就保留了 CustomTextInput 组件的 input 元素的引用，就可以对其进行一些必要的操作，比如使其获得焦点。 而且注意到，CustomTextInput 实际是个函数式组件，这种方式也不会被 ref 只能绑定到类组件和 DOM 元素所限制，因为 ref 被通过 props 传递给它的。 这种方式的另一个有点是可以支持很深的组件层级，比如，如果中间的组件不需要这个引用，可以直接将其传递给其子组件处理： function CustomTextInput(props) &#123; return ( &lt;div&gt; &lt;input ref=&#123;props.inputRef&#125; /&gt; &lt;/div&gt; );&#125;function Parent(props) &#123; return ( &lt;div&gt; My input: &lt;CustomTextInput inputRef=&#123;props.inputRef&#125; /&gt; &lt;/div&gt; );&#125;class Grandparent extends React.Component &#123; render() &#123; return ( &lt;Parent inputRef=&#123;el =&gt; this.inputElement = el&#125; /&gt; ); &#125;&#125; 如上述示例，中间组件 Parent 收到其父组件 Grandparent 传递的 inputRef ， 直接将其丢给下一级组件 CustomTextInput 处理。 注意到，这种方式下需要修改子组件的代码，如果在某些情况子组件是不受控制的，无法修改子组件的代码的时候，则还有一种方式是使用 ReactDOM.findDOMNode(component) ，这种方式不鼓励使用，只有在别无选择的时候可以考虑。 旧版 API：字符串 Refs之前的版本使用字符串的 this.refs.input ，这种方式存在一些问题，仅作保留兼容，未来可能被一处，不要使用。 注意事项如果 ref 回调被定义为一个内联函数，在组件更新的时候它会被调用两次，第一次是传入 null 调用，第二次传入 DOM 元素调用。这是因为每一次重新渲染的时候，传递给 ref 的回调函数都是新创建的函数实例，因此 React 需要清除旧的 ref 然后重新设置。大多数情况下是无关紧要的，通过传入一个绑定在类上的函数来可以避免这个问题。 参考 本文主要参考 React 的官方文档（Refs and the DOM），并根据个人理解和习惯做了一些结构的调整。","categories":[{"name":"js","slug":"js","permalink":"http://tcatche.site/categories/js/"}],"tags":[{"name":"react","slug":"react","permalink":"http://tcatche.site/tags/react/"}]},{"title":"ES6 - Iterator 与 for...of","slug":"iteritor-and-for-of","date":"2017-05-25T07:30:00.000Z","updated":"2018-08-01T10:41:24.000Z","comments":true,"path":"2017/05/iteritor-and-for-of/","link":"","permalink":"http://tcatche.site/2017/05/iteritor-and-for-of/","excerpt":"","text":"概述Iterator 接口允许为所有数据结构，提供了一种统一的遍历机制，被 for...of 使用这种机制遍历这些数据结构， 一些内置类型都是内置的可遍历对象并且有默认的迭代行为, 比如 Array , 另一些类型则不是， 比如 Object 。 为了变成可遍历解构，对象或其原型链上某个对象必须实现 @@iterator 方法，即属性名为 Symbol.iterator 。 当该对象需要被遍历的时候（比如用于一个 for..of 循环中），它的 @@iterator 方法被调用并且无参数，然后返回一个用于在遍历中获得值的迭代器，具体过程如下： 创建一个指针对象，指向当前数据结构的起始位置； 第一次调用该指针对象的 next 方法，指向数据结构的第一个成员，返回结果是一个包含 value 和 done 两个属性的对象。 value 字段表示当前遍历的成员的值。 如果 done 的值为 true ，则遍历结束，否则，done 的值为 false ，下次会继续遍历下一个成员。 可以看一下数组的默认遍历器 let arr = [&quot;a&quot;, &quot;b&quot;];let iter = arr[Symbol.iterator]();iter.next(); // Object &#123;value: &quot;a&quot;, done: false&#125;iter.next(); // Object &#123;value: &quot;b&quot;, done: false&#125;iter.next(); // Object &#123;value: undefined, done: true&#125; 第 1 次调用 iter.next() ，返回数组的第1个元素 value 为 a，以及 done 的值为 fasle ，表示遍历没有结束，还可以继续遍历。 第 2 次调用 iter.next() ，返回数组的第2个元素 value 为 b，以及 done 的值还是为 fasle ，表示遍历没有结束，还可以继续遍历。 第 3 次调用 iter.next() ，返回的 value 为 undefined，done 的值为 true ，遍历结束。 了解了这些，就可以创建一个可遍历的对象，并定义它的遍历行为： let obj = &#123; data: [&#x27;a&#x27;, &#x27;b&#x27;], [Symbol.iterator]() &#123; const _self = this; let _curr = 0; return &#123; next() &#123; if (_curr &lt; _self.data.length) &#123; return &#123; value: _self.data[_curr ++], done: false &#125;; &#125; else &#123; return &#123; value: undefined, done: true &#125;; &#125; &#125; &#125;; &#125;&#125;;for (var value of obj) &#123; console.log(value) // a b&#125; Generate如果了解 Generate ，就会发现这个和 Generate 的结构非常相似，那么遍历函数可以使用 Generate 吗？ 答案是可以，接下来使用 Generate 函数改写上面的例子： let obj = &#123; data: [&#x27;a&#x27;, &#x27;b&#x27;], [Symbol.iterator]: function * () &#123; for (let index = 0; index &lt; this.data.length; index ++) &#123; yield this.data[index]; &#125; &#125;&#125;;for (var value of obj) &#123; console.log(value) // a b&#125; 使用 Generate 更加节省代码，而且流程也更加清晰，更容易理解。 内置支持迭代的对象String 、Array 、TypedArray 、Map 和 Set 都内置迭代器， 因为它们的原型对象都有一个 @@iterator 方法： var string = &quot;hello&quot;;for (var chr of string) &#123; console.log(chr); // h, e, l, l, o&#125; 支持迭代操作的语句、表达式和方法除了内置迭代器的对象，还有一些场合下也会使用迭代器： 解构赋值对数组和Set结构进行执行解构操作的时候，会调用对象的迭代器： let array = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;];[a, ...others] = arraya // &quot;a&quot;others // [&quot;b&quot;, &quot;c&quot;] 扩展运算符扩展运算符（...）也会调用默认的 iterator 接口： let hello = &quot;hello&quot;;[...hello] // [&quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot;]let array = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;];[...array, &quot;d&quot;]; // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;] 对象默认不支持迭代器，因此对象的解构赋值和扩展运算符并不是使用迭代器的： var &#123;a, ...others&#125; = &#123;a: 1, b: 2, c: 3&#125;// 等价于：function _objectWithoutProperties(obj, keys) &#123; var target = &#123;&#125;; for (var i in obj) &#123; if (keys.indexOf(i) &gt;= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; &#125; return target;&#125;var obj = &#123; a: 1, b: 2, c: 3 &#125;;var a = obj.a, others = _objectWithoutProperties(obj, [&quot;a&quot;]); for..of 循环前文已说明，不再多言 常见的类数组对象常见的一些类数组对象，如 arguments 、 NodeList 等也支持迭代器： (function test() &#123; for (let v in arguments) &#123; console.log(v); &#125;&#125;)(1, 2, 3)// 1 2 3 但并不是所有的类数组对象都支持迭代器，所以在使用的时候，可以先将其转换为数组： var arrLike = &#123; 0: 0, 1: 1, length: 2&#125;for (let val of arrLike) &#123; console.log(val); &#125;// Uncaught TypeError: undefined is not a functionfor (let val of Array.from(arrLike)) &#123; console.log(val); &#125;// 0 1 Generatorsgenerator函数自身就是一个迭代器，当然也可以使用迭代器： function * list() &#123; yield 1; yield 2; yield 3;&#125;for (var v in list()) &#123; console.log(v); // 1 2 3&#125; 接受数组或可迭代对象作为参数任何接受数组作为参数的场合，其实都调用了遍历器接口，如 Array.from() 、Map() , Set() , WeakMap() , WeakSet() 、Promise.all() 、Promise.race() ： var arr = [1, 2, 3];// 修改数组的迭代器，让返回结果都 *10arr[Symbol.iterator] = function() &#123; return &#123; next: function() &#123; if (this._curr &lt; arr.length) &#123; return &#123; value: arr[this._curr ++] * 10, done: false &#125;; &#125; else &#123; return &#123; done: true &#125;; &#125; &#125;, _curr: 0, &#125;;&#125;;for (let value of arr) &#123; console.log(value) // 10, 20, 30&#125;Array.from(arr) // [10, 20, 30]new Set(arr) // &#123;10, 20, 30&#125;arr.map(item =&gt; item) // [1, 2, 3] for 循环、for…in 以及 forEach等数组函数遍历对比在有些应用场景下，这些遍历方式可以通用，这个根据实际的应用场景选择即可。 for 循环for 语句遍历就一个特点，写起来麻烦，应用场景到时最普遍的。for 语句遍历对象的时候，如果遍历对象需要搭配其他函数，如 Object.keys(object) ，获得对象的键值 keys 的数组 for..infor..in 可以遍历对象和数组对象，但有一些情况需要注意： index 的索引为字符串的数字，不能直接进行数值的运算： var arr = [1, 2, 3];for (var index in arr) &#123; console.log(typeof index); // string&#125; for...in 会遍历对象上的所有可枚举属性，包括原型方和原型属性： var obj = &#123; a: 1&#125;obj.__proto__ = &#123; b: 2&#125;for (var key in obj) &#123; console.log(key)&#125;// a// b 如果不想遍历原型方法和原型属性的话可以使用 hasOwnPropery 做一个判断： for (var key in obj) &#123; if (obj.hasOwnProperty(key))&#123; console.log(key); &#125;&#125;// a 也可以使用 Object.keys(object) 获取对象自身的实例属性组成的数组： var keys = Object.keys(obj);for (var i = 0; i &lt; keys.length; i ++) &#123; console.log(keys[i]);&#125;// a forEach 等数组函数数组上也有一些方法支持遍历数组，比如 forEach 、map 、filter 、every 、reduce 等函数，这些函数都有着不同的用途，但是最主要的问题在于他们遍历数组的操作是在回调函数中执行、不能使用 continue 、break 中断遍历，而且不能直接 return 返回到外部。 参考 MDN-Iteration protocols ECMAScript 6 入门 An Introduction to JavaScript ES6 Iterators","categories":[{"name":"js","slug":"js","permalink":"http://tcatche.site/categories/js/"}],"tags":[{"name":"es","slug":"es","permalink":"http://tcatche.site/tags/es/"}]},{"title":"Array Like 对象","slug":"array-like-object","date":"2017-05-24T08:58:00.000Z","updated":"2021-08-09T06:39:53.230Z","comments":true,"path":"2017/05/array-like-object/","link":"","permalink":"http://tcatche.site/2017/05/array-like-object/","excerpt":"","text":"ArrayLike 对象ArrayLike（类数组/伪数组） ，就是像数组的对象，常见的 ArrayLike 对象有：NodeList 、 arguments 、 HTMLCollection 、 jQuery 对象甚至 String 等。 ArrayLike 实际上只需要一个硬性条件：有 length 属性即可： var obj = &#123;length: 3&#125;[].map.call(obj, item =&gt; item);// [undefined x 4] 通过数组方法访问的话，只能访问到 0 到 length-1 值为属性名的字段： var obj = &#123; &quot;0&quot;: 0, &quot;1&quot;: 1, &quot;2&quot;: 2, length: 2&#125;var arr = [].map.call(obj, item =&gt; item);console.log(arr)// [0, 1] ArrayLike 最主要的特性就是它的结构和 Array 对象类似，可以使用数组的方法操作它们，可以更方便的自由扩展，不用担心污染到原生的 Array ，最典型的应用就是 jQuery 了， 如下使用 jQuery 选择器 $(&#39;div&#39;) 以后的结构： $(&#x27;div&#x27;) = &#123; 0: .., ... 291: ... context: document, length: 292, prevObject: jQuery.fn.init(1), selector: &quot;div&quot;, __proto__: Object(0)&#125; ArrayLike 的判断这里直接拿来一下 lodash 的判断方法： const MAX_SAFE_INTEGER = 9007199254740991/** * Checks if `value` is a valid array-like length. * * **Note:** This method is loosely based on * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength). * * @since 4.0.0 */function isLength(value) &#123; return typeof value == &#x27;number&#x27; &amp;&amp; value &gt; -1 &amp;&amp; value % 1 == 0 &amp;&amp; value &lt;= MAX_SAFE_INTEGER&#125;/** * Checks if `value` is array-like. A value is considered array-like if it&#x27;s * not a function and has a `value.length` that&#x27;s an integer greater than or * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`. * * @since 4.0.0 */function isArrayLike(value) &#123; return value != null &amp;&amp; typeof value != &#x27;function&#x27; &amp;&amp; isLength(value.length)&#125; 由于类数组对象并不是规范，所以不同项目的实现都有些微的差异。 ArrayLike 是否需要转换为 Array基本上，类数组对象不需要特意转换为数组对象，因为数组的函数在实现的时候，并没有检测内部的 this 指针是否是数组，只需要有 length 属性和索引的元素访问即可，因此在类数组对象上也能使用，只需要使用 call 、apply 改变调用方式即可： var arrLike = &#123;0:&quot;a&quot;, 1:&quot;b&quot;, 2:&quot;c&quot;, length:3&#125;;Array.prototype.map.call(arrLike, item =&gt; item + item);// [&quot;aa&quot;, &quot;bb&quot;, &quot;cc&quot;]Array.prototype.filter.call(arrLike, item =&gt; item &lt;= &quot;a&quot;);// [&quot;a&quot;] Array-Like 转换为 ArrayES6 提供的 Array.from() 可以从一个类似数组或可迭代的对象中创建一个新的数组实例： Array.from(&#x27;foo&#x27;);// [&quot;f&quot;, &quot;o&quot;, &quot;o&quot;] 虽然 ES6 语法在最新的浏览器的普及度还是蛮高的，在一些老旧的浏览器下仍不支持，这个时候可以使用 Array.prototype.slice 将一个类数组对象或集合装换为数组： const arrayLikeToArray = (collection) =&gt; Array.prototype.slice.call(collection);// 或者const arrayLikeToArray = (collection) =&gt; [].slice.call(collection); 第二种方法略有性能的损失，会新建一个数组，不过考虑到执行引擎的优化，性能损失可以忽略，反而更省事。 也可以使用 bind 来简化该过程： var unboundSlice = Array.prototype.slice;var slice = Function.prototype.call.bind(unboundSlice);const arrayLikeToArray = collection =&gt; slice(collection); 但是 slice 方法在 IE &lt; 9 以下浏览器还有问题，如果仍需要兼容该版本浏览器，需要做一个修改： const arrayLikeToArray = collection =&gt; &#123; &#x27;use strict&#x27;; var _slice = Array.prototype.slice; try &#123; // Can&#x27;t be used with DOM elements in IE &lt; 9 return _slice.call(document.documentElement); &#125; catch (e) &#123; // Fails in IE &lt; 9 var arr = []; for (var i = 0, len = collection.length; i &lt; len; i++) &#123; arr[i] = collection[i]; &#125; return arr; &#125;&#125; 参考 MDN-Array.prototype.slice JavaScript: Array-Like Object to Array","categories":[{"name":"js","slug":"js","permalink":"http://tcatche.site/categories/js/"}],"tags":[]},{"title":"React - Stateless Function Component","slug":"react-stateless-components","date":"2017-05-23T08:14:00.000Z","updated":"2018-11-11T08:36:30.000Z","comments":true,"path":"2017/05/react-stateless-components/","link":"","permalink":"http://tcatche.site/2017/05/react-stateless-components/","excerpt":"","text":"Stateless Function Component（SFC， 无状态组件） 是 React v0.14.0 引入的一种新的创建组件的方式，这个方式大大提升了“纯组件”的编写速度和便捷性，而且还能有效提升组价的性能。 常规的组件通常情况下，我们是使用 React.createClass() 或者 class MyComponent extends React.Component 创建组件，但是很多时候，我们需要的组件仅仅是一个简单的渲染数据的模板，这种情况下，这种方式创建的组件无疑十分的繁琐，可以看一个例子： class Widget extends React.Component &#123; static propTypes = &#123; onClick: React.PropTypes.func.isRequired, children: React.PropTypes.element.isRequired &#125; _handleClick = (e) =&gt; &#123; //do sth this.props.onClick(e); &#125; render() &#123; returen ( &lt;div onClick=&#123;this._handleClick&#125;&gt; &#123;this.props.children&#125; &lt;/div&gt; ); &#125;&#125; 可以看到，这个组件没有任何的内部状态 state ，也没有任何的生命周期相关的操作，只接受一些参数，并根据参数渲染结果，任意相同的输入，必定会获得相同的输出结果，也不太需要关心其生命周期。 对于这种无状态的组件，完全可以使用 SFC 的方式创建。 Stateless Function Component先来看下使用这种方式改写的代码： const _handleClick = (event, onClick) =&gt; &#123; //do sth this.props.onClick(event);&#125;const Widget = (props, context) =&gt; &lt;div onClick=&#123;e =&gt; _handleClick(e, props.onClick)&#125;&gt;&#123;props.children&#125;&lt;/div&gt;;Widget.propTypes = &#123; onClick: React.PropTypes.func.isRequired, children: React.PropTypes.element.isRequired&#125; 不仅降低了代码的数量，而且提升了代码的可读性。 无状态组件实际上就是一个函数，函数接受两个参数，第一个是 props 第二个是 context ，返回一个 render 的内容。而且在渲染的时候由于是无状态的，可以省略将组件类实例化的过程，性能会更好。 This pattern is designed to encourage the creation of these simple components that should comprise large portions of your apps. In the future, we’ll also be able to make performance optimizations specific to these components by avoiding unnecessary checks and memory allocations. React 官方也建议采用这种模式创建简单的组件，对于有状态的组件，可以使用有状态的组件处理数据，把它们的 state 传递给无状态的组件进行内容的渲染: class Container extends Component &#123; state = &#123; text: &quot;init text&quot; &#125; _handleClick() &#123; this.setState(&#123;text: &quot;click text&quot;&#125;) &#125; render() &#123; return ( &lt;Widget onClick=&#123;this._handleClick&#125;&gt;&#123;this.state.text&#125;&lt;/Widget&gt; ); &#125;&#125; 注意：由于 SFC 没有实例化的过程，因此不能使用 this 指针，也不能使用 ref 指针。 SFC 与函数SFC 本质上是一个函数，所以定义的 SFC 大部分情况下即可以当做组件用，也可以当作函数使用。 如下面这个乍一看没有什么意义的组件，用来给元素包括一层 div： const DivWrapper = (&#123; className, children &#125;) =&gt; &lt;div className=&#123;className&#125;&gt;&#123; children &#125;&lt;/div&gt;; 在使用的时候我们可以直接当做 SFC 组件使用，也可以直接当做函数调用： &lt;DivWrapper className=&quot;wrapper&quot;&gt;It used as SFC&lt;/DivWrapper&gt;// 等价于// const createDivWrapper 是为了使函数命名更规范，没有其他实际意义const createDivWrapper = DivWrapper;createDivWrapper(&#123;className: &#x27;wrapper&#x27;, children: &#x27;It used as function call&#x27; &#125;); 在上面这个示例中 实际是没有什么区别的，但是当我们的父元素使用 cloneElement 动态给其子元素注入属性的时候，会有很大区别，看下面这个例子： const &#123; Component, Children, cloneElement &#125; = React;// 这个无聊的组件为每个自己的子元素绑定了一个额外的 click 事件class Parent extends Component &#123; render() &#123; return ( &lt;div&gt; &#123; Children.map( this.props.children, (child, index) =&gt; cloneElement(child, &#123;...child.props, onClick: () =&gt; console.log(child.props.children)&#125;) ) &#125; &lt;/div&gt; ); &#125;&#125;// 使用&lt;Parent&gt; &lt;DivWrapper className=&quot;wrapper&quot;&gt;It used as SFC&lt;/DivWrapper&gt; &#123; createDivWrapper(&#123;className: &#x27;wrapper&#x27;, children: &#x27;It used as function call&#x27; &#125;) &#125;&lt;/Parent&gt;// 尝试分别点击 “It used as SFC” 和 “It used as function call”// 点击 “It used as SFC” 不触发事件// 点击 “It used as function call” 控制台打印日志 “It used as function call” 上面我们创建了一个组件，组件动态为自己的每个子元素注入一个新的点击事件，然后我们点击它的子元素发现，当作为 SFC 调用时并没有相应额外传递进来的 onClick 事件，而作为函数调用却能够触发事件。 首先我们来这两种使用方式的区别：使用了 SFC ，Parent 的子元素是 Parent 组件，而是用了函数调用，Parent 的子元素是 div 元素。所以，当我们的 SFC 并没有提供对额外的属性响应处理时候，这个传递来的属性会丢失。 我们来个一个实际的例子，当我们在使用一些外部类库的时候，如rc-collapse，如果面板非常复杂，有时候会写出这样的代码： // 创建一个复杂的titleconst createComplexTitle = (props) =&gt; &lt;ComplexTitle &#123; ...props &#125;/&gt;;// 创建一个复杂的titleconst createComplexContent = (props) =&gt; &lt;ComplexContent &#123; ...props &#125;/&gt;;const PanelWrapper = (&#123; data &#125;) =&gt; &#123; // 进行数据处理判断 return ( &lt;Collapse.Panel header=&#123;createComplexTitle(data)&#125;&gt; &#123;createComplexContent(data)&#125; &lt;/Collapse.Panel&gt; )&#125;const createPanel = PanelWrapper;const collapse1 = array =&gt; ( &lt;Collapse&gt; &#123; array.map(item =&gt; &lt;PanelWrapper data=&#123;item&#125;/&gt;) &#125; &lt;/Collapse&gt;);const collapse2 = array =&gt; ( &lt;Collapse&gt; &#123; array.map(item =&gt; createPanel(item)) &#125; &lt;/Collapse&gt;); 如上例子，这个面板非常复杂，我们需要将其封装出来处理，这样就会有以上 collapse1 和 collapse2 写法，而 collapse1 写法会丢失一些来自 Collapse 父组件传递的 props，除非我们添加了额外的处理： // 可行但不推荐const PanelCreater = (&#123; data, ...props &#125;) =&gt; &#123; // 进行数据处理判断 return ( &lt;Panel header=&#123;createComplexTitle(data)&#125;, &#123; ...props &#125;&gt; &#123;createComplexContent(data)&#125; &lt;/Panel&gt; )&#125;; 改成这样后虽然能够处理额外的属性，但是会导致对组件的行为不可控制，我们不知道我们写出来的组件会最终变成什么样子，违背了组件设计的初衷，所以还是建议使用第二种写法。 大部分这样的组件都会对其子元素的类型进行要求，比如 react-router，它的 &lt;Switch&gt; 组件要求子元素必须为 &lt;Route&gt; 或 &lt;Redirect&gt;，因为它就是使用 cloneElement 把 location 等属性写给路由对应的组件，如果我们在自己写这样类库的时候，也可以对 children 类型进行检查和限制，并能够对于不满足条件的子元素进行警告。 比如，我们来对 &lt;Collapse&gt; 组件的子元素进行限制: import PropTypes from &#x27;prop-types&#x27;;Collapse.propTypes = &#123; // ... other props children: PropTypes.arrayOf(PropTypes.instanceOf(Collapse.Panel))&#125; 参考 Stateless React components 无状态组件(Stateless Component) 与高阶组件","categories":[{"name":"js","slug":"js","permalink":"http://tcatche.site/categories/js/"}],"tags":[{"name":"react","slug":"react","permalink":"http://tcatche.site/tags/react/"}]},{"title":"React - Context","slug":"react-context","date":"2017-05-19T09:08:00.000Z","updated":"2020-07-22T02:19:40.095Z","comments":true,"path":"2017/05/react-context/","link":"","permalink":"http://tcatche.site/2017/05/react-context/","excerpt":"","text":"注意，本文仅适用于 React16 以下的版本 Context 是一个实验性的 Api，和 props 一样用于组件之间的数据传递，但是这个功能却很少使用，甚至不为人知。 为何使用 Context在使用 React 开发的时候，通常通过改变 state 和 传递 props 对组件进行控制，特别是通过 props 在组件间的数据流传输，可以很容易的推断组件的状态。首先看一下常用的组件间 props 传递的例子： const ParentComponent = () =&gt; &#123; const colorTheme = &quot;green&quot;; return ( &lt;MiddleChildComponent color=&#123;colorTheme&#125; /&gt; )&#125;const MiddleChildComponent = (&#123;color, ...props&#125;) =&gt; &#123; // doSth(props) return (&lt;LeafChildComponent color=&#123;color&#125; /&gt;);&#125;const LeafChildComponent = (&#123;color&#125;) =&gt; &#123; // doSth(props) return &lt;div style=&#123; &#123;background: color&#125; &#125;&gt;LeafChildComponent&lt;/div&gt;;&#125; 这个例子是 React 经典的单向数据传递的结构，数据的流向是： ParentComponent --(props)--&gt; MiddleChildComponent --(props)--&gt; LeafChildComponent React 的这个结构也使得代码非常容易进行调试和维护，当代码出现问题的时候，只需要沿着这条路径进行追踪即可。 但是，当应用变大的时候，这个中间层次可能会变多，这样当传递某个特殊的 prop 的时候，需要穿越非常多的中间组件层级，而这些中间的组件并不会用到，设置根本不知道这个 prop 的存在，这样写起来无疑非常的繁琐，在这种情况下，可以考虑使用 Context Api ，使用 Context 可以不必再中间组件传递 props ，而能让后代获取到数据： 使用 Context使用 Context 需要增加以下属性和方法： 在父组件中定义方法 getChildContext ，方法返回子组件接收的 conext 对象。 在父组件中定义属性 childContextType ， 该属性指定了 getChildContext 方法返回的对象的数据类型 。 在想要获取 context 的子组件定义属性 contextTypes 即可获取 context ，如果未定义该属性，则 context 是一个空对象。 在子组件使用 this.context 获取 Context ，如果是无状态的 SFC 组件，则第二个参数传入 Context。 使用 Context 重新改写上面的例子： class ParentComponent extends React.Component &#123; static childContextTypes = &#123; color: React.PropTypes.string &#125; // 定义 context getChildContext() &#123; return &#123; color: &#x27;green&#x27; &#125; &#125; render() &#123; return ( &lt;MiddleChildComponent/&gt; ) &#125;&#125;// 未指定 contextTypes ，context 为空const MiddleChildComponent = (props, context) =&gt; &#123; console.log(&quot;MiddleChildComponent context is: &quot;); console.log(context); return (&lt;LeafChildComponent /&gt;);&#125;const LeafChildComponent = (props, context) =&gt; &#123; console.log(&quot;LeafChildComponent context is: &quot;); console.log(context); return &lt;div style=&#123; &#123;background: context.color&#125; &#125;&gt;LeafChildComponent&lt;/div&gt;;&#125;// 为要获取 context 的组件指定属性 contextTypesLeafChildComponent.contextTypes = &#123; color: React.PropTypes.string&#125;ReactDOM.render( &lt;ParentComponent /&gt;, document.getElementById(&#x27;app&#x27;))// MiddleChildComponent context is:// Object &#123;&#125;// LeafChildComponent context is:// Object &#123;color: &quot;green&quot;&#125; 当 props 或者 state 改变的时候，父组件就会调用 getChildContext 方法更新 context。 组件的生命周期函数如果为一个组件定义了 contentTypes 属性获取父组件的 contentTypes， 则以下几个生命周期函数会被传入一个额外的参数，即 context 对象： constructor(props, context) componentWillReceiveProps(nextProps, nextContext) shouldComponentUpdate(nextProps, nextState, nextContext) componentWillUpdate(nextProps, nextState, nextContext) componentDidUpdate(prevProps, prevState, prevContext) Context 的缺陷事实上，绝大多数的应用都用不到 context ，使用 context 有以下问题： 这是一个实验性的 api这是一个实验性的 api 这就意味着这个 api 未来可能发生变动，甚至会被删除，将进一步影响到使用这个 api 的应用和组件，因此最好避免使用它。 和特定的父组件耦合如果一个组件使用了 context ， 这就意味着这个组合使用的时候就必须和一个能提供所需 context 的父组件耦合在一起，这样就限制了组件的应用范围，组件很难被复用。 context 更新被阻断当父组件的 state 或者 pros 变化的时候，父组件的 getChildContext 会被调用更新 context，同时父组件会更新其自身和并引发其子组件的更新，而子组件接收到的 context 也会被改变，这一点到不会引起问题，在某些情况下子组件可以依赖于 context 更新自身。 但是当中间组件使用了 shouldComponentUpdate 禁止更新，这样则子组件不会被更新，子组件则不会被渲染，此时父组件更新的值无法被应用，看下面代码： 父组件 ParentComponent 加载完成后修改 state 和 context： class ParentComponent extends React.Component &#123; static childContextTypes = &#123; color: React.PropTypes.string &#125; state = &#123; color: &#x27;green&#x27; &#125; getChildContext() &#123; return &#123; color: this.state.color &#125; &#125; componentDidMount() &#123; this.setState(&#123;color: &#x27;red&#x27;&#125;); &#125; render() &#123; return ( &lt;MiddleChildComponent/&gt; ) &#125;&#125;class MiddleChildComponent extends React.Component &#123; render() &#123; return ( &lt;LeafChildComponent /&gt; ) &#125;&#125;const LeafChildComponent = (props, context) =&gt; &#123; console.log(&quot;LeafChildComponent context is: &quot;); console.log(context); return &lt;div style=&#123; &#123;background: context.color&#125; &#125;&gt;LeafChildComponent&lt;/div&gt;;&#125;// 为要获取 context 的组件指定属性 contextTypesLeafChildComponent.contextTypes = &#123; color: React.PropTypes.string&#125;ReactDOM.render( &lt;ParentComponent /&gt;, document.getElementById(&#x27;app&#x27;))// LeafChildComponent context is:// Object &#123;color: &quot;green&quot;&#125;// LeafChildComponent context is:// Object &#123;color: &quot;red&quot;&#125; 从上面的 log 可以看到 context 是正确更新的，这次设置中间组件禁止更新： class MiddleChildComponent extends React.Component &#123; shouldComponentUpdate() &#123; return false; &#125; render() &#123; return ( &lt;LeafChildComponent /&gt; ) &#125;&#125;// LeafChildComponent context is:// Object &#123;color: &quot;green&quot;&#125; 从执行结果可以看到，第二次的 context 更新被中间组件阻断，依赖 context 进行组件的更新是有风险的。 难以维护当维护别人的组件的时候，如果一些组件使用了 context 这样就非常的困难了，需要从大量的组件中找到要使用的组件，当项目比较大的时候无疑是非常困难的。而如果采用了 props 就可以沿着调用的方向向上找，很容易就找到定义的位置。 应用场景Dan Abramov 设计了一些明智的规则关于使用 context： function shouldIUseReactContextFeature() &#123; // 类库作者 或者 向下传递很深的层级 if (amIALibraryAuthor() &amp;&amp; doINeedToPassSomethingDownDeeply()) &#123; // 很乐意处理 api 修改和 bug // A custom &lt;Option&gt; component might want to talk to its &lt;Select&gt;. // This is OK but note that context is experimental API and doesn&#x27;t update // correctly in some cases so you might want to roll your own subscriptions. return amIFineWith(API_CHANGES &amp;&amp; BUGGY_UPDATES); &#125; // 主题 或 本地化场景 if (myUseCase === &#x27;theming&#x27; || myUseCase === &#x27;localization&#x27;) &#123; // Context 可以用以存放全局变量或者很少改变的内容 // 如果坚持使用的话可以用在 HOC 组件中，而不是直接使用 this.context ，这样当接口改变 // 的时候可以很容易的只修改一个地方 // In apps, context can be used for &quot;global&quot; variables that rarely change. // If you insist on using it, provide a higher order component. // This way when we change the API, you will only need to update one place. return iPromiseToWriteHOCInsteadOfUsingItDirectly(); &#125; if (libraryAsksMeToUseContext()) &#123; // Ask them to provide a higher order component! throw new Error(&#x27;File an issue with this library.&#x27;); &#125; // Good luck. return yolo();&#125; 上面基本已经说明了应用场景：类库作者、全局级别的信息（主题、语言、环境、用户信息等），并且在使用的时候要考虑 api 在后面版本发生修改等问题，当然也有使用 context 非常出色的类库： react-router、 react-redux。 本文最后自定义一个路由管理组件 Router 作为练习。Router 组件包含两个子组件 Router和Route 。Router 组建包括整个应用，Route` 用于匹配路径到组件。 首先定义 Router ，它提供了 Route 组件需要的几个操作， import &#123; Component, PropTypes &#125; from &#x27;react&#x27;;class Router extends Component &#123; getChildContext() &#123; const register(url) &#123; console.log(&#x27;registered route!&#x27;, url) &#125; const location = location.href; return &#123; router: &#123; register, location &#125; &#125; &#125; render() &#123; return &lt;div&gt;&#123;this.props.children&#125;&lt;/div&gt; &#125;&#125;Router.childContextTypes = &#123; router: PropTypes.object.isRequired,&#125; 然后 Route 组件需要使用 context 中 router： class Route extends Component &#123; componentWillMount() &#123; this.context.router.register(this.props.path) &#125; match() &#123; return this.context.router.location === this.props.path; &#125; render() &#123; console.log(`I am the route for $&#123;this.props.path&#125;`) return &lt;div&gt;&#123;this.match()? this.props.children: null&#125;&lt;/p&gt; &#125;&#125;Route.contextTypes = &#123; router: PropTypes.object.isRequired,&#125; 这样就可以在 app 入口开始使用 Router 组件： const App = () =&gt; ( &lt;div&gt; &lt;Router&gt; &lt;div&gt; &lt;Route path=&quot;/foo&quot; /&gt; &lt;Route path=&quot;/bar&quot; /&gt; &lt;div&gt; &lt;Route path=&quot;/baz&quot; /&gt; &lt;/div&gt; &lt;/div&gt; &lt;/Router&gt; &lt;/div&gt;) 使用这种方式的优点在于，只要保证 Route 组件被嵌套在 Router 组件之内，Route 可以放在任意的位置，任意嵌套，都能正常使用。 参考 React-Docs Context in ReactJS Applications","categories":[{"name":"js","slug":"js","permalink":"http://tcatche.site/categories/js/"}],"tags":[{"name":"react","slug":"react","permalink":"http://tcatche.site/tags/react/"}]},{"title":"ES6 - 装饰器：Decorator","slug":"decorator","date":"2017-05-18T06:33:00.000Z","updated":"2018-08-01T10:41:24.000Z","comments":true,"path":"2017/05/decorator/","link":"","permalink":"http://tcatche.site/2017/05/decorator/","excerpt":"","text":"装饰器是 ES7 的一个新提案，本质上是 Object.defineProperty(obj, prop, descriptor) 的语法糖，用于动态的修改类的行为，相比较集成的方式而言，这种方式无疑更加的灵活。 装饰器的使用装饰器用于类和类的成员上，但是不能用于函数，因为存在着函数提升。 作用于类的装饰器装饰器作用于类上的时候，它的第一个参数 target 则是被装饰的类的本身，签名如下： function(target) const sayHello = target =&gt; &#123; target.sayHello = () =&gt; console.log(&quot;hello&quot;);&#125;@sayHelloclass Person &#123;&#125;;Person.sayHello(); // hello 作用于类成员的装饰器当装饰器作用于类的属性的时候接收3个参数：要装饰的目标对象的原型、要装饰的属性名和该属性的描述对象，签名如下： function(target, name, descriptor) 其参数与 Object.defineProperty 一致，如下定义了一个 readonly 的装饰器： // 把 descriptor 的 writable 字段设为 falsefunction readonly(target, key, descriptor) &#123; descriptor.writable = false return descriptor&#125;class Person &#123; @readonly name = &quot;person&quot;&#125;let p = new Person();p.name = &quot;person2&quot;// Uncaught TypeError: Cannot assign to read only property &#x27;name&#x27; of object &#x27;#&lt;Person&gt;&#x27; 装饰器增强如果装饰器需要接受参数，可以对其进行一层包装，在装饰的时候为其传入参数： const sayHello = hello =&gt; target =&gt; &#123; target.sayHello = () =&gt; console.log(hello);&#125;@sayHello(&#x27;hi&#x27;)class Person &#123;&#125;;Person.sayHello(); // hi 也可以同时应用多个装饰器： const before = target =&gt; &#123; console.log(&quot;before&quot;);&#125;const sayHello = hello =&gt; target =&gt; &#123; target.sayHello = () =&gt; console.log(hello);&#125;@before@sayHelloclass Person &#123; name = &quot;person&quot;&#125;;Person.sayHello();// before// hello 装饰器的原理对于类而言，装饰器的行为实际上是把类作为参数执行装饰器函数，这里可以看一下的转换： // 转换前@F(&quot;color&quot;)@Gclass Foo &#123;&#125;// 转换后var Foo = (function () &#123; class Foo &#123; &#125; Foo = F(&quot;color&quot;)(Foo = G(Foo) || Foo) || Foo; return Foo;&#125;)(); 对于类的成员方法或者属性，装饰器的行为则是修改目标的 descriptor ，并返回一个新的 descriptor 然后把这个新的 descriptor 应用到目标方法或者属性上： // 转换前class Foo &#123; @F(&quot;color&quot;) @G bar() &#123; &#125;&#125;// 转换后var Foo = (function () &#123; class Foo &#123; bar() &#123; &#125; &#125; var _temp; _temp = F(&quot;color&quot;)(Foo.prototype, &quot;bar&quot;, _temp = G(Foo.prototype, &quot;bar&quot;, _temp = Object.getOwnPropertyDescriptor(Foo.prototype, &quot;bar&quot;)) || _temp) || _temp; if (_temp) Object.defineProperty(Foo.prototype, &quot;bar&quot;, _temp); return Foo;&#125;)(); 装饰器练习下面根据装饰器的特性，写几个常用的装饰器作为练习： MixinMixin 是对象集成的一种替代，在一个对象中混入另一个对象的方法： const mixins = (...objs) =&gt; &#123; return function (target) &#123; Object.assign(target.prototype, ...objs); &#125;;&#125;class Obj &#123; test() &#123; console.log(&quot;call test&quot;) &#125;&#125;objA = &#123; print() &#123; console.log(&quot;call print&quot;) &#125;&#125;objB = &#123; log() &#123; console.log(&quot;call log&quot;) &#125;&#125;@mixins(objA, objB)class Test extends Obj &#123;&#125;new Test().print()new Test().log()new Test().log()// call test // call print// call log 标记一个接口 deprecated在开发的时候经常会接口更新，有些接口为了保持兼容而保留，但是希望这个接口再被调用的时候能够发出警告信息，提醒升级，实现如下： const deprecated = (warnText=`The interface is deprecated`) =&gt; (target, key, descriptor) =&gt; &#123; if (typeof descriptor.value !== &#x27;function&#x27;) &#123; throw new Error(&#x27;The @deprecated decorator can only be used on function.&#x27;); &#125; return &#123; ...descriptor, value: function() &#123; console.warn(warnText); return descriptor.value.apply(this, arguments); &#125; &#125;&#125;class Test &#123; @deprecated() calculate() &#123; return; &#125;&#125;new Test().calculate()// The interface is deprecated 统计方法执行时间对于复杂的操作可能会需要记录操作执行的时间： const runtime = (target, key, descriptor) =&gt; &#123; if (typeof descriptor.value !== &#x27;function&#x27;) &#123; throw new Error(&#x27;The @runtime decorator can only be used on function.&#x27;); &#125; label = `The function $&#123;key&#125; running used` return &#123; ...descriptor, value: function() &#123; console.time(label); let result = descriptor.value.apply(this, arguments); console.timeEnd(label); return result; &#125; &#125;&#125;class Test &#123; @runtime calculate() &#123; for(var i = 0; i &lt; 10000000; i ++) &#123;&#125; &#125;&#125;new Test().calculate()// The function calculate running used: 8.162841796875ms 参考Decorators in ES7ECMAScript 6 入门wycats/javascript-decorators","categories":[{"name":"js","slug":"js","permalink":"http://tcatche.site/categories/js/"}],"tags":[{"name":"es","slug":"es","permalink":"http://tcatche.site/tags/es/"},{"name":"Decorator","slug":"Decorator","permalink":"http://tcatche.site/tags/Decorator/"}]},{"title":"CSS 变量","slug":"css-variables","date":"2017-05-16T08:54:00.000Z","updated":"2021-08-09T06:40:41.595Z","comments":true,"path":"2017/05/css-variables/","link":"","permalink":"http://tcatche.site/2017/05/css-variables/","excerpt":"","text":"在任何一门语言中，变量的存在都是必不可少的，使用变量可以很方便的复用很多信息，比如网页的配色方案，使用方案只需要修改几个变量值即可完成对整个页面的配色的修改。而且变量本身包含了语义信息，更容易理解，比如 main-text-color 相对 #333 更容易理解。以前只能通过预处理器 Sass 、Less 等使用变量，而现在原生 css 终于也添加了变量的引入。 首先看一下 css 变量的兼容性： 从兼容性表格可以看出，css 变量的兼容性已经非常好了，主流浏览器 Chrome 、Safari 、Firefox 的支持度都挺高的。接下来开始使用： 变量声明和使用变量的声明使用两个连词线 -- ，而变量的使用则使用 var() 函数： :root &#123; --color-main-text: #333; --color-bg: #f6f6f6;&#125;body &#123; color: var(--color-main-text); background: var(--color-bg);&#125; 变量只能用作属性值，不能 用作属性名： :root &#123; --pdt: padding-top;&#125;.content &#123; var(--side): 10px; /* 不生效 */&#125; var() 函数的第二个参数表示变量的默认值，如果变量不存在就会使用这个默认值： body &#123; color: var(--color-main-text, #333); background: var(--color-bg); margin: var(--body-margin, 10px 30px); font-family: var(--font-family, &#x27;Microsoft YaHei&#x27;, tahoma, arial, &quot;Hiragino Sans GB&quot;, simsun, sans-serif);&#125; 注意，第二个参数内容的空格和逗号也不再做处理，上例子中 margin 和 font 的默认值分别为后面的带空格的上下、左右边距值和带逗号的一长串字体名。 上面提到变量不存在才使用默认值，但是当变量不合法的时候则使用属性的缺省值： body &#123; --color: 10px; color: red; color: var(--color, blue); /* color为默认的黑色 */&#125; 此时，颜色不是 --color 的值不是合法的颜色值，而最终结果也不是默认参数值 blue 而是此属性的默认值黑色。 变量拼接当变量类型是字符串的话，可以直接和字符串拼接： body &#123; --hello: &#x27;hello&#x27;; --hw: var(--hello)&#x27; world&#x27;; /* hello world */&#125; 变量的类型为数值，则不能直接和单位一起拼接，必须使用 calc() 函数： body &#123; --gap: 20; margin-top: var(--gap)px; /* 无效 */ margin-bottom: calc(var(--gap) * 1px); /* 有效 */&#125; 当然也可以直接定义变量的属性值包含单位，但是如果带有单位就不能写成字符串形式： body &#123; --gap: 20px; margin-top: var(--gap); /* 有效 */ --gap2: &#x27;20px&#x27;; margin-top: var(--gap2)px; /* 无效 */&#125; 作用域css 变量实际上是 css 自定义属性（custom properties），从这一点出发就很容易理解 css 变量的作用域了，也就是说 css 的作用于实际上是依托于 css 的级联规则： :root &#123; --color: blue;&#125;div &#123; --color: green;&#125;#alert &#123; --color: red;&#125;* &#123; color: var(--color);&#125; &lt;p&gt;blue&lt;/p&gt;&lt;div&gt;green&lt;/div&gt;&lt;div id=&#x27;alert&#x27;&gt; red &lt;p&gt;red too, because of inheritance!&lt;/p&gt;&lt;/div&gt; 不同元素读取的颜色值和其对应规则的优先级有关，因此文字呈现的颜色不一样。 媒体查询对于页面动态变化的情况，可以在 @media 命令中声明变量，比如根据屏幕的宽度不同为元素设置不同的宽度： body &#123; --width: 980px&#125;@media screen and (max-width: 1200px) &#123; body &#123; --width: 80%; &#125;&#125; 兼容检查属性兼容性判断，可以使用 css 的 @support 检查： /* support */@supports ( (--a: 0)) &#123;&#125;/* not support */@supports ( not (--a: 0)) &#123;&#125; 也可以使用js： const isSupportCssProperty = window.CSS &amp;&amp; window.CSS.supports &amp;&amp; window.CSS.supports(&#x27;--a&#x27;, 0); JavaScript操作使用js修改属性的基本语法如下： // 设置变量document.body.style.setProperty(&#x27;--primary&#x27;, &#x27;green&#x27;);// 读取变量document.body.style.getPropertyValue(&#x27;--primary&#x27;); // &#x27;green&#x27;// 删除变量document.body.style.removeProperty(&#x27;--primary&#x27;); 在一些动态改变位置的场合会很有用，比如随着滚动条滚动始终保持当前位置 总结和 less 、 sass 相比，语法较为繁琐，但是仔细看看还是有一些特点的，比如变量根据级联的优先级、媒体查询的动态赋值特性，在某些特定的应用场景下或许会更有用。 参考CSS Custom Properties for Cascading Variables Module Level 1","categories":[{"name":"css","slug":"css","permalink":"http://tcatche.site/categories/css/"}],"tags":[]},{"title":"ES6 - Symbol 类型","slug":"symbol-base-type","date":"2017-04-27T03:09:00.000Z","updated":"2018-08-01T10:41:24.000Z","comments":true,"path":"2017/04/symbol-base-type/","link":"","permalink":"http://tcatche.site/2017/04/symbol-base-type/","excerpt":"","text":"概述Symbol 类型是一种特殊的、不可变的数据类型，主要用于解决名称冲突的问题，是 es6 引入的第七种原始数据类型，其他六种分别是：null 、 undefined 、 boolean 、 string 、 number 、 object 。 创建 Symbol Symbol([description])创建一个全新的 Symbol ，description 是对 Symbol 实例的描述，先来看几个示例： var s0 = Symbol();var s1 = Symbol(&quot;desc&quot;);var s2 = Symbol(&quot;desc&quot;);console.log(s0) // Symbol()console.log(s1) // Symbol(desc)typeof s1; // &quot;symbol&quot;s1 === s2 // false 从上述示例可以看出，即使传递给 Symbol 同样的 “描述” ，得到的 Symbol 也都是独立的。 Symbol.for在某些场合下可能希望复用之前所创建的 Symbol，使用 Symbol.for 创建的 Symbol 可以做到这一点： Symbol.for([key]) 用 Symbol.for() 方法创建的的 symbol 会被放入一个全局 symbol 注册表中, Symbol.for(key) 方法并不是每次都会创建一个新的 symbol ，它会首先检查给定的 key 是否已经在注册表中了。假如是，则会直接返回上次存储的那个，否则，新建一个与该 key 关联的 symbol ，并放入全局 symbol 注册表中。 var s1 = Symbol.for(&quot;foo&quot;); // 创建一个 symbol 并放入 symbol 注册表中， key 为 &quot;foo&quot;var s2 = Symbol.for(&quot;foo&quot;); // 从 symbol 注册表中读取 key 为&quot;foo&quot;的 symbols1 === s2 // true Symbol.keyFor Symbol.keyFor(symbol); 该方法用于从 symbol 注册表中获取与某个 symbol 关联的键： // 创建一个 symbol 并放入 Symbol 注册表，key 为 &quot;foo&quot;var globalSym = Symbol.for(&quot;foo&quot;); Symbol.keyFor(globalSym); // &quot;foo&quot;// 创建一个 symbol，但不放入 symbol 注册表中var localSym = Symbol(); Symbol.keyFor(localSym); // undefined，所以是找不到 key 的// well-known symbol 们并不在 symbol 注册表中Symbol.keyFor(Symbol.iterator) // undefined Symbol 属性名遍历使用 Symbol 作为对象的属性名是，无论使用 for...in 、for...of 循环或者 Object.keys() 、Object.getOwnPropertyNames() 方法均不会被遍历到，当然有一个Object.getOwnPropertySymbols 方法，可以获取指定对象的所有 Symbol 属性名： var obj = &#123;&#125;;obj.a = &#x27;a&#x27;;obj[Symbol(&#x27;b&#x27;)] = &#x27;b&#x27;;for (var i in obj) &#123; console.log(i);&#125;// afor (var v in obj) &#123; console.log(v);&#125;// aconsole.log(Object.keys(obj)); // [&quot;a&quot;]console.log(Object.getOwnPropertyNames(obj)); // [&quot;a&quot;]console.log(Object.getOwnPropertySymbols(obj)); // [Symbol(b)] 在上面代码中，Object.getOwnPropertySymbols 可以获取 Symbol 键名，但是无法获取到非 Symbol 键名，如果在需要遍历所有键名的场合可以尝试 Reflect.ownKeys : var obj = &#123;&#125;;obj.a = &#x27;a&#x27;;obj[Symbol(&#x27;b&#x27;)] = &#x27;b&#x27;;console.log(Reflect.ownKeys(obj)); // [&quot;a&quot;, Symbol(b)] Symbol 的内置属性除了可以定义自己使用的 Symbol 以外，JavaScript 还内建了一些在 ES5 之前没有暴露给开发者的符号，指向内部语言行为。这些符号可以使用以下属性访问： Symbol.hasInstance对象的 Symbol.hasInstance 属性指向一个函数，该函数用于判断某对象是否为某构造器的实例，即当调用 instanceof 运算符的时候实际上是调用对象的 Symbol.hasInstance 的属性对应的函数： class MyArray &#123; static (instance) &#123; return Array.isArray(instance); &#125;&#125;console.log([] instanceof MyArray); // true// 等价于：console.log(MyArray[Symbol.hasInstance]([])); // true Symbol.isConcatSpreadable对象的 Symbol.isConcatSpreadable 属性指向一个布尔值，该函数用于配置某对象作为 Array.prototype.concat() 方法的参数时是否展开其数组元素。 首先对于数组而言，Symbol.isConcatSpreadable 属性默认为 true ， 可以展开： var a = [1, 2, 3];var b = [4, 5];console.log(a.concat(b)); // [1, 2, 3, 4, 5] 设置 数组 b 的 Symbol.isConcatSpreadable 值为 false ： var a = [1, 2, 3];var b = [4, 5];b[Symbol.isConcatSpreadable] = false;console.log(a.concat(b)); // [1, 2, 3, [4, 5]] 类似数组的对象也可以展开，但它的 Symbol.isConcatSpreadable 属性默认为 false ： var a = [1, 2, 3];var b = &#123; length: 2, 0: 4, 1: 5 &#125;;console.log(a.concat(b)); // [1, 2, 3, Object]b[Symbol.isConcatSpreadable] = true;console.log(a.concat(b)); // [1, 2, 3, 4, 5] Symbol.iterator对象的 Symbol.iterator 属性为对象定义了默认的迭代器。该迭代器可以被 for...of 循环结构使用。 var myIterable = &#123;&#125;myIterable[Symbol.iterator] = function* () &#123; yield 1; yield 2; yield 3;&#125;;[...myIterable] // [1, 2, 3] Symbol.match、Symbol.search、Symbol.replace 、 Symbol.split这四个属性代表的行为类似，这里以 Symbol.match 属性为例说明： 对象的 Symbol.match 属性，指向一个函数。当执行 String.prototype.match() 时，如果该属性存在，会调用它。也就是说 str.match(obj) 等价于调用 obj[Symbol.match](str) ： var a = &#123;&#125;;&quot;Hello, world!&quot;.match(a); // nullvar b = &#123; value: &#x27;world&#x27;, [Symbol.match](string) &#123; return string.match(this.value); &#125;&#125;&quot;Hello, world!&quot;.match(b); // [&quot;world&quot;, index: 7, input: &quot;Hello, world!&quot;] 同样的，执行 str.search(obj) 、 str.replace(obj, replaceStr) 、 str.split(obj, limit) 等价于执行 obj[Symbol.search](str) 、 obj[Symbol.replace](str, replaceStr) 、 obj[Symbol.split](str, limit) ： var a = &#123; value: &#x27;world&#x27;, [Symbol.search](string) &#123; return string.indexOf(this.value); &#125;, [Symbol.replace](string, replaceStr) &#123; return string.replace(this.value, replaceStr); &#125;, [Symbol.split](string, limit) &#123; return string.split(this.value, limit); &#125;&#125;&quot;Hello, world!&quot;.search(a); // 7&quot;Hello, world!&quot;.replace(a, &#x27;Beijing&#x27;); // &quot;Hello, Beijing!&quot;&quot;Hello, world!&quot;.split(a); // [&quot;Hello, &quot;, &quot;!&quot;] Symbol.species对象的 Symbol.species 属性，指向一个构造函数。创建实例的时候，会使用这个方法的返回值作为构造函数，来创建新的对象 class MyArray1 extends Array &#123;&#125;var a1 = new MyArray1(1,2,3);var mapped1 = a1.map(x =&gt; x * x);console.log(mapped1 instanceof MyArray1); // trueconsole.log(mapped1 instanceof Array); // trueclass MyArray2 extends Array &#123; // 覆盖 species 到父级的 Array 构造函数上 static get [Symbol.species]() &#123; return Array; &#125;&#125;var a2 = new MyArray2(1,2,3);var mapped2 = a2.map(x =&gt; x * x);console.log(mapped2 instanceof MyArray2); // falseconsole.log(mapped2 instanceof Array); // true 在ES5 中 Array.prototype.map 等函数实现类似如下： Array.prototype.map = function (callback) &#123; var returnValue = new Array(this.length); this.forEach(function (item, index, array) &#123; returnValue[index] = callback(item, index, array); &#125;); return returnValue;&#125; 在ES6 中，Array.prototype.map 等函数实现奖创建对象升级为使用 Symbol.species 属性，其实现类似如下： Array.prototype.map = function (callback) &#123; var Species = this.constructor[Symbol.species]; var returnValue = new Species(this.length); this.forEach(function (item, index, array) &#123; returnValue[index] = callback(item, index, array); &#125;); return returnValue;&#125; 这种修改可以保证在自定义的数组的子类上执行这些函数，可以让返回的结果的类型能够回归到 Array 类型，否则，直接执行这些函数返回的类型是 MyArray 子类型。数组的 slice ，filter ，splice ，concat 方法都是这样。 Symbol.toPrimitive对象的 Symbol.toPrimitive 属性，指向一个函数。当此对象被转为原始类型的值时，会调用这个方法。 比如，当执行 +object 的时候，实际上会调用 object[Symbol.toPrimitive](&#39;number&#39;) ，当执行 &#39;&#39;+object ，实际上会调用 object[Symbol.toPrimitive](&#39;string&#39;) ， 执行 if(object) 实际上会调用 object[Symbol.toPrimitive](&#39;default&#39;) ， 通过 Symbol.toPrimitive 可以自由改变对象被类型转换的返回结果： // 没有 Symbol.toPrimitive 属性的对象var obj1 = &#123;&#125;;console.log(+obj1); // NaNconsole.log(`$&#123;obj1&#125;`); // &quot;[object Object]&quot;console.log(obj1 + &quot;&quot;); // &quot;[object Object]&quot;// 拥有 Symbol.toPrimitive 属性的对象var obj2 = &#123; [Symbol.toPrimitive](hint) &#123; console.log(`hint is $&#123;hint&#125;`); if (hint === &#x27;string&#x27;) &#123; return 1; &#125; else if (hint === &#x27;number&#x27;) &#123; return 2; &#125; else &#123; return 3; &#125; &#125;&#125;;console.log(+obj2);// hint is number// 2console.log(`$&#123;obj2&#125;`);// hint is string// 1console.log(obj2 + &quot;&quot;);// hint is default// 3 注意，hint 的取值只有 number 、 string 和 default 三种，当在进行类型转换的时候，如果 hint === &#39;number&#39; 分支的返回结果不能转换为数字，则会返回 NAN 。 Symbol.toStringTag对象的 Symbol.toStringTag 属性，指向一个函数，当对象被调用 Object.prototype.toString 方法的时候，这个函数的返回标签会出现在 toString 方法返回的字符串中： var obj = &#123;&#125;;obj.toString(); // &quot;[object Object]&quot;var obj = &#123; get [Symbol.toStringTag]() &#123; return &#x27;Obj&#x27;; &#125;&#125;obj.toString(); // &quot;[object Obj]&quot; 应用场景存储对象的基础属性Symbol 唯一的特性可以保证作为对象的属性名，其属性值不会被误修改： Symbol(&#x27;foo&#x27;) === Symbol(&#x27;foo&#x27;); // falsevar obj = &#123;&#125;;var foo1 = Symbol(&#x27;foo&#x27;);var foo2 = Symbol(&#x27;foo&#x27;);obj[foo1] = 1;obj[foo2] = 2;obj[foo1] === 1 // trueobj[foo2] === 2 // true 由于外界拿不到 foo1 和 foo2 的引用，就可以保证了 它们对应的属性值不会被修改。 但是，这只能防止被误修改，但是实际上还是能被修改的： var obj = &#123; [Symbol(&#x27;foo&#x27;)]: 1&#125;console.log(obj); // Object &#123;Symbol(foo): 1&#125;var symbolKeys = Object.getOwnPropertySymbols(obj);obj[symbolKeys[0]] = 2;console.log(obj); // Object &#123;Symbol(foo): 2&#125; 因此，这种存储方式并不是完全私有的，可以存放一些不想被误修改的数据又不介意被修改的数据。 替代标识用的静态变量比如当记录日志的时候，通常会有多个日志的级别：debug 、 info 、 warn ，以前通常是这么写的： var levels = &#123; DEBUG: &#x27;debug&#x27;, INFO: &#x27;info&#x27;, WARN: &#x27;warn&#x27;,&#125;;// 或var levels = &#123; DEBUG: 1, INFO: 2, WARN: 4,&#125;; 这样写也可以工作，但是这些值并不唯一，可能会和其他值冲突。而实际上这些值取什么并无意义，只需要确保不会和其他值冲突即可。因此，完全可以使用 Symbol 替代： var levels = &#123; DEBUG: Symbol(&#x27;debug&#x27;), INFO: Symbol(&#x27;info&#x27;), WARN: Symbol(&#x27;warn&#x27;),&#125;;console.log(levels.DEBUG, &#x27;debug message&#x27;); // Symbol(debug) &quot;debug message&quot;console.log(levels.INFO, &#x27;info message&#x27;); // Symbol(info) &quot;info message&quot; 提供一个修改的钩子比如之前提到的 Symbol.toStringTag 等就是一个 toString 方法的钩子，使用这个可以改变自定义的对象的显示名称，这在开发工具函数也很有用： var inspect = Symbol(&#x27;inspect&#x27;);var log = (obj) =&gt; &#123; if (obj[inspect]) &#123; console.log(obj[inspect]); return ; &#125; console.log(obj);&#125;var obj1 = &#123;&#125;;log(obj1); // Object &#123;&#125;var obj2 = &#123; [inspect]: &quot;This is object2&quot;,&#125;;log(obj2); // This is object2 如上述例子，编写了一个增强的 log ，默认使用 console.log 直接打印对象，但是如果对象存在 inspect 这个属性值 则打印这个属性值的内容，这个属性值就是提供的一个改变函数行为的钩子。 参考 MDN ECMAScript 6 入门-阮一峰 Metaprogramming in ES6: Symbols and why they’re awesome ES6学习——类语法：Symbolspecies在实例创建中的应用","categories":[{"name":"js","slug":"js","permalink":"http://tcatche.site/categories/js/"}],"tags":[{"name":"es","slug":"es","permalink":"http://tcatche.site/tags/es/"}]},{"title":"函数式编程-柯里化和反柯里化","slug":"function-program-curry-function","date":"2017-04-21T06:51:00.000Z","updated":"2018-08-01T10:41:24.000Z","comments":true,"path":"2017/04/function-program-curry-function/","link":"","permalink":"http://tcatche.site/2017/04/function-program-curry-function/","excerpt":"","text":"柯里化 curry柯里化，是把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数的技术。 var add = (x, y) =&gt; x + y;var curriedAdd = x =&gt; y =&gt; x + y;var addOne = curriedAdd(1);var addTen = curriedAdd(10);addOne(5);// 6addTen(5);// 15 上述示例，将原本接收两个参数的 add 改造成了接收一个参数的 addOne 和 addTen 函数，每个函数都具有独立的语义。 这种方式有一个优点，可以把易变的参数固定下来。这个最典型的应用场景是使用 bind 函数绑定 this 对象： Function.prototype.bind = function(context) &#123; var _this = this； var _args = Array.prototype.slice.call(arguments, 1); return function() &#123; return _this.apply(context, _args.concat(Array.prototype.slice.call(arguments)))； &#125;&#125; 柯里化的另一个应用场景是在如果有多个不同的执行场景，可以提前确定当前执行环境。这个最典型的例子是兼容现代浏览器以及 IE 浏览器的事件监听： var addEvent = (root, ele, type, fn, capture = false) =&gt; &#123; if (root.attachEvent) &#123; ele.attachEvent(&#x27;on&#x27; + type, fn); &#125; else if (root.addEventListener) &#123; ele.addEventListener(type, fn, capture); &#125;&#125; 这个函数执行倒没有问题，只是每次调用都会执行一次 if...else，挺繁琐的，完全可以通过柯里化只做一次判定： var addEvent = ((root) =&gt; &#123; if (root.attachEvent) &#123; return (ele, type, fn) =&gt; ele.attachEvent(&#x27;on&#x27; + type, fn); &#125; else if (root.addEventListener) &#123; return (ele, type, fn, capture = false) =&gt; ele.addEventListener(type, fn, capture); &#125;&#125;)(window); 这样addEvent函数实际上已经是本浏览器支持的事件添加方法。 curry 的实现curry 的实现有两种方法，第一种是自己手工实现： var add = (x, y, z) =&gt; x + y + z;var curriedAdd = x =&gt; y =&gt; z =&gt; x + y + z; 还有一种方法就是使用 curry 函数进行转换， 如 lodash 和 ramda 都提供有函数可以自动完成 curry， 这里写一个简单的实现： var curry = (fn, length = fn.length) =&gt; &#123; var args = []; var _curryN = (...arguments) =&gt; &#123; args = args.concat(Array.prototype.slice.call(arguments)); if (args.length == length) &#123; return fn.apply(null, args); &#125; return _curryN; &#125;; return _curryN;&#125; 就是，生成一个 curry 函数，每次调用 curry 函数的时候计算函数的参数是否满足定义时候的参数数量，如果不满足，则缓存当前的参数，否则，把多次调用 curry 函数的参数传入原始函数执行。 中间的 _curryN 是个挺有用的工具，可以将一个接受多个参数的函数转化为接受部分参数的 curry 函数，将其进一步分离，并优化代码结构如下： var curryN = (fn, length) =&gt; &#123; //对原始函数的包装，合并多次调用的柯里化的函数的参数，作为原始函数fn的参数，调用fn var _warpFunc = (fn, args) =&gt; (...arguments) =&gt; fn.apply(null, args.concat(Array.prototype.slice.call(arguments))); return function() &#123; var args = Array.prototype.slice.call(arguments); if (args.length &lt; length) &#123; return curryN(_warpFunc(fn, args), length - args.length) &#125; return fn.apply(null, args); &#125;&#125;var curry = (fn, length = fn.length) =&gt; curryN(fn, length); 反柯里化 uncurry反柯里化（uncurry）从字面上就可以看出和柯里化（curry）的含义正好相反，如果说柯里化的作用是固定部分参数，势函数针对性更强，那么反柯里化的作用就是扩大一个函数的应用范围，使一个函数适用于其他的对象。 如果说 curry 是预先传入一些参数，那么 uncurry 就是把原来已经固定的参数或者 this 上下文当作参数延迟到问来传递，也就是把 this.method 的调用模式转化成 method(this,arg1,arg2....)。 比如，Array 上有一个 push 的方法，想让 push 这个函数不仅仅支持数组，还能够被其他对象使用：push(obj,args) ，如下： var arr = [1, 2, 3];arr.push(4)// [1, 2, 3, 4]var push = Array.prototype.push.unCurry();var obj = &#123;&#125;;push(obj, &quot;a&quot;)// Object &#123;0: &quot;a&quot;, length: 1&#125; 在javascript里面，很多函数都不做对象的类型检测，而是只关心这些对象能做什么，如 Array 和 String 的 prototype 上的方法就被特意设计成了这种模式，这些方法不对 this 的数据类型做任何校验，因此 obj 可以冒用 Array 的 push 方法进行操作。这里再看一个 String 的例子： var toUpperCase = String.prototype.toUpperCase.unCurry();toUpperCase(&#x27;js&#x27;); // JS call 方法也可以被 unCurry： var a = &#123; name: &#x27;a&#x27;, print: function() &#123; console.log(this.name) &#125;, change: function(name) &#123; this.name = name console.log(this.name) &#125;,&#125;a.print();// avar b = &#123; name: &#x27;b&#x27;&#125;a.print.call(b);// bvar call = Function.prototype.call.unCurry();call(a.print, b)// bcall(a.print, b, &#x27;bb&#x27;)a.name// &quot;aa&quot;b.name// &quot;bb&quot; unCurry 本身也是方法，它也可以被反柯里化： var unCurry = Function.prototype.unCurry.unCurry();var toUpperCase = unCurry(String.prototype.toUpperCase)toUpperCase(&#x27;js&#x27;); // JS 反柯里化的实现：实现的代码很简单，只有几行，但是比较绕： /** * 为 Function 原型添加 unCurry 方法，这样所有的 function 都可以被修改适用范围； * 需要返回一个修改后的适用范围的函数，此时需要借用 call 方法实现 * 但是需要处理参数，此时借用 apply传入参数 */Function.prototype.unCurry = function() &#123; // _fn 在本例中是 Array.prototype.push var _fn = this; return function() &#123; // 这里有点绕，做个说明： // return Function.prototype.call.apply(_fn, arguments); // // 等价于： // var fCall = Function.prototype.call; // return fCall.apply(_fn, arguments); // // 等价于： // return _fn.fCall(...arguments); // // 等价于： // return _fn.apply(arguments[0], [].slice.call(arguments, 1)); // // 即修改 _fn 中的 this 指向第一个参数，在本例中是 obj， // 剩下的参数传入原函数_fn return Function.prototype.call.apply(_fn, arguments); &#125;&#125; 参考 mostly-adequate-guide 函数式JavaScript（4）：函数柯里化 前端开发者进阶之函数反柯里化unCurry","categories":[{"name":"js","slug":"js","permalink":"http://tcatche.site/categories/js/"}],"tags":[{"name":"function","slug":"function","permalink":"http://tcatche.site/tags/function/"},{"name":"函数式","slug":"函数式","permalink":"http://tcatche.site/tags/%E5%87%BD%E6%95%B0%E5%BC%8F/"}]},{"title":"函数式编程-纯函数","slug":"function-program-pure-function","date":"2017-04-13T10:31:00.000Z","updated":"2018-08-01T10:41:24.000Z","comments":true,"path":"2017/04/function-program-pure-function/","link":"","permalink":"http://tcatche.site/2017/04/function-program-pure-function/","excerpt":"","text":"定义实际上纯函数的定义更近似于数学上的函数的定义，数学上的函数定义如下： 设A，B是非空的数集，如果按照某种确定的对应关系f，使对于集合 A 中的任意一个数 x，在集合B中都有唯一确定的数 y 和它对应，那么就称 f:A-&gt;B 为从集合A 到集合B 的一个函数。 而纯函数的定义为： 纯函数定义为这样一种函数：对于相同的输入，其输出的结果永远是相同的，而且没有可见的副作用。 从定义上可以看出，纯函数和数学上的函数都有要求：对于任意相同输入，其输出结果都是 唯一确定 的，不存在一个输入对应于多个输出结果的情况。 纯函数和非纯函数很经常看到，比如数组的 slice 和 splice 函数，一个是纯函数，一个就是非纯函数： slice 函数是纯函数，执行结果是可预计的、可靠的，每次输入相同的参数，执行操作的结果都一致： var arr = [1, 2, 3, 4];// 纯函数的示例：arr.slice(0, 2);// [1, 2]arr.slice(0, 2);// [1, 2] 而 splice 函数不是纯函数，输入相同的参数，每次操作的结果都不一致： // 非纯函数的示例：arr.splice(0, 2);// [1, 2]arr.splice(0, 2);// [3， 4]arr.splice(0, 2);// [] 副作用前面提到纯函数不存在副作用，副作用的影响是这样的： 副作用表示在运算过程中，系统状态的改变或者与外部进行的可观察的交互。如果一个函数与外部的可变状态发生了交互，则认为函数是有副作用的。 可以看个例子： var minAge = 21;// 存在副作用的函数var checkAge = age =&gt; age &gt; minAge;// 不存在副作用的函数var checkAge = age =&gt; &#123; var minAge = 21; return age &gt; minAge;&#125; 从以上示例可以看到，对于同一个输入，第一个函数存在副作用，这个函数的行为不光取决于函数的参数，而且依赖外部变量 minAge ，如果外部修改了 minAge 的值，函数的执行结果可能发生改变，这种改变是不可预期的，而第二个函数不存在副作用，没有使用或修改任何的外部变量，因此可以保证它的输出结果始终是不会发生改变的。 对于一个系统而言，依赖外部系统环境的状态会造成额外的复杂度，而使用纯函数可以有效降低系统的复杂度，而且还有一些其他的特性： 纯函数的特性纯函数具有很多可靠的特性： 可缓存性因为纯函数的输出结果是确定的，只和输入有关，因此对于复杂运算可以将结果存储起来，下次直接使用。 如下定义了一个非常耗时的操作： var complexFunc = (val) =&gt; &#123; // 耗时的操作 for(var i = 0; i &lt; 100000000; i ++) &#123;&#125; return val ++;&#125;console.time(&#x27;timer&#x27;);complexFunc(1);console.timeEnd(&#x27;timer&#x27;);// timer: 257ms// 重复调用，函数重新运行，运行时间没有怎么发生变化。console.time(&#x27;timer&#x27;);complexFunc(1);console.timeEnd(&#x27;timer&#x27;);// timer: 227ms 这个操作执行较慢，每次都要花费大量时间，但是这是个纯函数，每次执行的结果是可预期的，因此，可以对其执行结果进行缓存： //一个缓存函数结果的简单的实现var memoize = function(f) &#123; var _cache = &#123;&#125;; return function() &#123; var argsStr = JSON.stringify(arguments); _cache[argsStr] = _cache.hasOwnProperty(argsStr) ? _cache[argsStr] : f(arguments); return _cache[argsStr]; &#125;&#125;var memoizedFunc = memoize(complexFunc); 然后再次执行这个函数： // 第一次执行未缓存console.time(&#x27;timer&#x27;);memoizedFunc(1);console.timeEnd(&#x27;timer&#x27;);// timer: 250ms// 此时运行结果已经被缓存，运行速度大幅增加。console.time(&#x27;timer&#x27;);memoizedFunc(1);console.timeEnd(&#x27;timer&#x27;);// timer: 0.0149ms 通过将执行结果缓存起来，虽然第一次调用的执行时间人就很长，但是当函数第二次被调用的时候，可以直接从缓存的数据中读取结果，函数的时间大大缩短。 可并行化因为纯函数不需要访问共享数据，不会受外部状态影响而进行资源竞争，纯函数可以很容易的实行并行代码或者并行操作。 参考 mostly-adequate-guide","categories":[{"name":"js","slug":"js","permalink":"http://tcatche.site/categories/js/"}],"tags":[{"name":"function","slug":"function","permalink":"http://tcatche.site/tags/function/"},{"name":"函数式","slug":"函数式","permalink":"http://tcatche.site/tags/%E5%87%BD%E6%95%B0%E5%BC%8F/"}]},{"title":"一些有趣的网站","slug":"some-awasome-site","date":"2017-04-12T07:38:00.000Z","updated":"2021-08-10T03:35:21.472Z","comments":true,"path":"2017/04/some-awasome-site/","link":"","permalink":"http://tcatche.site/2017/04/some-awasome-site/","excerpt":"","text":"这里收集了一些有趣的好玩的网站 Unsplash Unsplash 是一个真免费提供高质量照片的网站，照片都是真实的摄影，照片分辨率也很大，该照片网站每10天更新10张照片。 但是我要介绍的是它的一个获取随机图片的api [https://source.unsplash.com/](https://source.unsplash.com/) 支持多种方式的随机图片获取： 从指定分类中随机获取图片 从指定用户随机获取图片 从指定用户喜欢的图片 从指定图片集随机获取图片 从一个分类中随机获取图片 从一个关键字随机获取图片 还支持js、php等api，详细可以查看其页面，不再多言。 WebGradients WebGradients is a free collection of 180 linear gradients that you can use as content backdrops in any part of your website. Easy copy CSS3 crossbrowser code and use it in a moment! We’ve also prepared a .PNG version of each gradient. As a bonus, there are packs for Sketch &amp; Photoshop. 简单来说，WebGradients 这个网站收集了180个漂亮的色彩渐变，可以用在任意需要渐变背景的地方。 Can I use __ ? Can I use __ ? 是一个可以统计前端技术的浏览器兼容性，并以表格的形式呈现出来的工具类网站。比如我想知道 Flexible Box 的浏览器兼容性如何，可以在页面搜索，获得兼容性结果： 当在应用一些新的特性的时候可以很方便的检查一下兼容性确定要支持的版本是否满足要求。","categories":[{"name":"其它","slug":"其它","permalink":"http://tcatche.site/categories/%E5%85%B6%E5%AE%83/"}],"tags":[]},{"title":"ES6 - Generator 函数和 Async 函数","slug":"generator-and-async-function","date":"2017-04-11T07:06:00.000Z","updated":"2018-08-01T10:41:24.000Z","comments":true,"path":"2017/04/generator-and-async-function/","link":"","permalink":"http://tcatche.site/2017/04/generator-and-async-function/","excerpt":"","text":"Generator 函数Generator （生成器）函数是 ES6 提供的新的解决异步回调嵌套的特性，先看个实例： function* test()&#123; yield 1; //执行顺序：3 yield 2; //执行顺序：6 return 3; //执行顺序：9&#125;var g = test(); //执行顺序：1var rt;rt = g.next(); //执行顺序：2console.log(rt); // 执行顺序：4 输出：Object &#123;value: 1, done: false&#125;rt = g.next(); //执行顺序：5console.log(rt); // 执行顺序：7 输出：Object &#123;value: 2, done: false&#125;rt = g.next(); //执行顺序：8console.log(rt); // 执行顺序：10 输出：Object &#123;value: 3, done: true&#125;rt = g.next(); //执行顺序：11console.log(rt); // 执行顺序：12 输出：Object &#123;value: undefined, done: true&#125; 上面出现的几个关键字的作用： function* 声明一个生成器函数，通过生成器函数可以得到一个迭代器 yeild 关键字可以保存 Generator 函数的执行位置，并跳出到调用此函数的地方继续执行, yeild 关键字只能用于 Generator 函数， 否则报错 通过此函数的 next 函数，可以继续返回之前暂停的地方继续执行，next 函数返回值是一个包含两个属性的对象，value 属性是 yield 后面语句的结果，done 属性代表是否结束 Generator 的运行流程为： 每次执行生成器函数（var g = test()），都会生成一个迭代器对象（g） 每次调用迭代器对象的 next 方法（g.next()），都会促使迭代器对象向下执行，直到遇到 yield 关键字后，保存当前状态并跳出迭代器，并把 yield 关键字后的表达式的结果作为 value 的值返回 外围函数继续执行（console.log(rt)），直到下次调用迭代器的 next 函数，则继续从迭代器停止的位置开始继续执行，直到下一个 yield 语句。 如果直到运行结束没有下一个 yield 语句则迭代器结束，设置 done 字段的值为 true ，此时，如果存在 return 语句，则 return 语句的返回值为 value 属性的值，否则 value 的值为 undefined 此时迭代器已经结束，再次调用 next() 结果始终为： &#123;value: undefined, done: true&#125; Generator.prototype.next()next() 方法可以接受一个参数向生成器传值（参数可以省略），并返回一个包含属性 done 和 value 的对象: gen.next([value]) [value][Any=undefined]：修改上一次 yield 语句的返回值，如果是第一次调用则不起作用。 return[{value, done}]： value 表示本次 yield 语句的值，done 表示是否结束。 注意 如果 value 参数省略则传递给当前 yield 语句的值为 undefined： function* double(x) &#123; while(true) &#123; x = 2 * (yield x); &#125;&#125;var t = double(3);t.next() // Object &#123;value: 3, done: false&#125;t.next() // Object &#123;value: NaN, done: false&#125;t.next(4) // Object &#123;value: 8, done: false&#125; 在以上示例中，第二次执行 next() 未传递参数，此时实际上等价于 x = 2 * undefined 因此此时 value 属性的值为 NAN ，第三次执行时，传递了参数 4 此时的 value 为 2 * 4 。 Generator.prototype.throw()throw() 方法用来向生成器抛出异常，如果生成器函数包含 try...catch 语句块，则被其捕获，否则异常抛到外部函数： var g = function* () &#123; try &#123; yield; &#125; catch (e) &#123; console.log(&#x27;内部捕获&#x27;, e); &#125; yield console.log(&quot;This line will be logged&quot;);&#125;;var i = g();i.next();try &#123; i.throw(&#x27;a&#x27;); i.throw(&#x27;b&#x27;);&#125; catch (e) &#123; console.log(&#x27;外部捕获&#x27;, e);&#125;// 内部捕获 a// This line will be logged// 外部捕获 b 由上述示例可以看到，在触发 throw 语句时，如果 generate 内部处理了这个错误，则会执行了一次 next 语句。 刚才提到，如果 generate 函数跑出的错误没有被 generate 函数内部捕获处理，错误会被交给外部函数，此时，生成器函数将执行结束，即再次调用其 next 方法，则始终返回 &#123;value:undefined, done: true&#125; ，此生成器函数不再会被执行： var gen = function* () &#123; yield console.log(&quot;This line will be logged.&quot;); throw new Error(&quot;Something is error.&quot;) yield console.log(&quot;This line will not be logged.&quot;); yield console.log(&quot;This line also will not be logged.&quot;);&#125;;var g = gen();try &#123; g.next(); g.next(); g.next();&#125; catch (err) &#123; console.log(err)&#125;// Object &#123;value: undefined, done: false&#125;// Error: Something is error.// Object &#123;value: undefined, done: true&#125; Generator.prototype.return()return() 方法返回给定的值并提前结束生成器 function* gen() &#123; yield 1; yield 2; yield 3;&#125;var g = gen();g.next(); // &#123; value: 1, done: false &#125;g.return(&quot;foo&quot;); // &#123; value: &quot;foo&quot;, done: true &#125;g.next(); // &#123; value: undefined, done: true &#125; Async 函数ES2017 标准引入了 async 函数，更加简化了异步操作，而 async 函数实际上是 Generator 函数的语法糖。 async 函数返回一个 Promise 对象，可以使用 then 回调处理函数的返回值，async 函数如果包括 await 表达式，则会暂停执行，等待 await 表达式执行完毕后继续执行，如果 async 函数内部有多个 await ，则只有当所有的 await 执行完成或者遇到未捕获的错误才会结束。 function delay(time, value)&#123; return new Promise(resolve =&gt; &#123; setTimeout(() =&gt; &#123; console.log(`After $&#123;time&#125;ms return $&#123;value&#125;.`); resolve(value); &#125;, time) &#125;)&#125;async function add(x) &#123; var a = await delay(200, 1); var b = await delay(300, 2); return x + a + b;&#125;add(2).then(d=&gt;console.log(d));// After 200ms return 1.// After 300ms return 2.// 5 await 语句await 命令通常跟一个 Promise 对象，如果后面不是一个 Promise，则被转换成一个立即 resolve 的 Promise 对象，如果 await 后面的 Promise 状态变为 reject ，则 async 停止执行，且其返回的 Promise 状态为 reject ： async function test() &#123; await Promise.reject(&quot;reject&quot;); console.log(&quot;This line will not run&quot;); // not log&#125;test().then(d =&gt; console.log(d)).catch(e =&gt; console.log(e));// reject await 并发多个 await 的命令实际上是逐个调用的，即只有在上一个调用完成之后才会进行下一个的调用： function delay(time, value)&#123; return new Promise(resolve =&gt; &#123; setTimeout(() =&gt; &#123; console.log(`After $&#123;time&#125;ms return $&#123;value&#125;.`); resolve(value); &#125;, time) &#125;)&#125;async function add(x) &#123; var a = await delay(300, 1); console.log(&#x27;Waiting.&#x27;); var b = await delay(200, 2); return x + a + b;&#125;add(2).then(d=&gt;console.log(d));// After 300ms return 1.// Wait delay(300, 1) finished.// After 200ms return 2.// 5 由以上示例可以看到，第一个 await 执行时间较长，log(&#39;Waiting.&#39;) 语句等待其执行完毕后才执行，如果两个 await 是相互独立的操作最好让他们同时触发，可以减少操作耗时： function delay(time, value)&#123; return new Promise(resolve =&gt; &#123; setTimeout(() =&gt; &#123; console.log(`After $&#123;time&#125;ms return $&#123;value&#125;.`); resolve(value); &#125;, time) &#125;)&#125;// 原始继发的写法async function add(x) &#123; var t1 = new Date().getTime(); var a = await delay(300, 1); var b = await delay(200, 2); var t2 = new Date().getTime(); console.log(`Async run Time is $&#123;t2 - t1&#125;ms.`); return x + a + b;&#125;// 改进1：先调用 promise 后赋值async function add1(x) &#123; var t1 = new Date().getTime(); var delayA = delay(300, 1); var delayB = delay(200, 2); var a = await delayA; var b = await delayB; var t2 = new Date().getTime(); console.log(`Async run Time is $&#123;t2 - t1&#125;ms.`); return x + a + b;&#125;// 改进2：使用 Promise.allasync function add2(x) &#123; var t1 = new Date().getTime(); var [a, b] = await Promise.all([delay(300, 1), delay(200, 2)]) var t2 = new Date().getTime(); console.log(`Async run Time is $&#123;t2 - t1&#125;ms.`); return x + a + b;&#125;add(2).then(d=&gt;console.log(d));// After 300ms return 2.// After 200ms return 1.// Async run Time is 1852ms.// 5add1(2).then(d=&gt;console.log(d));// After 200ms return 2.// After 300ms return 1.// Async run Time is 360ms.// 5add2(2).then(d=&gt;console.log(d));// After 200ms return 2.// After 300ms return 1.// Async run Time is 381ms.// 5 由上例可以看出，此时耗时更短的 delayB 先完成，并且总耗时也最短。 重写 Promise回调链：先看一个示例： // 使用纯 Promise 的写法function getProcessedData(url) &#123; return downloadData(url) // returns a promise .catch(e =&gt; &#123; return downloadFallbackData(url) // returns a promise &#125;) .then(v =&gt; &#123; return processDataInWorker(v); // returns a promise &#125;);&#125;// 使用 async 的写法async function getProcessedData(url) &#123; let v: try &#123; v = await downloadData(url); &#125; catch (e) &#123; v = await downloadFallbackData(url); &#125; return processDataInWorker(v);&#125; 从上述示例可以看出，使用 Async 处理异步的流程写起来非常的直观，就像同步的代码一样。 异常处理如果 await 后面的 promise 出错或者 reject ，此 await 后面的语句将会被跳过，此时可以将 await 语句放到 try...catch 代码块中： async function test() &#123; try &#123; await Promise.reject(&quot;reject&quot;); // 如果有多个 await语句，都可以放进来 &#125; catch(e) &#123; &#125; console.log(&quot;This line will run.&quot;);&#125;test().then(d=&gt;console.log(d)).catch(e=&gt;console.log(e));// This line will run.// undefined. 因为 async 函数没有返回任何值 使用 try...catch 结构，可以实现多次尝试： function delay(time, value)&#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; var random = Math.random(); if (random &gt; 0.6) &#123; resolve(value); &#125; else &#123; reject(value) &#125; &#125;, time) &#125;)&#125;async function test() &#123; const MAX_TRY_TIMES = 5; for (var i = 0; i &lt; MAX_TRY_TIMES; i ++) &#123; console.log(`第 $&#123;i + 1&#125; 次尝试`) try &#123; await delay(100, 1); break; &#125; catch(err) &#123; &#125; &#125; console.log(`第 $&#123;i + 1&#125; 次尝试成功`); // 3&#125;test();// 第 1 次尝试// 第 2 次尝试// 第 2 次尝试成功 Async 的实现前文提到 async 是 generate 函数的语法糖，也就是说，async 函数实质上是对 generate 函数的封装，在这里将尝试使用 generate 来生成 async 的实现： 首先需要把 async 的函数内容定义转化为 generate 函数，这一步很简单，只需要把 async 关键字去掉，function 关键字后面加 * ，代码中所有的 await 关键字改为 yield 关键字： var asyncFunc = async function(x) &#123; var a = await delay(300, 1); var b = await delay(200, 2); return x + a + b;&#125;// 转化为var generateFunc = function* (x) &#123; var a = yield delay(300, 1); var b = yield delay(200, 2); return x + a + b;&#125;; 但是此时 generateFunc 还不能被执行，还需要为 generateFunc 创建一个执行器 generateFuncRunner，而 async 函数返回一个 Promise ，可以很容易写出执行器 generateFuncRunner 的函数签名： var asyncFunc = function() &#123; return generateFuncRunner(generateFunc);&#125;;function generateFuncRunner(fn) &#123; return new Promise(function (resolve, reject) &#123; // run generate &#125;);&#125; 接下来就是编写一个 generate 的运行器了，具体思路在注释里，不再详细说明： function generateFuncRunner(fn) &#123; return new Promise(function (resolve, reject) &#123; // 获取迭代器对象 var gen = fn(); // 递归运行该迭代器对象 function step(args) &#123; try &#123; var next = gen.next(args); &#125; catch(err) &#123; reject(err); &#125; // generate fn 已经结束，直接 resolve if (next.done) &#123; resolve(next.value); // generate fn 未结束，递归向后执行直到 fn 结束 &#125; else &#123; // 返回一个立即 resolve 的 promise 处理下一处 yield return Promise.resolve(next.value).then(function(value) &#123; step(value); // 捕获 generate 函数的下一个 yield 处可能发生的异常 &#125;, function(err) &#123; gen.throw(err); &#125;) &#125; &#125; &#125;);&#125; 这样就实现了 async 函数，下面附上 babel 对 async 的转码作为参考（针对本实例稍有修改）： let asyncFunc = (() =&gt; &#123; var _ref = _asyncToGenerator(function* (x) &#123; var a = yield delay(300, 1); var b = yield delay(200, 2); return x + a + b; &#125;); return function asyncFunc() &#123; return _ref.apply(this, arguments); &#125;;&#125;)();function _asyncToGenerator(fn) &#123; return function () &#123; return new Promise(function (resolve, reject) &#123; var gen = fn(); function step(key, arg) &#123; try &#123; var info = gen[key](arg); var value = info.value; &#125; catch (error) &#123; reject(error);return; &#125; if (info.done) &#123; resolve(value); &#125; else &#123; return Promise.resolve(value).then(function (value) &#123; step(&quot;next&quot;, value); &#125;, function (err) &#123; step(&quot;throw&quot;, err); &#125;); &#125; &#125;return step(&quot;next&quot;); &#125;); &#125;;&#125; 参考 ECMAScript 6 入门-阮一峰 async function-MDN","categories":[{"name":"js","slug":"js","permalink":"http://tcatche.site/categories/js/"}],"tags":[{"name":"function","slug":"function","permalink":"http://tcatche.site/tags/function/"},{"name":"es","slug":"es","permalink":"http://tcatche.site/tags/es/"},{"name":"异步","slug":"异步","permalink":"http://tcatche.site/tags/%E5%BC%82%E6%AD%A5/"}]},{"title":"Debounce 和 Throttle","slug":"debounce-throttle","date":"2017-03-24T03:39:00.000Z","updated":"2018-08-01T10:41:24.000Z","comments":true,"path":"2017/03/debounce-throttle/","link":"","permalink":"http://tcatche.site/2017/03/debounce-throttle/","excerpt":"","text":"在一些应用场合下，由于事件被频繁的触发，导致为事件绑定的函数被频繁的调用，因为斌烦的执行大量无意义的DOM操作、Ajax请求等行为，造成页面的抖动和资源的大量消耗甚至错误的数据加载。常见的导致这些情况出现的事件主要这些： window 对象的 resize、scroll 事件 鼠标拖拽的 mousemove 事件 输入文本时的绑定的用于进行自动完成或自动加载的操作的 keyup 事件 对于这些情况通常可以延迟函数的执行时机，来进行优化，根据延迟的策略不同，有 debounce 和 throttle 两种解决办法： DebounceDebounce 就是强制一个函数在某个动作结束 n 毫秒后执行，如果在这 n 毫秒内，该动作再次发生，则重新计时。 下面是一个简单的实现： /*** @param func &#123;Function&#125; 目标函数* @param delay &#123;Number&#125; 空闲时间，单位毫秒* @param context &#123;Object&#125; 可省略，function 内部的上下文* @return &#123;Function&#125; 返回客户调用函数*/var debounce = function (func, delay, context) &#123; var timer; return function () &#123; var ctx = context || this; //每次被调用就清除上次的定时器 //并新建一个定时器，重新计时 if (timer) &#123; clearTimeout(timer); &#125; timer = setTimeout(function () &#123; func.apply(ctx, arguments); &#125;, delay); &#125;;&#125;;// 使用：window.addEventListener(&#x27;resize&#x27;, debounce(function ()&#123; console.log(&#x27;resize&#x27;);&#125;, 250)); ThrottleThrottle 为函数设定一个执行周期，强制函数在指定的执行周期内执行且仅执行一次，也就是说，当动作发生时，如果该函数上次执行的时间到现在小于这个执行周期，则不执行函数。 下面是一个简单的实现： /*** @param func &#123;Function&#125; 目标函数* @param threshhold &#123;Number&#125; 间隔时间，单位毫秒* @param context &#123;Object&#125; 可省略，function 内部的上下文* @return &#123;Function&#125; 返回客户调用函数*/var throttle = function (func, threshhold, context) &#123; var last; var timer; return function () &#123; var current = new Date(); var ctx = context || this; // 在函数刚开始或到达指定间隔后执行func if (!last || current - last &gt; threshhold) &#123; last = current; func.apply(ctx, arguments); // 保证最终状态时候的调用能够被执行，否则最终状态可能会被过滤掉 &#125; else &#123; clearTimeout(timer); setTimeout(function() &#123; last = current; func.apply(ctx, arguments); &#125;) &#125; &#125;;&#125;;window.addEventListener(&#x27;resize&#x27;, throttle(function () &#123; console.log(&#x27;resize&#x27;)&#125;, 250)); 总结这两个函数很相似，使用场景也很类似，最主要的就是区分两者对调用时机的处理，简单来说就是当函数被连续调用时 debounce 限制目标函数仅在停止调用时间足够长后才执行， throttle 限制目标函数以固定的速率执行，主要应用场景如下： 表单根据输入自动补全或自动加载时使用 debounce 处理 DOM 元素动态定位 resize、scroll 事件使用 throttle 处理 mousemove 事件使用 throttle 当然这也并非是固定的，具体情况还要跟使用场景相关。 参考 Timing Controls Debounce and Throttle: a visual explanation","categories":[{"name":"js","slug":"js","permalink":"http://tcatche.site/categories/js/"}],"tags":[{"name":"优化","slug":"优化","permalink":"http://tcatche.site/tags/%E4%BC%98%E5%8C%96/"},{"name":"function","slug":"function","permalink":"http://tcatche.site/tags/function/"}]},{"title":"ES6 - Proxy 对象","slug":"proxy-object","date":"2017-03-21T09:38:00.000Z","updated":"2020-07-22T03:06:42.873Z","comments":true,"path":"2017/03/proxy-object/","link":"","permalink":"http://tcatche.site/2017/03/proxy-object/","excerpt":"","text":"概述Proxy 对象是定义在全局对象上的一个对象的构造函数，通过对目标对象的一些基本操作进行重定义并生成新的代理对象。说起来比较绕，看如下示例： var obj = new Proxy(&#123;&#125;, &#123; set(target, key, val) &#123; console.log(&#x27;call setter&#x27;); return Reflect.set(target, key, val); &#125;&#125;);obj.val = 3;// call setter// 3 Proxy 对象生成的新对象修改了 &#123;&#125; 对象的赋值方式，使用 obj.val 赋值，比原始行为多了一行打印日志。 使用 Proxy 对象生成代理对象的语法如下： var proxyObj = new Proxy(target, handler); 其中 handler 是拥有一系列需要更改的默认行为的方法的函数的集合，支持更改的行为和 Reflect 对象的静态函数一一对应： apply： 拦截 Proxy 实例作为函数调用的操作，比如 proxy(...args)、proxy.call(object, ...args)、proxy.apply(...) construct： 拦截 new 命令，比如 new proxy(...args) defineProperty： 拦截 Object.defineProperty(proxy, propKey, propDesc)、Object.defineProperties(proxy, propDescs)，返回一个布尔值 deleteProperty： 拦截 delete proxy[propKey] 的操作，返回一个布尔值 get： 拦截对象属性的读取，比如 proxy.foo 和 proxy[&#39;foo&#39;]。 getOwnPropertyDescriptor： 拦截 Object.getOwnPropertyDescriptor(proxy, propKey)，返回属性的描述对象 getPrototypeOf： 拦截 Object.getPrototypeOf(proxy)、 Object.prototype.__proto__、 Object.prototype.isPrototypeOf()、 Object.getPrototypeOf()、 Reflect.getPrototypeOf()、 instanceof 运算符 ，返回一个对象 has： 拦截 propKey in proxy 的操作，返回一个布尔值 isExtensible： 拦截 Object.isExtensible(proxy) ownKeys： 拦截 Object.getOwnPropertyNames(proxy)、Object.getOwnPropertySymbols(proxy)、Object.keys(proxy)，返回一个数组。该方法返回目标对象所有自身的属性的属性名，而Object.keys()的返回结果仅包括目标对象自身的可遍历属性 preventExtensions： 拦截 Object.preventExtensions(proxy)，返回一个布尔值 set： 拦截对象属性的设置，比如 proxy.foo = v 或 proxy[&#39;foo&#39;] = v setPrototypeOf： 拦截 Object.setPrototypeOf(proxy, proto)，返回一个布尔值 Proxy 支持修改的这些行为和 Reflect 中的行为意义一致，不再一一说明。 应用场景Proxy 顾名思义，类似于设计模式中的代理模式，通常有一下几种用途： 取消代理对于某些场合下，可能会需要收回对代理的使用，这种情况下可以使用 Proxy.revocable，该方法返回一个对象，对象包含两个属性，一个属性是 proxy 实例，另一个是取消 proxy 实例的方法： var &#123;proxy, revoke&#125; = Proxy.revocable(&#123;&#125;, &#123;&#125;);proxy.value = 1;proxy.value; //1revoke();proxy.value; //Uncaught TypeError: Cannot perform &#x27;get&#x27; on a proxy that has been revoked 访问控制和管理在 js 语法中并不存在私有属性，我们可以使用 Proxy 阻止属性被访问： var obj = &#123; _private: &#x27;_private&#x27;, public: &#x27;public&#x27;&#125;var proxyObj = new Proxy(obj, &#123; get(target, key) &#123; // 设置下划线开头的属性为私有属性 if (key.indexOf(&#x27;_&#x27;) &gt; -1) &#123; throw Error(&quot;私有属性，禁止访问&quot;); &#125; return Reflect.get(target, key); &#125;&#125;);proxyObj.public // &quot;public&quot;proxyObj._private // Uncaught Error: 私有属性，禁止访问 通过修改 obj 的 getter，将所有的下划线 _ 属性的访问拦截，并抛出异常，其他的属性正常返回值。 在设置私有属性的时候最好把私有属性遍历和 setter 以及删除也禁用了： var obj = &#123; _private: &#x27;_private&#x27;, public: &#x27;public&#x27;&#125;var proxyObj = new Proxy(obj, &#123; // 设置读取下划线开头的属性 get(target, propKey) &#123; if (propKey.indexOf(&#x27;_&#x27;) &gt; -1) &#123; throw Error(&quot;私有属性，禁止访问&quot;); &#125; return Reflect.get(target, propKey); &#125;, // 禁止为下划线开头的属性赋值 set(target, propKey) &#123; if (propKey.indexOf(&#x27;_&#x27;) &gt; -1) &#123; throw Error(&quot;私有属性，禁止访问&quot;); &#125; return Reflect.get(target, propKey); &#125;, // 禁止删除下划线开头的属性 deleteProperty(target, propKey) &#123; if (propKey.indexOf(&#x27;_&#x27;) &gt; -1) &#123; throw Error(&quot;私有属性，禁止删除&quot;); &#125; return Reflect.deleteProperty(target, propKey); &#125;, // 获取对象成员跳过下划线开头的属性 ownerKeys(target) &#123; return Reflect.ownerKeys(target).filter(item =&gt; item[0] !== &#x27;_&#x27;); &#125;&#125;); 在进行类库编写的时候经常会有接口过期，为了过渡，通常我们不会删除该方法，但是最好能够给出警告信息： var obj = &#123; oldFunc: () =&gt; &#123;&#125;, newFunc: () =&gt; &#123;&#125;&#125;var proxy = new Proxy(obj, &#123; get(target, key) &#123; if (key == &#x27;oldFunc&#x27;) &#123; console.warn(&#x27;警告！ oldFunc 已过时，请使用 newFunc 代替。&#x27;); &#125; return Reflect.get(target, key); &#125;&#125;)proxy.oldFunc(); // 警告！ oldFunc 已过时，请使用 newFunc 代替。 同样我们也可以进行方法拦截，过滤，记录日志等操作，操作和上面类似，不再详细说明。 校验通过 Proxy 可以很方便的实现属性校验： var validatorCreater = (target, validator) =&gt; new Proxy(target, &#123; _validator: validator, set(target, key, value, receiver) &#123; if (this._validator[key]) &#123; if (!this._validator[key](value)) &#123; throw Error(`$&#123;value&#125; is not a valid value`); &#125; return Reflect.set(target, key, value, receiver); &#125; throw Error(`$&#123;key&#125; is not a valid property`); &#125;&#125;);var validators = &#123; name(val) &#123; return typeof val === &#x27;string&#x27;; &#125;, age(val) &#123; return typeof val === &#x27;number&#x27; &amp;&amp; val &gt; 0; &#125;&#125;var person = validatorCreater(&#123;&#125;, validators);person.name = 1; // Uncaught Error: name is not a valid propertyperson.name = &#x27;1&#x27;; // &quot;1&quot;person.age = &#x27;1&#x27;; // Uncaught Error: 1 is not a valid valueperson.age = -1; // Uncaught Error: -1 is not a valid valueperson.age = 12; // &quot;12&quot; 数据变化监听当数据发生改变时，能够监听到这种变化，这是数据绑定的实现基础，来看下面这个例子： 实现 onChange(obj, callback) 函数，当 obj 变化时（新增、删除、修改、查找），调用 callback 函数 function onChange(objToWatch, onChangeFunction) &#123; if (typeof objToWatch !== &quot;object&quot;) &#123; throw TypeError(&quot;objToWatch must be a object&quot;); &#125; return new Proxy(objToWatch, &#123; get(target, propKey, receiver) &#123; onChangeFunction(); const result = Reflect.get(target, propKey, receiver); if (typeof result === &quot;object&quot;) &#123; return onChange(result, onChangeFunction); &#125; return result; &#125;, set(target, propKey, value, receiver) &#123; onChangeFunction(); return Reflect.set(target, propKey, value, receiver); &#125;, deleteProperty(target, propKey) &#123; onChangeFunction(); delete target[propKey]; return true; &#125; &#125;);&#125;// 测试let counter = 0;const logger = () =&gt; &#123; counter++;&#125;;const obj = &#123; a: &#123; b: &#123; c: &#123; d: &quot;123&quot; &#125; &#125; &#125; &#125;;const proxy = onChange(obj, logger);console.log(proxy.a); // 访问属性console.log(counter); // 1console.log(proxy.a.b.c.d); // 访问多层属性，每层都会触发console.log(counter); // 5proxy.a = &quot;b&quot;; // 修改属性console.log(counter); // 6delete proxy.a; // 删除属性console.log(counter); // 7 DecoratorProxy 和 Decorator 在某些情况下还是挺像的，使用上可以区分为：Proxy 的核心作用是控制外界对被代理者内部的访问，Decorator 的核心作用是增强被装饰者的功能。有些功能的实现可以用Proxy 也可以使用 Decorator 。 参考 MDN ECMAScript 6 入门-阮一峰 Metaprogramming in ES6: Part 3 - Proxies 实例解析ES6 Proxy使用场景","categories":[{"name":"js","slug":"js","permalink":"http://tcatche.site/categories/js/"}],"tags":[{"name":"es","slug":"es","permalink":"http://tcatche.site/tags/es/"}]},{"title":"ES6 - Reflect 对象","slug":"reflect-object","date":"2017-03-16T07:24:00.000Z","updated":"2018-08-01T10:41:24.000Z","comments":true,"path":"2017/03/reflect-object/","link":"","permalink":"http://tcatche.site/2017/03/reflect-object/","excerpt":"","text":"Reflect 对象是 ES6 提供的一个内置的用于操作对象的的全局对象。但和其他的全局对象不同，Reflect 对象没有构造函数，不能使用 new关键字 创建对象。 Reflect 静态方法Reflect 对象提供以下静态函数，大部分与 Object 对象上同名方法的作用一样，同时将一些命令式的语法函数化。 Reflect.apply静态方法 Reflect.apply() 通过指定的参数列表发起对目标函数的调用，类似于 Function.prototype.apply.call(target, thisArgument, argumentsList) Reflect.apply(target, thisArgument, argumentsList) target: 目标函数 thisArgument: 绑定的 this 对象 argumentsList: target函数调用时传入的实参列表，该参数应该是一个类数组的对象 throws: 如果 target 不可被调用抛出 TypeError 异常 一般来说，若需要绑定函数的 this 对象通常可以 func.apply(obj, args) 但是有时候函数可能自定义了 apply 方法，为了方便，我们可能需要写成 Function.prototype.apply.call(func, obj, args)，而采用 Reflect.apply，可以简化操作，并且更容易理解： // 除非确认 func.apply 未被其他人定义或改写，方可使用func.apply(obj, args)// 保险方式，稍显冗余Function.prototype.apply.call(func, obj, args);// 保险方式，更加直观Reflect.apply(func, obj, args); Reflect.construct对构造函数进行 new 操作，相当于执行 new target(…args)，提供了一种不使用new，来调用构造函数的方法。 Reflect.construct(target, argumentsList[, newTarget]) target: 目标对象 argumentsList: 参数列表 [newTarget[Function]]: 可省略，类似于 new.target 操作符，指向构造方法或函数的引用 throws: 如果 target 或者 newTarget 不是构造函数，抛出 TypeError 异常 function Foo(val) &#123; this.val = val;&#125;// newvar foo = new Foo(1);// Reflect.constructvar foo1 = Reflect.construct(Foo, [1]); 使用 newTarget 参数： function newTarget() &#123;&#125;var result = Reflect.construct(Array, [], newTarget);Reflect.getPrototypeOf(result); // newTarget.prototypeReflect.getPrototypeOf(result) === newTarget.prototype // trueArray.isArray(result); // true 顺便提下，在普通的函数调用中（和作为构造函数来调用相对），new.target 的值是 undefined，因此可以用来检测是否将构造函数作为普通函数调用： function Foo() &#123; if (!new.target) throw &quot;Foo() must be called with new&quot;; console.log(&quot;Foo instantiated with new&quot;);&#125;Foo(); // throws &quot;Foo() must be called with new&quot;new Foo(); // logs &quot;Foo instantiated with new&quot; Reflect.defineProperty精确添加或修改对象上的属性，和 Object.defineProperty 类似。 Reflect.defineProperty(target, propertyKey, attributes) Object.defineProperty 返回结果为第一个参数对象，而 Reflect.defineProperty 返回结果为布尔型，表示操作是否成功，两者检查操作结果方式如下： // Object.definePropertytry &#123; Object.defineProperty(obj, name, desc); // success&#125; catch (e) &#123; // failure&#125;// Reflect.definePropertyif (Reflect.defineProperty(obj, name, desc)) &#123; // success&#125; else &#123; // failure&#125; Reflect.deleteProperty删除对象的某个属性，类似于执行 delete target[name]，区别在于一个是操作符，一个是函数调用。 Reflect.deleteProperty(target, propertyKey) // 使用 deletedelete &#123;foo: 1&#125;.foo; // true；// 使用 Reflect.deletePropertyReflect.deleteProperty(&#123;foo: 1&#125;, &quot;foo&quot;); // true//freeze objectdelete Object.freeze(&#123;foo: 1&#125;).foo; // falseReflect.deleteProperty(Object.freeze(&#123;foo: 1&#125;), &quot;foo&quot;); // false Reflect.enumerate已过时 Reflect.get获取对象上某个属性的值，类似于 target[propertyKey]。 Reflect.get(target, propertyKey[, receiver]) target: 目标对象 propertyKey: 需要获取的值的键值 [receiver]: 可省略，如果遇到 getter，则 getter 中 this 指向的上下文为 receiver 。 return[Any]: 任意类型 Reflect.get(&#123;x: 1, y: 2&#125;, x) // 1Reflect.get([1, 2, 3], 0) // 1Reflect.get(&quot;asdf&quot;, 0) // TypeError。参数 target 类型只能是 ObjectReflect.get(new String(&quot;asdf&quot;), 0) // a 注意：第三个参数表示使用指定的 receiver，表示指定的 getter 中存在的 this 指向的上下文: var foo = &#123; _val : &#x27;foo&#x27;, get val() &#123; return &#x27;value: &#x27; + this._val; &#125;&#125;;var bar = &#123; _val : &#x27;bar&#x27;, get val() &#123; return &#x27;value: &#x27; + this._val; &#125;&#125;;console.log(Reflect.get(foo, &quot;val&quot;)); // value: fooconsole.log(Reflect.get(foo, &quot;val&quot;, bar)); // value: bar,foo.val() 中的 this 指向 bar Reflect.set设置对象身上某个属性的值，类似于 target[name] = val。 Reflect.set(target, propertyKey, value[, receiver]) target: 目标对象 propertyKey: 需要获取的值的键值 [receiver]: 可省略，如果遇到 setter，则 setter 中 this 指向的上下文为 receiver 。 return[Boolean]: 任意类型 var obj = &#123; val: 1&#125;obj.val // 1Reflect.set(obj, &#x27;val&#x27;, 2);obj.val // 2Reflect.set(obj, &#x27;setval&#x27;, 3);obj.val // 3 注意：第三个参数表示使用指定的 receiver，表示指定的 setter 中存在的 this 指向的上下文: var foo = &#123; val: 1, set setval(value) &#123; return this.val = value; &#125;,&#125;var bar = &#123; val: 2,&#125;foo.val // 1bar.val // 2Reflect.set(foo, &#x27;setval&#x27;, 3, bar);foo.val // 1bar.val // 3 如果第一个参数不是对象，Reflect.set 会报错。 Reflect.getOwnPropertyDescriptor如果属性在对象中存在，则返回给定的属性的属性描述符，否则返回 undefined。类似于 Object.getOwnPropertyDescriptor()，唯一不同在于 Object 对非对象参数会进行强制类型转换，Reflect 会抛出 TypeError 异常。 Reflect.getOwnPropertyDescriptor(target, propertyKey) Reflect.getOwnPropertyDescriptor(&#123;x: &quot;hello&quot;&#125;, &quot;x&quot;);Object.getOwnPropertyDescriptor(&#123;x:&quot;1&quot;&#125;, &quot;x&quot;);// 都返回 Object &#123;value: &quot;hello&quot;, writable: true, enumerable: true, configurable: true&#125; 这两个的区别是 Object.getOwnPropertyDescriptor 会包装非对象参数，将其强制转换为对象， Reflect.getOwnPropertyDescriptor 会抛出 TypeError 异常： Reflect.getOwnPropertyDescriptor(&quot;x&quot;, 0); //抛出异常: Uncaught TypeError: Reflect.getOwnPropertyDescriptor called on non-objectObject.getOwnPropertyDescriptor(&quot;x&quot;, 0); //返回 Object &#123;value: &quot;x&quot;, writable: false, enumerable: true, configurable: false&#125; Reflect.getPrototypeOf返回指定对象的原型。类似于 Object.getPrototypeOf，唯一不同在于 Object 对非对象参数会进行强制类型转换，Reflect 会抛出 TypeError 异常。 Reflect.getPrototypeOf(target) var proto = &#123;&#125;;var obj = Object.create(proto);Object.getPrototypeOf(obj) === proto; // trueReflect.getPrototypeOf(obj) === proto; // true 如果参数为非对象，将抛出 TypeError 异常，而 Object.isExtensible 会将其强制转换为一个对象： Object.isExtensible(1); // falseReflect.isExtensible(1); // Uncaught TypeError: Reflect.isExtensible called on non-object Reflect.setPrototypeOf给对象设置原型， 即更改对象的 __proto__ 属性。类似于 Object.setPrototypeOf()。 Reflect.setPrototypeOf(target, prototype) 注意：如果第一个非对象参数 Object 会对直接返回该参数，Reflect 会抛出 TypeError 异常： Object.setPrototypeOf(1, &#123;&#125;); //1Reflect.setPrototypeOf(1, &#123;&#125;);// Uncaught TypeError: Reflect.setPrototypeOf called on non-object 注意：prototype 只能为 Object 或者 null，否则也会抛出 TypeError 异常： Object.setPrototypeOf(&#123;&#125;, 1);// Uncaught TypeError: Object prototype may only be an Object or nullReflect.setPrototypeOf(&#123;&#125;, 1);// Uncaught TypeError: Object prototype may only be an Object or null Reflect.has判断一个对象是否存在某个属性，和 in 操作符 的功能相同 Reflect.has(target, propertyKey) var obj = &#123; foo: &#x27;foo&#x27;,&#125;;// 使用 in 操作符&#x27;foo&#x27; in obj // true// 使用 Reflect.hasReflect.has(obj, &#x27;foo&#x27;) // true Reflect.isExtensible判断一个对象是否可以扩展。类似于 Object.isExtensible，唯一不同在于 Object 对非对象参数会进行强制类型转换，Reflect 会抛出 TypeError 异常。 Reflect.isExtensible(target) var obj = &#123;&#125;;Object.isExtensible(obj); // trueReflect.isExtensible(obj); // true// 阻止对象扩展Reflect.preventExtensions(obj); Object.isExtensible(obj); // falseReflect.isExtensible(obj); // false// 被冻结的对象不可扩展obj = Object.freeze(&#123;&#125;)Object.isExtensible(obj); // falseReflect.isExtensible(obj); // false// 被密封的对象不可扩展obj = Object.seal(&#123;&#125;)Object.isExtensible(obj); // falseReflect.isExtensible(obj); // false Reflect.ownKeys返回一个包含所有自身属性（不包含继承属性）的数组。Object 对象不存在这个方法，而是提供两个独立的方法：getOwnPropertyNames 和 getOwnPropertySymbols 。Reflect.ownKeys 返回值等同于 Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target))。 Reflect.ownKeys(target) var obj = &#123; 1: 1, 2: 2, a: &#x27;a&#x27;, b: &#x27;b&#x27;, [Symbol(&#x27;c&#x27;)]: &#x27;c&#x27;, [Symbol(&#x27;d&#x27;)]: &#x27;d&#x27;&#125;Object.getOwnPropertyNames(obj).concat(Object.getOwnPropertySymbols(obj));// [&quot;1&quot;, &quot;2&quot;, &quot;a&quot;, &quot;b&quot;, Symbol(c), Symbol(d)]Reflect.ownKeys(obj);// [&quot;1&quot;, &quot;2&quot;, &quot;a&quot;, &quot;b&quot;, Symbol(c), Symbol(d)] Reflect.preventExtensions用于让一个对象变为不可扩展，返回布尔值，表示是否操作成功，类似于 Object.preventExtensions， Object 对非对象参数会进行强制类型转换，Reflect 会抛出 TypeError 异常。 Reflect.preventExtensions(target) var obj = &#123;&#125;;Reflect.isExtensible(obj); // trueReflect.preventExtensions(obj); // trueReflect.isExtensible(obj); // false 这两个函数都只能阻止一个对象不能再添加新的自身属性，仍然可以为该对象的原型添加属性: var obj = &#123;&#125;;var proto = &#123;&#125;obj.a = &quot;a&quot;;obj.__proto__ = proto;Reflect.preventExtensions(obj); // trueobj.b = &quot;b&quot;;console.log(obj.b); // undefinedproto.b = &quot;b&quot;console.log(obj.b); // b 注意：使用 Object.defineProperty 或 Reflect.defineProperty 方法为一个不可扩展的对象添加新属性会抛出异常： var obj = &#123; removable: true &#125;;Reflect.preventExtensions(obj);Reflect.defineProperty(obj, &quot;new&quot;, &#123; value: 1 &#125;); // 抛出TypeError异常Object.defineProperty(obj, &quot;new&quot;, &#123; value: 1 &#125;); // 抛出TypeError异常 注意：在严格模式下，为不可扩展对象添加新属性会抛出TypeError异常： var obj = &#123; removable: true &#125;;Reflect.preventExtensions(obj);function fail() &#123; &quot;use strict&quot;; obj.newProperty = &quot;FAIL&quot;;&#125;fail(); // throws a TypeError 总结Reflect 上的几乎所有操作都是原本存在的操作， Reflect 对其做了统一的整合，具有以下优点： 将对象上的操作函数化过去的某些对象上的操作是命令式的，如 name in obj、 delete obj[name], Reflect 将这些操作统一为函数调用 name in obj// 使用 ReflectReflect.has(obj, &#x27;name&#x27;)delete obj[name]// 使用 ReflectReflect.deleteProperty(obj, &#x27;name&#x27;) 更有用的返回值Reflect 上有好些方法和 Object 上的一样，但是修改了返回的结果，比如 Object.defineProperty 在无法定义属性时，会抛出错误， Reflect 则返回 false // Object.definePropertytry &#123; Object.defineProperty(obj, name, desc); // success&#125; catch (e) &#123; // failure&#125;// Reflect.definePropertyif (Reflect.defineProperty(obj, name, desc)) &#123; // success&#125; else &#123; // failure&#125; 其他相似的方法如 Reflect.deleteProperty、 Reflect.preventExtensions、 Relect.set 、 Reflect.setPrototypeOf 也是如此。 控制访问器中 this 的绑定Reflect.get 和 Reflect.set 通过提供额外的第三个参数 receiver 可以方便的控制访问器 getter 和 setter 中的 this 的指向，比如在访问器中不想使用自己的属性或方法，而是使用包装器的属性或方法： var obj = &#123; set foo(value) &#123; return this.bar(); &#125;, bar: function() &#123; console.log(&quot;obj&quot;); &#125;&#125;;var wrapper = &#123; bar : function() &#123; console.log(&quot;wrapper&quot;); &#125;&#125;Reflect.set(obj, &quot;foo&quot;, &quot;value&quot;, wrapper); 提供和 Proxy 一一对应的方法Proxy 对象支持的所有方法都可以在 Reflect 上找到，Proxy 对象可以方便地调用对应的 Reflect 方法，执行基础的操作。同时，不论 Proxy 做了怎样的修改，都可以通过 Reflect 获取原始行为。 浏览器兼容性 Chrome Edge Firefox IE Opera Safari 49.0 Yes 42.0 未实现 未实现 10 参考 MDN ECMAScript 6 入门-阮一峰 Metaprogramming in ES6: Part 2 - Reflect Here are a number of reasons why the Reflect object is useful","categories":[{"name":"js","slug":"js","permalink":"http://tcatche.site/categories/js/"}],"tags":[{"name":"es","slug":"es","permalink":"http://tcatche.site/tags/es/"}]},{"title":"createStore.js 源码阅读笔记","slug":"createStore","date":"2017-03-07T08:09:00.000Z","updated":"2018-08-01T10:41:24.000Z","comments":true,"path":"2017/03/createStore/","link":"","permalink":"http://tcatche.site/2017/03/createStore/","excerpt":"","text":"接口 createStore(reducer, [preloadedState], enhancer) reducer (Function): 接收 state 和 action 参数的函数，并返回新的 state。 [preloadedState(Any)]: 初始时的 state，可以使用空内容初始化，也可以使用保存在客户端或者服务端的 state 初始化。如果 reducer 是使用 combinedReducers 生成的，则state 只能是普通对象，不能是其他的特殊对象，如 immutable 对象等。 enhancer (Function): enhancer 是一个强化的。 return (Object): 返回应用的 Store ,包含几个函数的对象。 源码结构createStore 的代码看起来很多，内容非常简单，先看一下整体结构： export default function createStore(reducer, preloadedState, enhancer) &#123; // 获取应用当前的 state function getState() &#123; &#125; // 事件监听 function subscribe(listener) &#123; &#125; // 事件触发 function dispatch(action) &#123; &#125; // 修改应用的 reducer function replaceReducer(nextReducer) &#123; &#125; function observable() &#123; &#125; return &#123; dispatch, subscribe, getState, replaceReducer, [$$observable]: observable &#125;&#125; 调用 createStore 就是返回了一个对象，对象主要包括这五个函数，createStore 代码很简单，b不再一一说明，注意点直接放在下一节源码注释中： 源码注释源代码如下： import isPlainObject from &#x27;lodash/isPlainObject&#x27;import $$observable from &#x27;symbol-observable&#x27;/** * These are private action types reserved by Redux. * For any unknown actions, you must return the current state. * If the current state is undefined, you must return the initial state. * Do not reference these action types directly in your code. * 定义一个初始化 action， 这个 action 是 redux 私有的，不应该被引用 * 同时 reducer 对于未知的 action 应该返回当前的 state 不作任何处理 */export var ActionTypes = &#123; INIT: &#x27;@@redux/INIT&#x27;&#125;/** * Creates a Redux store that holds the state tree. * The only way to change the data in the store is to call `dispatch()` on it. * * There should only be a single store in your app. To specify how different * parts of the state tree respond to actions, you may combine several reducers * into a single reducer function by using `combineReducers`. * * @param &#123;Function&#125; reducer A function that returns the next state tree, given * the current state tree and the action to handle. * * @param &#123;any&#125; [preloadedState] The initial state. You may optionally specify it * to hydrate the state from the server in universal apps, or to restore a * previously serialized user session. * If you use `combineReducers` to produce the root reducer function, this must be * an object with the same shape as `combineReducers` keys. * * @param &#123;Function&#125; enhancer The store enhancer. You may optionally specify it * to enhance the store with third-party capabilities such as middleware, * time travel, persistence, etc. The only store enhancer that ships with Redux * is `applyMiddleware()`. * * @returns &#123;Store&#125; A Redux store that lets you read the state, dispatch actions * and subscribe to changes. */export default function createStore(reducer, preloadedState, enhancer) &#123; // 可省略的参数处理，如果 preloadedState 省略 则把第二个参数作为 enhancer if (typeof preloadedState === &#x27;function&#x27; &amp;&amp; typeof enhancer === &#x27;undefined&#x27;) &#123; enhancer = preloadedState preloadedState = undefined &#125; // 存在 `enhancer` 则使用 `enhancer(createStore)` 创建 store， `enhancer` 通常接受 `createStore` // 做为参数，并返回一个以 `reducer` 、 `preloadedState` 为参数的 `enhanceredCreateStore` ，也就是说 // 签名为 `createStore =&gt; (reducer, preloadedState) =&gt; store`。 // enhancer(createStore) 通常是在 createStore 创建的 store 上做了一些修改，比如 `applyMiddleware` // 只是修改了 dispatch 方法，其他保持不变，具体可以参考 `applyMiddleware.js 源码阅读笔记`。 // // 常用的 `enhancer` 比如: `applyMiddleware(...middlewares)` // 如果需要应用多个 enhancers 可以使用 `compose` 组合这些 enhancers: // createStore(reducer, preloadedState, compose(enhancer1, enhancer2, ...))。 if (typeof enhancer !== &#x27;undefined&#x27;) &#123; if (typeof enhancer !== &#x27;function&#x27;) &#123; throw new Error(&#x27;Expected the enhancer to be a function.&#x27;) &#125; return enhancer(createStore)(reducer, preloadedState) &#125; if (typeof reducer !== &#x27;function&#x27;) &#123; throw new Error(&#x27;Expected the reducer to be a function.&#x27;) &#125; var currentReducer = reducer var currentState = preloadedState // 当前监听的事件列表 var currentListeners = [] // 新的事件监听列表 // 之所以使用两个变量保存 `listeners` 是为了防止 `dispatch` 的时候 `subscribe` 和 `unsubscribe` // 对 `listeners` 列表改变，造成不可预知的结果 var nextListeners = currentListeners // 防止这次 dispatch 未完成即进行下一次 dispatch，造成 state 错误 var isDispatching = false /** * 如果下一个监听的事件列表等于当前的事件列表，则复制当前的事件列表。 * 这个主要是保证 dispatch 执行的时候，如果 subscribe 或者 unsubscribe 事件时，不至于 * 影响到当前正在执行中的事件序列。 * 在每次列表变化的时候都会被调用，每次列表的改变都在下一次 dispatch 时生效 */ function ensureCanMutateNextListeners() &#123; if (nextListeners === currentListeners) &#123; nextListeners = currentListeners.slice() &#125; &#125; /** * Reads the state tree managed by the store. * * @returns &#123;any&#125; The current state tree of your application. * 返回应用当前的 state */ function getState() &#123; return currentState &#125; /** * Adds a change listener. It will be called any time an action is dispatched, * and some part of the state tree may potentially have changed. You may then * call `getState()` to read the current state tree inside the callback. * * You may call `dispatch()` from a change listener, with the following * caveats: * * 1. The subscriptions are snapshotted just before every `dispatch()` call. * If you subscribe or unsubscribe while the listeners are being invoked, this * will not have any effect on the `dispatch()` that is currently in progress. * However, the next `dispatch()` call, whether nested or not, will use a more * recent snapshot of the subscription list. * * 2. The listener should not expect to see all state changes, as the state * might have been updated multiple times during a nested `dispatch()` before * the listener is called. It is, however, guaranteed that all subscribers * registered before the `dispatch()` started will be called with the latest * state by the time it exits. * * @param &#123;Function&#125; listener A callback to be invoked on every dispatch. * @returns &#123;Function&#125; A function to remove this change listener. * * 注意： * 1. 函数返回一个取消订阅当前监听函数的函数 * 2. 每次事件列表的改变都在下一次 dispatch 时生效，如果当前正在执行 dispatch 函数， * 则新增加的事件订阅不会立即生效，取消事件订阅也是一样 * 3. 事件监听不应该监听全部的 state 的变化，因为在监听的函数执行之时 state 可能会被改变多次 */ function subscribe(listener) &#123; if (typeof listener !== &#x27;function&#x27;) &#123; throw new Error(&#x27;Expected listener to be a function.&#x27;) &#125; var isSubscribed = true ensureCanMutateNextListeners() nextListeners.push(listener) //返回一个取消订阅当前监听函数的函数 return function unsubscribe() &#123; if (!isSubscribed) &#123; return &#125; isSubscribed = false ensureCanMutateNextListeners() //从事件列表中找到刚才添加的，并删除 var index = nextListeners.indexOf(listener) nextListeners.splice(index, 1) &#125; &#125; /** * Dispatches an action. It is the only way to trigger a state change. * * The `reducer` function, used to create the store, will be called with the * current state tree and the given `action`. Its return value will * be considered the **next** state of the tree, and the change listeners * will be notified. * * The base implementation only supports plain object actions. If you want to * dispatch a Promise, an Observable, a thunk, or something else, you need to * wrap your store creating function into the corresponding middleware. For * example, see the documentation for the `redux-thunk` package. Even the * middleware will eventually dispatch plain object actions using this method. * * @param &#123;Object&#125; action A plain object representing “what changed”. It is * a good idea to keep actions serializable so you can record and replay user * sessions, or use the time travelling `redux-devtools`. An action must have * a `type` property which may not be `undefined`. It is a good idea to use * string constants for action types. * @returns &#123;Object&#125; For convenience, the same action object you dispatched. * * Note that, if you use a custom middleware, it may wrap `dispatch()` to * return something else (for example, a Promise you can await). * 注意： * 1. dispatch 默认只支持 action 作为参数，但是使用了中间件以后，比如 `redux-thunk` * 中间件，指定格式的 function 也被支持作为参数。 * 2. dispatch 的默认返回值是参数中的 action， 但是如果使用了中间件，dispatch 之前和 * 之后可能会执行中间件的一些操作，并且返回值也可能被修改。 * * 以下情况会抛出异常： * 1. `action` 不是一个简单对象 * 2. `action.type` 不存在 * 3. `action` 正在 `dispatching` 然后再次 `dispatch`， 这种情况主要发生在异步 `reducer` */ function dispatch(action) &#123; if (!isPlainObject(action)) &#123; throw new Error( &#x27;Actions must be plain objects. &#x27; + &#x27;Use custom middleware for async actions.&#x27; ) &#125; if (typeof action.type === &#x27;undefined&#x27;) &#123; throw new Error( &#x27;Actions may not have an undefined &quot;type&quot; property. &#x27; + &#x27;Have you misspelled a constant?&#x27; ) &#125; if (isDispatching) &#123; throw new Error(&#x27;Reducers may not dispatch actions.&#x27;) &#125; try &#123; isDispatching = true //更新 store 的 state currentState = currentReducer(currentState, action) &#125; finally &#123; isDispatching = false &#125; //保证当前执行的是最新的事件序列 var listeners = currentListeners = nextListeners //逐个调用订阅的事件，比如 state 改变了更新ui for (var i = 0; i &lt; listeners.length; i++) &#123; listeners[i]() &#125; return action &#125; /** * Replaces the reducer currently used by the store to calculate the state. * * You might need this if your app implements code splitting and you want to * load some of the reducers dynamically. You might also need this if you * implement a hot reloading mechanism for Redux. * * 使用新的 reducer 替代 store 当前的 reducer，主要用于一些动态加载的内容， * 比如 webpack 的代码分割功能或者 redux 的代码热更新。 * @param &#123;Function&#125; nextReducer The reducer for the store to use instead. * @returns &#123;void&#125; */ function replaceReducer(nextReducer) &#123; if (typeof nextReducer !== &#x27;function&#x27;) &#123; throw new Error(&#x27;Expected the nextReducer to be a function.&#x27;) &#125; currentReducer = nextReducer //使用了新的 reducer 时，仍然会 `dispatch(&#123; type: ActionTypes.INIT &#125;)` 。 dispatch(&#123; type: ActionTypes.INIT &#125;) &#125; //待补充：这部分内容研究后稍后补充 /** * Interoperability point for observable/reactive libraries. * @returns &#123;observable&#125; A minimal observable of state changes. * For more information, see the observable proposal: * https://github.com/zenparsing/es-observable * ECMAScript标准库引入了一个Observable类型的提案。 * Observable类型可用于建模基于推送的数据源，例如DOM事件，定时器间隔和 socket */ function observable() &#123; var outerSubscribe = subscribe return &#123; /** * The minimal observable subscription method. * @param &#123;Object&#125; observer Any object that can be used as an observer. * The observer object should have a `next` method. * @returns &#123;subscription&#125; An object with an `unsubscribe` method that can * be used to unsubscribe the observable from the store, and prevent further * emission of values from the observable. */ subscribe(observer) &#123; if (typeof observer !== &#x27;object&#x27;) &#123; throw new TypeError(&#x27;Expected the observer to be an object.&#x27;) &#125; function observeState() &#123; if (observer.next) &#123; observer.next(getState()) &#125; &#125; observeState() var unsubscribe = outerSubscribe(observeState) return &#123; unsubscribe &#125; &#125;, [$$observable]() &#123; return this &#125; &#125; &#125; // When a store is created, an &quot;INIT&quot; action is dispatched so that every // reducer returns their initial state. This effectively populates // the initial state tree. // 在createStore的时候，函数内部会dispatch(&#123; type: ActionTypes.INIT &#125;) // 对 state 进行初始化，这也就是说为什么我们的 reducer 需要在 state 为空的时候初始化， //并且能够处理不存在的 action（不要引入处理这个 ActionTypes.INIT 这个 action，而是 //用默认的方式，比如 switch 语句中的 default 分支， 处理返回当前的非空的 store） dispatch(&#123; type: ActionTypes.INIT &#125;) //返回的操作接口 return &#123; dispatch, subscribe, getState, replaceReducer, [$$observable]: observable &#125;&#125; 相关Redux 源码阅读笔记： createStore.js 源码阅读笔记 combineReducers.js 源码阅读笔记 bindActionCreators.js 源码阅读笔记 applyMiddleware.js 源码阅读笔记 compose.js 源码阅读笔记 参考本文阅读代码版本 3.5.2 redux源代码 redux文档","categories":[{"name":"js","slug":"js","permalink":"http://tcatche.site/categories/js/"}],"tags":[{"name":"react","slug":"react","permalink":"http://tcatche.site/tags/react/"},{"name":"redux","slug":"redux","permalink":"http://tcatche.site/tags/redux/"}]},{"title":"combineReducers.js 源码阅读笔记","slug":"combineReducers","date":"2017-03-03T10:25:00.000Z","updated":"2018-08-01T10:41:24.000Z","comments":true,"path":"2017/03/combineReducers/","link":"","permalink":"http://tcatche.site/2017/03/combineReducers/","excerpt":"","text":"The combineReducers helper function turns an object whose values are different reducing functions into a single reducing function you can pass to createStore. 接口 combineReducers(reducers) reducers (Object): reducers 是一个对象，它的值对应要混合的各个 reducer 。 return (Function): 多个独立的 reducer 合并后的最终的 finalReducers， 这个 finalReducers 的签名和 reducer 一样，接收 state 和action 做为参数，然后调用 所有 reducer 处理 action ，并把各个 reducer 处理 state 结果合成最终的新的 state ，并且返回的 state 的结构和传入的 reducers 参数对象的结构一致。 分析当应用复杂起来以后，必然要对 reducer 进行拆分，否则全部放在一起的 reducer 难以维护。而拆分后的 reducer 负责维护一部分的 state。 combineReducers 的作用就是把多个 reducer 的函数合并成一个最终的 reducer 函数，然后就可以使用这个函数管理 store，先看个示例： //将 reducer 拆分成两个：const todoReducer = (state = [], action) =&gt; &#123; switch (action.type) &#123; case &#x27;ADD_TODO&#x27;: return state.concat([action.text]) default: return state &#125;&#125;const counterReducer = (state = 0, action) =&gt; &#123; switch (action.type) &#123; case &#x27;INCREMENT&#x27;: return state + 1 case &#x27;DECREMENT&#x27;: return state - 1 default: return state &#125;&#125;//将拆分过的两个 reducer 合并const combinedReducers = combineReducers(&#123; todos: todoReducer, counter: counterReducer&#125;)let store = createStore(combinedReducers)console.log(store.getState())//store 结构：&#123;todos: [], counter: 0&#125; 如上示例，我们调用 combinedReducers 得到的 store 的结构和 传递给 combinedReducers 的对象的结构一致，接下来我们修改 state： store.dispatch(&#123; type: &#x27;ADD_TODO&#x27;, text: &#x27;Use Redux&#x27;&#125;)console.log(store.getState())//store 结构：&#123;todos: [&#x27;Use Redux&#x27;], counter: 0&#125; 阅读代码后不难发现，combinedReducers 处理 state 可以认为是进行了以下操作： store.dispatch(action);store = &#123; todos: todoReducer(store[todos], action), counter: todoReducer(store[counter], action), ... others: othersReducer(store[others], action)&#125; combineReducers 对传入的 reducer 约定了一些必须遵守的规则： 如果接收到的 state 是 undefined ，必须对其初始化。 reducer 不允许返回 undefined，否则会抛出异常。 如果 reducer 未匹配到传入的 action 则最好返回接收到的原始 store。 combineReducers 操作的 state 必须是普通对象，不能是其他的特殊对象，如 immutable 对象等。 当然不仅仅在使用 combineReducers 是遵守这些规则，使用自定义的类似的 工具函数的时候最好也要遵守这些习惯。 源码注释源代码如下，加了阅读注释： import &#123; ActionTypes &#125; from &#x27;./createStore&#x27;import isPlainObject from &#x27;lodash/isPlainObject&#x27;import warning from &#x27;./utils/warning&#x27;//action 没有 对应处理的 reducer 时候返回的错误信息function getUndefinedStateErrorMessage(key, action) &#123; var actionType = action &amp;&amp; action.type var actionName = actionType &amp;&amp; `&quot;$&#123;actionType.toString()&#125;&quot;` || &#x27;an action&#x27; return ( `Given action $&#123;actionName&#125;, reducer &quot;$&#123;key&#125;&quot; returned undefined. ` + `To ignore an action, you must explicitly return the previous state.` )&#125;// state 和 reducer 检查:// 1. reducers 至少有一个成员 reducer，不能使空对象// 2. inputState 必须是简单对象// 3. inputState 中的属性，必须在 reducers 中存在同属性名的 reducerfunction getUnexpectedStateShapeWarningMessage(inputState, reducers, action) &#123; var reducerKeys = Object.keys(reducers) var argumentName = action &amp;&amp; action.type === ActionTypes.INIT ? &#x27;preloadedState argument passed to createStore&#x27; : &#x27;previous state received by the reducer&#x27; // combineReducers 接收的参数对象至少需要又有一个 reducer if (reducerKeys.length === 0) &#123; return ( &#x27;Store does not have a valid reducer. Make sure the argument passed &#x27; + &#x27;to combineReducers is an object whose values are reducers.&#x27; ) &#125; // inputState 是否是一个简单对象 // 简单对象是指 通过 &quot;&#123;&#125;&quot; 或者 &quot;new Object&quot; 创建的键值对的集合 if (!isPlainObject(inputState)) &#123; return ( `The $&#123;argumentName&#125; has unexpected type of &quot;` + (&#123;&#125;).toString.call(inputState).match(/\\s([a-z|A-Z]+)/)[1] + `&quot;. Expected argument to be an object with the following ` + `keys: &quot;$&#123;reducerKeys.join(&#x27;&quot;, &quot;&#x27;)&#125;&quot;` ) &#125; //判断 inputState 中是否存在 key ，在 reducers 中不存在 var unexpectedKeys = Object.keys(inputState).filter(key =&gt; !reducers.hasOwnProperty(key)) if (unexpectedKeys.length &gt; 0) &#123; return ( `Unexpected $&#123;unexpectedKeys.length &gt; 1 ? &#x27;keys&#x27; : &#x27;key&#x27;&#125; ` + `&quot;$&#123;unexpectedKeys.join(&#x27;&quot;, &quot;&#x27;)&#125;&quot; found in $&#123;argumentName&#125;. ` + `Expected to find one of the known reducer keys instead: ` + `&quot;$&#123;reducerKeys.join(&#x27;&quot;, &quot;&#x27;)&#125;&quot;. Unexpected keys will be ignored.` ) &#125;&#125;// reducers 合法性检查函数，主要检查要求以下几点：// 1. 调用 reducer 返回值不允许为 undefined// 2. reducer 在初次调用时，即被传入类型为 ActionTypes.INIT 的 action 需要对 state 初始化// 3. 不要处理 redux/* 这个命名空间下的action 直接返回 currentState，// 这一点代码未做检查，但是需要注意，自定义的 action type 最好不要用这个命名空间function assertReducerSanity(reducers) &#123; Object.keys(reducers).forEach(key =&gt; &#123; var reducer = reducers[key] var initialState = reducer(undefined, &#123; type: ActionTypes.INIT &#125;) // 此处检查 reducer 是否处理值为 undefined 的 state，如果未处理，即 reducer 返回 undefined 抛出异常 // 按照约定，当传递给reducer的state为 undefined 时，通常在初始化的时候，reducer第一次被调用时， // state 为 undefined， 此时 reducer 需要给 state 一个默认值， 而不能返回 undefined。 if (typeof initialState === &#x27;undefined&#x27;) &#123; throw new Error( `Reducer &quot;$&#123;key&#125;&quot; returned undefined during initialization. ` + `If the state passed to the reducer is undefined, you must ` + `explicitly return the initial state. The initial state may ` + `not be undefined.` ) &#125; // 声明一种随机的 action type，确保不会有人使用这种action // 使用这么奇怪的 action 是为了检查，当传入 reducer 不认识的 action type 时，reducer 会不应该返回 undefined。 // 实际上，按照约定，当传入不认识的 action type 或者想要忽视的action type 时，返回 current state 即可 // 同时，警告信息还指出不应该处理任何 redux/* ，命名空间下的 action，除非 current state 为 undefined 的时候，需要做初始化。 var type = &#x27;@@redux/PROBE_UNKNOWN_ACTION_&#x27; + Math.random().toString(36).substring(7).split(&#x27;&#x27;).join(&#x27;.&#x27;) if (typeof reducer(undefined, &#123; type &#125;) === &#x27;undefined&#x27;) &#123; throw new Error( `Reducer &quot;$&#123;key&#125;&quot; returned undefined when probed with a random type. ` + `Don&#x27;t try to handle $&#123;ActionTypes.INIT&#125; or other actions in &quot;redux/*&quot; ` + `namespace. They are considered private. Instead, you must return the ` + `current state for any unknown actions, unless it is undefined, ` + `in which case you must return the initial state, regardless of the ` + `action type. The initial state may not be undefined.` ) &#125; &#125;)&#125;/** * Turns an object whose values are different reducer functions, into a single * reducer function. It will call every child reducer, and gather their results * into a single state object, whose keys correspond to the keys of the passed * reducer functions. * * @param &#123;Object&#125; reducers An object whose values correspond to different * reducer functions that need to be combined into one. One handy way to obtain * it is to use ES6 `import * as reducers` syntax. The reducers may never return * undefined for any action. Instead, they should return their initial state * if the state passed to them was undefined, and the current state for any * unrecognized action. * * @returns &#123;Function&#125; A reducer function that invokes every reducer inside the * passed object, and builds a state object with the same shape. */export default function combineReducers(reducers) &#123; var reducerKeys = Object.keys(reducers) var finalReducers = &#123;&#125; // 把多个 reducers 合并到 finalReducers 对象中 for (var i = 0; i &lt; reducerKeys.length; i++) &#123; var key = reducerKeys[i] if (typeof reducers[key] === &#x27;function&#x27;) &#123; finalReducers[key] = reducers[key] &#125; &#125; var finalReducerKeys = Object.keys(finalReducers) // 对 reducers 合法性进行检查 var sanityError try &#123; assertReducerSanity(finalReducers) &#125; catch (e) &#123; sanityError = e &#125; return function combination(state = &#123;&#125;, action) &#123; // reducers 合法性检查存在异常抛出 if (sanityError) &#123; throw sanityError &#125; // state 和 reducer 检查: // 1. reducers 至少有一个成员 reducer，不能使空对象 // 2. inputState 必须是简单对象 // 3. inputState 中的属性，必须在 reducers 中存在同属性名的 reducer // 非生产环境下打印警告日志 if (process.env.NODE_ENV !== &#x27;production&#x27;) &#123; var warningMessage = getUnexpectedStateShapeWarningMessage(state, finalReducers, action) if (warningMessage) &#123; warning(warningMessage) &#125; &#125; // 最终 nextState 对象的结构和 finalReducers 的结构一致 var hasChanged = false var nextState = &#123;&#125; // 遍历 finalReducers ，为 finalReducers 的每个成员调用 reducer(subState, action) for (var i = 0; i &lt; finalReducerKeys.length; i++) &#123; var key = finalReducerKeys[i] var reducer = finalReducers[key] var previousStateForKey = state[key] var nextStateForKey = reducer(previousStateForKey, action) if (typeof nextStateForKey === &#x27;undefined&#x27;) &#123; var errorMessage = getUndefinedStateErrorMessage(key, action) throw new Error(errorMessage) &#125; nextState[key] = nextStateForKey hasChanged = hasChanged || nextStateForKey !== previousStateForKey &#125; return hasChanged ? nextState : state &#125;&#125; 相关Redux 源码阅读笔记： createStore.js 源码阅读笔记 combineReducers.js 源码阅读笔记 bindActionCreators.js 源码阅读笔记 applyMiddleware.js 源码阅读笔记 compose.js 源码阅读笔记 参考本文阅读代码版本 3.5.2 redux源代码 redux文档","categories":[{"name":"js","slug":"js","permalink":"http://tcatche.site/categories/js/"}],"tags":[{"name":"react","slug":"react","permalink":"http://tcatche.site/tags/react/"},{"name":"redux","slug":"redux","permalink":"http://tcatche.site/tags/redux/"}]},{"title":"bindActionCreators.js 源码阅读笔记","slug":"bindActionCreators","date":"2017-03-01T06:32:00.000Z","updated":"2018-08-01T10:41:24.000Z","comments":true,"path":"2017/03/bindActionCreators/","link":"","permalink":"http://tcatche.site/2017/03/bindActionCreators/","excerpt":"","text":"Turns an object whose values are action creators, into an object with the same keys, but with every action creator wrapped into a dispatch call so they may be invoked directly. 接口 bindActionCreators(actionCreators, dispatch) actionCreators (Function | Object): action creator 函数，或者键值是 action creators 的对象。 dispatch (Function): dispatch action 的函数。 return (Function | Object): 返回一个 dispatcher 函数或者对象，对象的每个属性值都是一个 dispatcher, 即可以dispatch action 的函数 理解bindActionCreators 文档里是这么说的：把 action creators 转换成有相同 keys 的对象，并把每个 action creator 使用 dispatch 包围起来，这样可以直接调用它们。 这种说法听起来很绕口，先看个例子： var addTodo = todo =&gt; (&#123; type: &#x27;ADD_TODO&#x27;, todo&#125;);var removeTodo = todo =&gt; (&#123; type: &#x27;REMOVE_TODO&#x27;, todo&#125;);var reducer = (state, action) =&gt; &#123; switch (action.type) &#123; case &#x27;ADD_TODO&#x27;: return state.add(action.text); case &#x27;REMOVE_TODO&#x27;: return state.remove(action.text); default: return state; &#125;&#125;;var store = redux.createStore(reducer, []); 这是一个很常见的 redux 的例子，我们触发 ADD_TODO 通过 store.dispatch(addTodo(&quot;To read.&quot;)),bindActionCreators 实际上就是对这个过程做了处理： // 单独为每个action创建：var addTodoDispatcher = bindActionCreators(TodoActionCreators, dispatch);var removeTodoDispatcher = bindActionCreators(TodoActionCreators, dispatch);// 或者组合为所有action创建：var todoDispatchers = bindActionCreators(&#123; addTodo: addTodo, removeTodo: removeTodo&#125;, dispatch); 这个时候可以通过 addTodoDispatcher(&quot;To read.&quot;) 或者 todoDispatchers.addTodo(&quot;To read.&quot;) 触发这个 action。 看起来这个只是省略了一个dispatch调用的代码，官方文档是这么说明的： The only use case for bindActionCreators is when you want to pass some action creators down to a component that isn’t aware of Redux, and you don’t want to pass dispatch or the Redux store to it.（惟一使用 bindActionCreators 的场景是当你需要把 action creator 往下传到一个组件上，却不想让这个组件觉察到 Redux 的存在，而且不希望把 Redux store 或 dispatch 传给它。） 也就是说它的主要应用场景是对某个组件隐藏 redux 的存在： // 不使用 bindActionCreators// 组件内调用 dispatch(addTodo(&quot;sth&quot;))、dispatch(addTodo(&quot;sth&quot;))// 组件需要了解 redux action 的触发方式&lt;TodoList todos=&#123;todos&#125; dispatch=&#123;dispatch&#125; addTodo=&#123;addTodo&#125; removeTodo=&#123;removeTodo&#125;/&gt;// 使用 bindActionCreators// 组件内调用 addTodo(&quot;sth&quot;)、removeTodo(&quot;sth&quot;)// 组件不需要知道 redux 的存在，直接调用函数&lt;TodoList todos=&#123;todos&#125; &#123;...todoDispatchers&#125; /&gt; 源码注释去除参数类型检查相关的一些代码后源代码如下： export default function bindActionCreators(actionCreators, dispatch) &#123; if (typeof actionCreators === &#x27;function&#x27;) &#123; return bindActionCreator(actionCreators, dispatch) &#125; // actionCreators 类型不是函数和对象 或者 actionCreators 是空，抛出异常 if (typeof actionCreators !== &#x27;object&#x27; || actionCreators === null) &#123; throw ... &#125; var keys = Object.keys(actionCreators) var boundActionCreators = &#123;&#125; for (var i = 0; i &lt; keys.length; i++) &#123; var key = keys[i] var actionCreator = actionCreators[key] // 当 actionCreators 类型是对象时 // 返回的对象仅保留其属性值类型为函数的属性，其他类型不保留 if (typeof actionCreator === &#x27;function&#x27;) &#123; boundActionCreators[key] = bindActionCreator(actionCreator, dispatch) &#125; &#125; return boundActionCreators&#125;function bindActionCreator(actionCreator, dispatch) &#123; return (...args) =&gt; dispatch(actionCreator(...args))&#125; 代码很简单，如果传递的 actionCreators 的类型是函数，则返回内容是一个 dispatcher，即： (...args) =&gt; dispatch(actionCreator(...args))，如果传递 actionCreators 的类型是一个对象，则返回一个相似结构的对象，只不过对象的每个属性值都是 dispatcher。 简单来说，如果 actionCreators 是 addTodo 返回值为 todo =&gt; dispatch(addTodo(todo)), 如果： // actionCreators 类型是函数var addTodoDispatcher = bindActionCreators(addTodo, dispatch);//等价于：var addTodoDispatcher = todo =&gt; dispatch(addTodo(todo));// actionCreators 类型是对象var todoDispatchers = bindActionCreators(&#123;addTodo, removeTodo, ..., otherTodo&#125;, dispatch);//等价于：var todoDispatchers = &#123; addTodo: todo =&gt; dispatch(addTodo(todo)), removeTodo: todo =&gt; dispatch(removeTodo(todo)), otherTodo: (...args) =&gt; dispatch(otherTodo(args)),&#125; 相关Redux 源码阅读笔记： createStore.js 源码阅读笔记 combineReducers.js 源码阅读笔记 bindActionCreators.js 源码阅读笔记 applyMiddleware.js 源码阅读笔记 compose.js 源码阅读笔记 参考本文阅读代码版本 3.5.2 redux源代码 redux文档","categories":[{"name":"js","slug":"js","permalink":"http://tcatche.site/categories/js/"}],"tags":[{"name":"react","slug":"react","permalink":"http://tcatche.site/tags/react/"},{"name":"redux","slug":"redux","permalink":"http://tcatche.site/tags/redux/"}]},{"title":"compose.js 源码阅读笔记","slug":"compose","date":"2017-03-01T06:32:00.000Z","updated":"2018-08-01T10:41:24.000Z","comments":true,"path":"2017/03/compose/","link":"","permalink":"http://tcatche.site/2017/03/compose/","excerpt":"","text":"Composes functions from right to left.. 接口 compose(…arguments) arguments (Function): 需要进行函数合成的多个函数，每个函数接收单一的参数，它的返回值将作为一个参数提供给它左边的函数调用，而最右边的函数可以接收多个参数，而它的签名将会作为组合后返回函数的签名。 return (Function): 返回把所有的参数从右向左合成的结果 函数组合组合是函数式编程的常用工具，我们在学习数学的时候会学到复合函数： f(x) = 2 * x;g(x) = x + 1;(f ∘ g)(x) = f(g(x)) = 2 * (x + 1) = 2 * x + 2; 可以很容易把这个组合形式扩展到组合更多的函数上，而函数组合就是将多个函组合成单个的新的函数的过程： var compose = function(f, g) &#123; return function(x) &#123; return f(g(x)); &#125;;&#125;; 和层层嵌套的函数调用相比较，函数组合创建了一个从右向左的数据流，数据的处理和流向非常清晰。 源码注释源代码如下： /** * Composes single-argument functions from right to left. The rightmost * function can take multiple arguments as it provides the signature for * the resulting composite function. * * @param &#123;...Function&#125; funcs The functions to compose. * @returns &#123;Function&#125; A function obtained by composing the argument functions * from right to left. For example, compose(f, g, h) is identical to doing * (...args) =&gt; f(g(h(...args))). * * 也就是说，组合实际上就是把 compose(f, g, h) 转换为 f(g(h(...args))) 其中...args 是 h 的参数 */export default function compose(...funcs) &#123; //没有参数返回一个不作任何变换的函数，即 f(x) = x ； if (funcs.length === 0) &#123; return arg =&gt; arg &#125; //只有一个函数参数，返回原参数 if (funcs.length === 1) &#123; return funcs[0] &#125; //利用 reduceRight 从右向左组合函数 //reduceRight 和 reduce 类似，只不过是从数组结尾向开始方向合并 const last = funcs[funcs.length - 1] const rest = funcs.slice(0, -1) return (...args) =&gt; rest.reduceRight((composed, f) =&gt; f(composed), last(...args))&#125; 相关Redux 源码阅读笔记： createStore.js 源码阅读笔记 combineReducers.js 源码阅读笔记 bindActionCreators.js 源码阅读笔记 applyMiddleware.js 源码阅读笔记 compose.js 源码阅读笔记 参考本文阅读代码版本 3.5.2 redux源代码 redux文档 JS函数式编程指南","categories":[{"name":"js","slug":"js","permalink":"http://tcatche.site/categories/js/"}],"tags":[{"name":"react","slug":"react","permalink":"http://tcatche.site/tags/react/"},{"name":"redux","slug":"redux","permalink":"http://tcatche.site/tags/redux/"}]},{"title":"applyMiddleware.js 源码阅读笔记","slug":"applyMiddleware","date":"2017-02-28T08:16:00.000Z","updated":"2020-07-22T02:19:41.733Z","comments":true,"path":"2017/02/applyMiddleware/","link":"","permalink":"http://tcatche.site/2017/02/applyMiddleware/","excerpt":"","text":"applyMiddleware 允许使用中间件middleware增强Redex的store的 dispatch 方法，这些中间件通过组合的方式构成一条中间件的链，通过这种方式，每个中间件无需关注其他中间件的操作。 接口 applyMiddleware(…middlewares) 每个中间件 middleware 的方法签名要求为 (&#123; getState, dispatch &#125;) =&gt; next =&gt; action。 applyMiddleware 的整体结构函数的源代码非常简洁只有不到20行的代码，函数的整体结构如下： function applyMiddleware(...middlewares) &#123; return (createStore) =&gt; (reducer, preloadedState, enhancer) =&gt; &#123; var store = createStore(reducer, preloadedState, enhancer) var dispatch = store.dispatch ...// 修改dispatch return &#123; ...store, dispatch &#125; &#125;&#125; 代码结构看起来很是复杂，实际上应用了函数式编程的柯里化技术，实际上柯里化是把一个接收多个参数的函数转换成接收一个参数的技巧，为了便于理解，对函数去柯里化如下： function applyMiddleware(...middlewares, createStore, reducer, preloadedState, enhancer) &#123; var store = createStore(reducer, preloadedState, enhancer) var dispatch = store.dispatch ...// 修改dispatch return &#123; ...store, dispatch &#125;&#125; 这下很容易看出，applyMiddleware 实质是使用 createStore 创建 store ，然后修改增强 store 的 dispatch 函数，store 的其他内容保留。 返回值这里使用了 es6 的新特性，可以翻译为： return Object.assign(&#123;&#125;, store, &#123;dispatch: dispatch&#125;); 返回一个新对象，将 store 的所有属性复制进去，并使用新的 dispatch 函数替代 store 原有的 dispatch 函数。 注意到 applyMiddleware 的返回值为 (createStore) =&gt; (reducer, preloadedState, enhancer) =&gt; newStore, 如果阅读过 createStore 的源代码就会发现有这么几行： function createStore(reducer, preloadedState, enhancer) &#123; ... if (typeof enhancer !== &#x27;undefined&#x27;) &#123; //如果传入了store enhancer即在调用了函数的时候传入了 applyMiddleware //那么此时创建的 store 的 dispatch 函数即是加了中间件“特效”的 return enhancer(createStore)(reducer, preloadedState) &#125; ...&#125; 如果传递了 enhancer参数，那么就会使用 enhancer 创建 store， 而 enhancer 实际上就和 applyMiddleware 的返回值几乎一样。正是因为 applyMiddleware 采用了柯里化，才保证了可以调用 applyMiddle(middleware1, middleware2, ...middlewares) 作为 createStore 的 enhancer 参数。 综上，使用中间件函数创建 store 有两种方式： // 1.使用 applyMiddle：applyMiddle(middleware1, middleware2, ...middlewares)(createStore)(reducer, preloadedState, enhancer);//2.使用 createStore：createStore( reducer, preloadedState, applyMiddlware(middleware1, middleware2, ...middlewares)); 唯一的区别在于，使用 applyMiddle 还可以再次应用其他的 store enhancer 中间件。 dispatch 的增强如果使用过其他的中间件结构比如nodejs的可以知道，中间件实际上是把 action--&gt;reducer 变成: action -&gt; middleware1 -&gt; middleware2 -&gt; ... -&gt; reducer，继续阅读代码： var dispatch = store.dispatchvar chain = []var middlewareAPI = &#123; getState: store.getState, dispatch: (action) =&gt; dispatch(action)&#125;chain = middlewares.map(middleware =&gt; middleware(middlewareAPI))dispatch = compose(...chain)(store.dispatch) 首先定义了中间件的需要传递给中间件的接口 getState 和 dispatch， 这也定义了中间件的签名必定是 (&#123; dispatch, getState &#125;) =&gt; next =&gt; action =&gt; &#123;//do sth&#125;，这里有个细节，middlewareAPI 为什么不写成：dispatch: dispatch 而是写成： dispatch: (action) =&gt; dispatch(action) ，这个细节将在后面详细说明。 然后继续看代码，可以把chain的存储的内容转换为： chain = middlewares.map(middleware =&gt; middleware(middlewareAPI))//等于：chain = [ next =&gt; action =&gt; &#123;&#125;, //包含getState、dispatch函数的闭包，假定此函数为f1 next =&gt; action =&gt; &#123;&#125;, //包含getState、dispatch函数的闭包，假定此函数为f2 ... next =&gt; action =&gt; &#123;&#125;, //包含getState、dispatch函数的闭包，假定此函数为fn] 为了后面描述的方便，这里为 chain 的成员分别命名 f1,f2, … fn 接着看 compose： dispatch = compose(...chain)(store.dispatch) compose 将函数从右向左组合： compose([f1, f2, ..., fn])//等价于：(...args) =&gt; f1(f2(...(fn(...args)))) 返回继续阅读 applyMiddleware 并把转换后的 compose 代入: dispatch = compose(...chain)(store.dispatch)//等价于：dispatch = f1(f2(...(fn(store.dispatch)))) 把这里的 f1, f2, ..., fn 分别替换回去: dispatch = f1(f2(action =&gt; &#123; //middleware n pre do sth //... store.dispatch(action); //middleware n after do sth&#125;));...dispatch = action =&gt; &#123; //middleware 1 pre do sth //middleware 2 pre do sth //... //middleware n pre do sth store.dispatch(action); //middleware n after do sth //... //middleware 2 after do sth //middleware 1 after do sth&#125; 其中 &quot;pre do sth&quot; 指的是中间件函数定义中的 next(action) 前面的代码，在 action 被处理前调用，而 &quot;after do sth&quot; 指的是中间件调用 next(action) 后的代码，在 action 被处理后调用，而 next(action) 实际上也是中间件将控制权移交下一个中间件，也即调用 applyMiddleware(middleware1, middleware2, ... middlewaren) 的执行过程为：middleware1 pre -&gt; middleware2 pre -&gt; ... -&gt; middlewaren pre -&gt; store.dispatch -&gt; middlewaren -&gt;... -&gt; middleware2 -&gt; middleware1函数。 注意： 中间件并不总是包含 &quot;pre do sth&quot; 和 &quot;after do sth&quot; 结构的，此外这里仅讨论只有同步操作的中间件，异步的情况后面讨论。 Middleware 中间件经过上面分析，可以知道中间件的基本结构如下： const Middleware = (&#123;dispatch, action&#125;) =&gt; next =&gt; action =&gt; &#123; //do sth next(action); //do sth&#125; 比如，可以编写日志中间件： const logMiddleware = (&#123;dispatch, action&#125;) =&gt; next =&gt; action =&gt; &#123; console.log(new Date() + &#x27; action: &#x27;); console.log(action); next(action);&#125; 中间件的函数签名实际上是有 dispatch 的，这个 dispatch 和 next 都是接收 action 作为参数的，他们有什么区别呢？ 前面已经说过，next 将 action 控制权移交下一个组件，其实质是被下一个中间件增强过的 “store.dispatch”。而回过头来再看一下 applyMiddleware 的源代码，可以发现中间件函数拿到的 dispatch实际是 ：dispatch: (action) =&gt; dispatch(action) 传递给每个 middleware 的 dispatch 被一层匿名函数包裹，这样最终导致传递给每个中间件的 dispatch 实际上是组合了所有的中间件的dispatch，而不是 “store.dispatch” 这个初始的旧的 “dispatch” 而在中间件可以调用 next(action) 和 dispatch(action) 的区别可以看下图： 使用 next(action) 效果如图左，从外层逐层处理action，并将处理过的action传递给下一层，处理完毕后再逐层返回，而使用 dispatch(action) 效果如图右，调用以后重新返回到外层，相当于再次从头开始应用中间件，这种情况通常用于场景是中断当前流程，将控制权移交其他部分，待其他内容处理完成再跳回正常流程，比如异步请求场景。 下面以 redux-thunk 为例说一下这种情况，首先看一下源代码： function createThunkMiddleware(extraArgument) &#123; return (&#123; dispatch, getState &#125;) =&gt; next =&gt; action =&gt; &#123; if (typeof action === &#x27;function&#x27;) &#123; return action(dispatch, getState, extraArgument); &#125; return next(action); &#125;;&#125;const thunk = createThunkMiddleware();thunk.withExtraArgument = createThunkMiddleware;export default thunk; redux-thunk 判断 action 是否为函数，如果是，将控制权移交给 action 处理，把 dispatch、 getState传递给 action ，待 action 处理完毕调用 dispatch(action) 此时 action 为正常的 action对象，回到正常中间件流程，然后redux-thunk 执行 next(action) 进入下一个中间件。 而这个 action 基本结构如下： //action 定义function success(data) &#123; return &#123; type: &#x27;SUCCESS&#x27;, data &#125;&#125;function error(err) &#123; return &#123; type: &#x27;ERROR&#x27;, err &#125;&#125;// 异步action定义// 和同步 action 不同 返回函数接收 dispatch 做为参数function asyncFetch(params) &#123; return function (dispatch, getState) &#123; return fetch(params) .then(data =&gt; dispatch(success(data) .catch(err =&gt; dispatch(error(err)) &#125;&#125;//调用：dispatch(asyncFetch(&#123;...&#125; &#125;)) 如上示例，asyncFetch(&#123;&#125;) 返回值不是对象而是函数，thunk 中间件拿到这个 “函数action” 后，把控制权移交给这个函数，这个函数执行 fetch 异步获取数据，获取数据成功后通过 dispatch(successAction) 再次返回 thunk中间件 ，此时 successAction 是对象，因此执行 next(action) 进入下一个中间件处理，异常流程与之类似不再说明。 注意： 中间件是根据声明顺序从左到右调用的，所以如果使用到类似于 thunk 中间件的异步类中间件，一般要在applyMiddleware 参数的最前面声明，以免其他中间件被执行多次。 源码注释/** * Creates a store enhancer that applies middleware to the dispatch method * of the Redux store. This is handy for a variety of tasks, such as expressing * asynchronous actions in a concise manner, or logging every action payload. * * See `redux-thunk` package as an example of the Redux middleware. * * Because middleware is potentially asynchronous, this should be the first * store enhancer in the composition chain. * * Note that each middleware will be given the `dispatch` and `getState` functions * as named arguments. * * @param &#123;...Function&#125; middlewares The middleware chain to be applied. * @returns &#123;Function&#125; A store enhancer applying the middleware. * 从返回值可以看出： * 除了通过Redux.createStore(reducer, preloadedState, applyMiddlware(...middlewares))创建store * 还可通过applyMiddlware(...middlewares)(createStore)(reducer, preloadedState, enhancer)创建store */export default function applyMiddleware(...middlewares) &#123; return (createStore) =&gt; (reducer, preloadedState, enhancer) =&gt; &#123; //内部使用原始的createStore创建store，以保证不影响store的其他接口 var store = createStore(reducer, preloadedState, enhancer) //保留原始的没有被中间件修改过的dispatch var dispatch = store.dispatch var chain = [] var middlewareAPI = &#123; getState: store.getState, //使用匿名函数保证传递给每个 middleware 的 dispatch 函数都是 //compose(...chain)(store.dispatch) 这个应用了全部中间件的增强过的最新的 dispatch dispatch: (action) =&gt; dispatch(action) &#125; //以redux为例： //const thunk = (&#123; dispatch, getState &#125;) =&gt; next =&gt; action =&gt; &#123; // if (typeof action === &#x27;function&#x27;) &#123; // return action(dispatch, getState, extraArgument); // &#125; // return next(action); //&#125;; //middleware =&gt; middleware(middlewareAPI)对应的实际上是 //thunk =&gt; thunk(middlewareAPI) //即chain的每一个元素的结构类似于： //next =&gt; action =&gt; &#123; // ... // if (typeof action === &#x27;function&#x27;) &#123; // return action(dispatch, getState, extraArgument); // &#125; // 此时，next 实际上就是 store.dispatch,即被后一个middleware增强过的dispatch // 又或者说 next 将 action 的控制权移交下一个中间件处理更为恰当 // return next(action); //&#125;; chain = middlewares.map(middleware =&gt; middleware(middlewareAPI)) //compose的实现简单来说如下： //function compose(...funcs) &#123; // if (funcs.length === 1) &#123; // return funcs[0] // &#125; // const last = funcs[funcs.length - 1] // const rest = funcs.slice(0, -1) // return (...args) =&gt; rest.reduceRight((composed, f) =&gt; f(composed), last(...args)) // &#125; //简单来说compose([chain1, chain2, chain3])(store.dispatch) //类似于：chain1(chain2(chain3(store.dispatch))) //即传递给每个chain的next从参数实际上是上一个chain包装过的增强的dispatch dispatch = compose(...chain)(store.dispatch) //返回一个新的对象，拥有store的所有接口 //并且store的其他接口如getState、subscribe保持不变 //仅仅使用增强后dispatch函数的覆盖了store的原始的dispatch函数 return &#123; ...store, dispatch &#125; &#125;&#125; 相关Redux 源码阅读笔记： createStore.js 源码阅读笔记 combineReducers.js 源码阅读笔记 bindActionCreators.js 源码阅读笔记 applyMiddleware.js 源码阅读笔记 compose.js 源码阅读笔记 参考本文阅读代码版本 3.5.2 redux源代码 redux文档 redux middleware 详解","categories":[{"name":"js","slug":"js","permalink":"http://tcatche.site/categories/js/"}],"tags":[{"name":"react","slug":"react","permalink":"http://tcatche.site/tags/react/"},{"name":"redux","slug":"redux","permalink":"http://tcatche.site/tags/redux/"}]},{"title":"文本省略显示","slug":"text-overflow-ellipsis","date":"2017-02-27T09:21:00.000Z","updated":"2018-11-11T08:30:38.000Z","comments":true,"path":"2017/02/text-overflow-ellipsis/","link":"","permalink":"http://tcatche.site/2017/02/text-overflow-ellipsis/","excerpt":"","text":"在开发中有一些情景下需要隐藏过多的文本，比如文章列表中文章的描述或者摘要，并加以省略号给用户提醒，在这里对常用的方法进行简单的总结： 单行文本省略单行文本省略很简单，只需三行css属性即可： &lt;p&gt;这里是一段用脸滚出来的文字：卡技术的恢复了开始发说说的反馈啦活动福利很好的数量咖啡还&lt;/p&gt; p &#123; width: 200px; white-space: nowrap; //强制文本单行显示 overflow: hidden; //溢出内容隐藏 text-overflow: ellipsis; //文本溢出内容添加省略号提醒 border: 3px solid #333&#125; 这种方法现在已经被主流浏览器支持，不再多言。 多行文本省略多行文本省略在有些情况下也会用到，这个功能目前没有通用的纯CSS的实现方式，在不同浏览器的实现方式不一致，主要有以下几种实现方式： Webkit 浏览器的专有方法webkit 内核的浏览器提供了一些专用属性 -webkit-line-clamp 支持指定多行文本省略： p &#123; width: 200px; display: -webkit-box; -webkit-line-clamp: 3; -webkit-box-orient: vertical; overflow: hidden; border: 3px solid #333;&#125; Opera 浏览器的专有方法：webkit 内核的浏览器提供了一些专用属性值 -o-ellipsis-lastline 支持指定多行文本省略： p &#123; line-height: 20px; max-height: 60px; overflow: hidden; text-overflow: -o-ellipsis-lastline;&#125; 支持 Firefox 和 IE 浏览器上的方法：以上两种方法在火狐和ie上并不被支持，但是可以通过限制内容块的高度，并且为内容块设置一个额外的省略号的代码块覆盖在段落最后： p &#123; //为p元素增加相对定位 position: relative; width: 200px; display: -webkit-box; -webkit-line-clamp: 3; -webkit-box-orient: vertical; overflow: hidden; border: 3px solid #333; //火狐下保证仅显示三行 line-height: 20px; max-height: 60px;&#125;p::after &#123; position: absolute; content: &#x27;\\02026&#x27;; //省略号的编码 background: #fff; bottom: 0; right: 0; padding-left: 30px; //颜色和p的背景色保持一致2background: linear-gradient(to right, rgba(255, 255, 255, 0), white 50%, white);&#125; 这种方法的实现效果会和前两种有所差异，如果对展示的一致性要求较高，可以只采用这种方法，或者下一节的js方法实现。 使用js使用js基本可以保证在不同的浏览器下有相同的效果，支持这个功能的 js库有好多，比如 Clamp.js 等，相关细节可以参考文档。 参考 Line Clampin’ (Truncating Multiple Line Text) 在线实例","categories":[{"name":"css","slug":"css","permalink":"http://tcatche.site/categories/css/"}],"tags":[]},{"title":"Promise特性总结","slug":"promise-object","date":"2016-09-01T07:17:09.000Z","updated":"2018-08-01T10:41:24.000Z","comments":true,"path":"2016/09/promise-object/","link":"","permalink":"http://tcatche.site/2016/09/promise-object/","excerpt":"","text":"Promise 对象代表着一个还未完成，但预期将来会完成的操作，该新特性属于 ECMAScript 2015（ES6）规范。使用 Promise 对象，可以十分方便的摆脱层层嵌套的异步操作回调函数，而以同步操作的流程书写代码。Promise 对象主要具有以下两个特点： Promise 对象的状态只受构造函数内的同步或者一步操作影响，其他外部操作无法改变 Promise 对象的状态。 Promise 对象的状态改变，只会从 pending 变为 resolved 或者从 pending 变为rejected，状态改变后不再会发生改变。 浏览器兼容性 Chrome Edge Firefox IE Opera Safari 32.0 Yes 29.0 未实现 19 7.1 Promise ConstructorPromise 对象构造器接受一个带有 resolve 和 reject 两个参数的函数，resolve 用于处理执行成功的场景，reject 用于处理执行失败的场景，我们可以根据执行结果决定调用哪个函数处理。 new Promise(function(resolve, reject) { … }); Promise对象有以下几种状态: pending: 初始状态； resolved: 成功的操作，又称fulfilled； rejected: 失败的操作。 示例如下： var promiseCount = 0;function testPromise() &#123; var thisPromiseCount = ++promiseCount; console.log(thisPromiseCount + &#x27;) 开始(同步代码开始)&#x27;); // 我们创建一个新的promise: 然后用&#x27;result&#x27;字符串完成这个promise (3秒后) var p1 = new Promise(function (resolve, reject) &#123; // 完成函数带着完成（resolve）或拒绝（reject）promise的能力被执行 console.log(thisPromiseCount + &#x27;) Promise开始(异步代码开始)&#x27;); console.log(&#x27;//等待若干秒&#x27;); // 这只是个创建异步完成的示例 window.setTimeout(function () &#123; // 我们满足（fullfil）了这个promise! resolve(thisPromiseCount) &#125;, Math.random() * 2000 + 1000); &#125;); // 定义当promise被满足时应做什么 p1.then(function (val) &#123; // 输出一段信息和一个值 console.log(val + &#x27;) Promise被满足了(异步代码结束)&#x27;); &#125;); console.log(thisPromiseCount + &#x27;) 建立了Promise(同步代码结束)&#x27;);&#125;testPromise();testPromise();testPromise(); 输出： 1) 开始(同步代码开始)1) Promise开始(异步代码开始)//等待若干秒1) 建立了Promise(同步代码结束)2) 开始(同步代码开始)2) Promise开始(异步代码开始)//等待若干秒2) 建立了Promise(同步代码结束)3) 开始(同步代码开始)3) Promise开始(异步代码开始)//等待若干秒3) 建立了Promise(同步代码结束) Promise 对象和其原型对象定义几个非常有用的方法： Promise.prototype.thenthen() 方法接收两个函数作为参数，并分别作为 success 和 failure 状态的回调函数，then() 方法返回一个 Promise 对象。 语法 p.then(function(succData){}, function(errData){})p.then(function(){}) then() 的第二个参数通常省略，因为无法捕获当前then() 函数的异常，而用统一的 catch() 函数进行异常处理，下节详述 then() 使用then() 方法返回 Promise 对象，因此可以链式调用，而前一个 then() 函数的返回值将会被作为参数传递给下一个 then() 函数： var p = new Promise(function(resolve, reject) &#123; resolve(&quot;SUCCESS&quot;); //or //reject(&quot;FAILURE&quot;);&#125;);p.then(function(succData)&#123; console.log(succData);//success&#125;, function(errData)&#123; console.log(errData);//failure&#125;); 链式调用：then() 方法返回 Promise 对象，因此可以链式调用，而前一个 then() 函数的返回值将会被作为参数传递给下一个 then() 函数： var p = new Promise(function(resolve, reject) &#123; resolve(1);&#125;);p.then(function(val) &#123; console.log(val); // 1 return val + 1;&#125;).then(function(val) &#123; console.log(val); // 2&#125;).then(function(val) &#123; console.log(val); // 3&#125;); Promise.prototype.catchcatch() 函数处理 Promise 失败的情形，即在 Promise 中调用了 reject(data) 的情形， 也可以捕获 then() 函数中抛出的错误。 语法 p.catch(function(errData){}) catch使用var p = new Promise(function(resolve, reject) &#123; //resolve(&quot;SUCCESS&quot;); //or reject(&quot;FAILURE&quot;);&#125;);p.then(function(succData)&#123; console.log(succData);//success&#125;).catch(function(errData)&#123; console.log(errData);//failure&#125;);//实际上等同于p.then(function(succData)&#123; console.log(succData);//success&#125;.then(null, function(errData)&#123; console.log(errData);//failure&#125;); 捕获 Promise 的错误catch 也能捕获 promise语句中的错误，这种情况类似于在 promise 中调用 reject。 var p = new Promise(function(resolve, reject) &#123; throw(&quot;FAILURE&quot;);&#125;);p.then(function(succData)&#123; throw new Error(&#x27;FAILURE&#x27;); //不执行&#125;).catch(function(errData)&#123; console.log(errData);//FAILURE&#125;); 捕获 then 函数的错误var p = new Promise(function(resolve, reject) &#123; resolve(&quot;SUCCESS&quot;);&#125;);p.then(function(succData)&#123; throw new Error(&#x27;FAILURE&#x27;);&#125;).catch(function(errData)&#123; console.log(errData);//FAILURE&#125;); catch 也支持链式调用Promise 的错误总是向后抛给 catch 处理的，而 catch 的返回值也是 Promise 因此后一个 catch() 可以处理前一个 catch() 中抛出的错误 建议统一使用 catch 处理异常尽管通过 then() 方法传递第二个参数可以处理异常，但是无法处理此个 then() 内的异常： var p = new Promise(function(resolve, reject) &#123; reject(FAILURE1);&#125;);p.catch(function(errData)&#123; console.log(errData);//FAILURE1 throw new Error(&#x27;FAILURE2&#x27;);&#125;).catch(function(errData)&#123; console.log(errData);//FAILURE2&#125;); Promise.allPromise.all 方法是 Promise 的一个静态方法，将多个 promise 实例（p1, p2, p3）包装成一个新的 promise 实例（p），此时会有两种执行结果： p 会等所有 promise（ p1, p2, p3 ）都被 resolve 后 resolve，此时将这些 promise （ p1, p2, p3 ）的返回值组成一个数组([p1,p2,p3])，传递给 p 的回调函数； 如果 p1, p2, p3 中有一个被 reject 则该 reject ，并将该 reject的返回值传递给 p 的回调函数 。 语法： Promise.all(iterable) iterable 是一个可迭代对象，比如 Array，iterable 元素可以不是 promise 如果不是 promise 则会使用 Promise.resolve 转换为 Promise。 从多个数据源获取数据下面是使用 ajax 从多个不同的接口获取数据的示例，如果所有的数据都获取成功，就可以渲染页面，否则报错。 p = Promise.race([ fetch(&#x27;/resource/data1.json&#x27;)， fetch(&#x27;/resource/data2.json&#x27;)， fetch(&#x27;/resource/data3.json&#x27;)，]).then(([d1, d2, d3]) =&gt; &#123;//render page&#125;).catch(err =&gt; &#123;//err handler&#125;); Promise.racePromise.race 方法是 Promise 的一个静态方法，将多个 promise 实例包装成一个新的 promise 实例，和 Promise.all 不同的是，这多个 promise 实例中的任意一个 promise 被解决或拒绝后，立刻以该 promise 的状态和传递的值返回给其回调函数，方法返回一个 Promise。 语法 Promise.race(iterable) //iterable：一个可迭代对象，比如Array。 处理 ajax 异常状态下面是使用 ajax 获取数据的示例，第二个 promise 在5s后状态会变为 reject ，如果 fetch 在5s 内获取导数据将会正常执行，否则会触发超时错误。 p = Promise.race([ fetch(&#x27;/resource/data.json&#x27;), new Promise(function (resolve, reject) &#123; setTimeout(() =&gt; reject(new Error(&#x27;request timeout&#x27;)), 5000) &#125;)]).then(response =&gt; &#123; //use data do sth&#125;).catch(error =&gt; &#123; //err handler&#125;) Promise.resolvePromise.resolve 方法将给定的参数转换为一个 Promise 对象， 语法 Promise.resolve(value);Promise.resolve(promise);Promise.resolve(thenable); 参数是 promise 对象参数是 promise 对象，则不做操作直接返回这个 promise 对象。 Promise.resolve(Promise.resolve(&#x27;Hello, world&#x27;)).then(data =&gt; console.log(data)); 参数是 thenable 对象如果参数是一个包含 then 方法的对象，resolve 方法会将这个对象转为 Promise 对象，然后执行这个对象的 then 方法。 Promise.resolve(&#123; then(resolve, reject) &#123; resolve(&#x27;Hello, world&#x27;); &#125;&#125;).then(data =&gt; console.log(data));//Hello, world 参数不是 thenable 和 promise 对象如果参数是一个数值，或者是一个非 thenable 或非 promise 的对象，Promise.resolve 方法返回一个状态为 Resolved 的 promise 对象，并把这个参数作为返回值传递给 then 回调函数(如果存在 then 的回调)。 Promise.resolve(&#x27;Hello, world&#x27;).then(data =&gt; console.log(data)); //Hello, world Promise.rejectPromise.reject 方法将给定的参数转换为一个 Promise 对象， 语法 Promise.reject(value);Promise.reject(promise);Promise.reject(thenable); 具体的使用情况与 Promise.resolve 类似。 参考: Promise Promise对象","categories":[{"name":"js","slug":"js","permalink":"http://tcatche.site/categories/js/"}],"tags":[{"name":"function","slug":"function","permalink":"http://tcatche.site/tags/function/"},{"name":"es","slug":"es","permalink":"http://tcatche.site/tags/es/"},{"name":"异步","slug":"异步","permalink":"http://tcatche.site/tags/%E5%BC%82%E6%AD%A5/"}]},{"title":"React组件的生命周期","slug":"react-components-life-cicle","date":"2016-05-20T05:14:00.000Z","updated":"2018-08-01T10:41:24.000Z","comments":true,"path":"2016/05/react-components-life-cicle/","link":"","permalink":"http://tcatche.site/2016/05/react-components-life-cicle/","excerpt":"","text":"React组件的生命周期和生命周期方法可以分为以下三个部分：组件的初始化挂载 componentWillMount() : 在初始化渲染执行之前调用； componentDidMount() : 在初始化渲染执行之后调用； 组件的更新 componentWillReceiveProps(): 在组件接收到新的 props 的时候调用； shouldComponentUpdate() : 在接收到新的 props 或者 state，将要渲染之前调用； componentWillUpdate() : 在接收到新的 props 或者 state 之前立刻调用，使用该方法做一些更新之前的准备工作； componentDidUpdate() : 在组件的更新已经同步到 DOM 中之后立刻被调用，使用该方法可以在组件更新之后操作 DOM 元素； 组件的卸载移除 componentWillUnmount() : 在组件从 DOM 中移除的时候立刻被调用，在该方法中执行任何必要的清理。 组件初始化挂载组件的初始化挂载完成组件的加载初始化操作，此阶段共包含两个方法 componentWillMount() 和 componentDidMount() 这两个函数分别在组件的挂载前后执行，因此在组件的整个生命周期仅执行一次，示例代码如下： class Test extends React.Component &#123;2constructor() &#123;22super();22this.state=&#123; value: 0 &#125;2&#125;2componentWillMount() &#123;22console.log(&quot;Test componentWillMount&quot;);2&#125;2componentDidMount() &#123;22console.log(&quot;Test componentDidMount&quot;);2&#125;2render() &#123;22console.log(&quot;Test component render&quot;);22console.log(&quot;value is: &quot; + this.state.value);P22return null;2&#125;&#125;ReactDOM.render(2&lt;Test /&gt;,2document.getElementById(&quot;react-root&quot;));//控制台输出：Test componentWillMountTest component rendervalue is: 0Test componentDidMount componentWillMount() void componentWillMount() 官方文档对这个方法有如下说明： Invoked once, both on the client and server, immediately before the initial rendering occurs. If you call setState within this method, render() will see the updated state and will be executed only once despite the state change. 方法在组件初始化渲染 render() 执行之前调用，在组件的生命周期中，仅会被执行一次，这个时候 DOM 还没有渲染，在这里可以允许我们在 DOM 渲染之前更改state，即在这个方法内调用 setState，render() 在渲染 DOM 的时候，会使用更新后的 state 渲染 DOM ，代码如下： class Test extends React.Component &#123;2constructor() &#123;22super();22this.state=&#123; value: 0 &#125;2&#125;2componentWillMount() &#123;22console.log(&quot;Test componentWillMount&quot;);22this.state=&#123; value: 1 &#125;2&#125;2componentDidMount() &#123;22console.log(&quot;Test componentDidMount&quot;);2&#125;2render() &#123;22console.log(&quot;Test component render&quot;);22console.log(&quot;value is: &quot; + this.state.value);22return null;2&#125;&#125;ReactDOM.render(2&lt;Test /&gt;,2document.getElementById(&quot;react-root&quot;));//控制台输出：Test componentWillMountTest component rendervalue is: 1Test componentDidMount 注意到 will be executed only once despite the state change 那么，如果在 componentWillMount() 中异步更新 state 会怎样呢，代码如下： class Test extends React.Component &#123;2constructor() &#123;22super();22this.state=&#123; value: 0 &#125;2&#125;2componentWillMount() &#123;22console.log(&quot;Test componentWillMount&quot;);22setTimeout(function() &#123;222console.log(&quot;Async load data&quot;)222this.setState=&#123; value: 1 &#125;22&#125;.bind(this), 100)2&#125;2componentDidMount() &#123;22console.log(&quot;Test componentDidMount&quot;);2&#125;2render() &#123;22console.log(&quot;Test component render&quot;);22console.log(&quot;value is: &quot; + this.state.value);22return null;2&#125;&#125;ReactDOM.render(2&lt;Test /&gt;,2document.getElementById(&quot;react-root&quot;));//控制台输出：Test componentWillMountTest component rendervalue is: 0Test componentDidMountAsync load data 从结果可以看到，异步改变的 state ，并没有影响到原有的 DOM render()， 控制台输出为 value is: 0。而且异步加载完成后对 componentWillMount() 中 state 的改变，控制台并没有再次输出 Test component render 和 value is: 1 ，没有再次触发 render() 过程。 总结：componentWillMount() 方法中对 state 的改变，如果是同步操作可以生效，异步操作会被忽略，因为异步操作完成后，组件状态不确定。React 官方不建议在 componentWillMount() 修改 state ，通常建议在 componentDidMount(), 如果需要设置 state 的初始状态，可以在 (es6:)constractor() 或者 (es5:)getInitialState() 中设置。 componentDidMount void componentDidMount() 方法在组件初始化渲染 render() 执行之后调用，在组件的生命周期中，仅会被执行一次，在执行这个函数的时候，组件已经拥有 DOM 呈现，可以进行 DOM 的操作，而这个时候，组件已经基本完成的渲染工作，通常可以开始与其他类库交互、操作 DOM 、发起 Ajax 请求、异步加载初始数据、设置事件监听和绑定、设置定时器任务 setTimeout 或者 setInterval 等。 注意：组件的渲染是递归操作的，因此子组件的这个方法会比父组件的先调用。 组件的更新当组件已经挂载完毕以后，组件通常已经处于运行阶段，当满足一定条件后，比如 state 和 props 发生改变以后，会触发组件的更新操作，组件的更新操作不会再调用组件挂载阶段的两个方法 componentWillMount() 和 componentDidMount() ，在此阶段有四个相关的方会被调用 componentWillReceiveProps 、shouldComponentUpdate 、componentWillUpdate 、componentDidUpdate 。 这四个与更新相关的方法，componentWillReceiveProps方法接收到新的属性变更时候被调用，在这里可以根据需要更新本组件的状态 、shouldComponentUpdate则是判断是否出发本组件的更新，默认返回 true 更新组件 、componentWillUpdate 和componentDidUpdate 分别在组件更新前后调用，通常进行组件更新前后的一些准备、处理工作。 props 的改变是来自父组件的状态变更，父组件的变动会引发当前组件的状态变更；而 state 是当前组件通过修改 state 改变当前组件的状态。 注意：官方推荐把 this.state 当成不可变变量，修改 state 调用 this.setState() 修改。 this.setState() 注意：setState() does not immediately mutate this.state but creates a pending state transition. Accessing this.state after calling this method can potentially return the existing value.setState() 的操作不是同步的，可以认为是异步的 setState() 执行完毕后，使用 this.state 获取的 state 值很可能仍然是旧的，代码如下： class Test extends React.Component &#123;2constructor() &#123;22super();22this.state=&#123; value: 0 &#125;2&#125;2componentDidMount() &#123;22console.log(&quot;Test componentDidMount&quot;);22this.setState(&#123; value: 1 &#125;);22console.log(&quot;value is: &quot; + this.state.value)2&#125;2render() &#123;22console.log(&quot;Test component render&quot;);22return null;2&#125;&#125;ReactDOM.render(2&lt;Test /&gt;,2document.getElementById(&quot;react-root&quot;));//控制台输出：Test component renderTest componentDidMountvalue is: 0 如果需要在 setState() 后获取更新后的值，可以放在 setState() 回调里： this.setState(2&#123; value: 1 &#125;,2function() &#123;22console.log(&quot;callback value is: &quot; + this.state.value);2&#125;); setState(newState) 更新是把 newState 对象的属性直接复制给 this.state。 componentWillReceiveProps() void componentWillReceiveProps(object nextProps) 在组件接收到新的 props 的时候被调用，组件state变化是不会执行这个函数，参数传递过来的是新的 props ，原来的 props 仍然可以通过 this.props 获取，在这里可以根据根据本组件接收到的属性确定是否需要更新本组件的状态。 当在本方法更新 state 时，在调用 shouldComponentUpdate 时，收到新的 state 即为本方法更新后的 state 。 class Test extends React.Component &#123;2constructor() &#123;22super();22this.state=&#123;222value: 022&#125;2&#125;2componentWillReceiveProps(nextProps) &#123;22console.log(&quot;This receive new props: &quot; + nextProps.value);22this.setState(&#123;222value: nextProps.value22&#125;);22console.log(&quot;This change state to: &quot; + nextProps.value);2&#125;2shouldComponentUpdate(nextProps, nextState) &#123;22console.log(&quot;This receive new state: &quot; + nextState.value);22return true;2&#125;2render() &#123;22return null;2&#125;&#125;class Parent extends React.Component &#123;2constructor() &#123;22super();22this.state=&#123; value: 0 &#125;2&#125;2componentDidMount() &#123;22console.log(&quot;After 5s, Test component will receive new props&quot;);22setTimeout(() =&gt; this.setState(&#123; value: 1 &#125;), 5000);2&#125;2render() &#123;22return &lt;Test value=&#123;this.state.value&#125; /&gt;2&#125;&#125;ReactDOM.render(2&lt;Parent /&gt;,2document.getElementById(&quot;react-root&quot;));//控制台输出：After 5s, Test component will receive new propsThis receive new props: 1This change state to: 1This receive new state: 1 shouldComponentUpdate() bool shouldComponentUpdate(object nextProps, object nextState) 在组件在接收到新的 props 或者 state，将要重新渲染之前调用，返回值决定了组件是否更新，如果 shouldComponentUpdate 返回 false，则 render() 将不会执行，直到下一次 state 改变，此外， componentWillUpdate 和 componentDidUpdate 也不会被调用。 class Test extends React.Component &#123;2constructor() &#123;22super();22this.state=&#123; value: 0 &#125;2&#125;2componentDidMount() &#123;22setTimeout(() =&gt; this.setState(&#123; value: 1 &#125;), 5000);2&#125;2shouldComponentUpdate() &#123;22console.log(&quot;componentWillUpdate will be called.&quot;);22return false;2&#125;2componentWillUpdate() &#123;22console.log(&quot;componentWillUpdate will not be called.&quot;);2&#125;2componentDidUpdate() &#123; console.log(&quot;componentDidUpdate will not be called.&quot;);2&#125;2render() &#123;22console.log(&quot;Test component render&quot;);22return null;2&#125;&#125;ReactDOM.render(2&lt;Test /&gt;,2document.getElementById(&quot;react-root&quot;));//控制台输出：Test component rendercomponentWillUpdate will be called. 由输出结果可以看出，shouldComponentUpdate 返回 false 以后，更新流程不再继续往下走了， componentWillUpdate 和 componentDidUpdate 方法也不再执行。 注意：调用 this.forceUpdate() 函数将不会执行 shouldComponentUpdate 方法，因为 this.forceUpdate() 要求强制更新组件，不会因为受 shouldComponentUpdate 的返回值影响，所以跳过该方法， 但是 componentWillUpdate 和 componentDidUpdate 仍然会被调用。另外 this.forceUpdate() 的调用虽然会跳过本组件的 shouldComponentUpdate 方法被执行，对子组件的没有影响。 class Test extends React.Component &#123;2constructor() &#123;22super();22this.state=&#123; value: 0 &#125;2&#125;2//5s后强制更新2componentDidMount() &#123;22setTimeout(() =&gt; this.forceUpdate(), 5000);2&#125;2shouldComponentUpdate() &#123;22console.log(&quot;shouldComponentUpdate not be called.&quot;);2&#125;2componentWillUpdate() &#123;22console.log(&quot;componentWillUpdate be called.&quot;);2&#125;2componentDidUpdate() &#123; console.log(&quot;componentDidUpdate be called.&quot;);2&#125;2render() &#123;22console.log(&quot;Test component render&quot;);22return null;2&#125;&#125;ReactDOM.render(2&lt;Test /&gt;,2document.getElementById(&quot;react-root&quot;));//控制台输出：Test component rendercomponentWillUpdate be called.Test component rendercomponentDidUpdate be called. 在组件比较多或者比较复杂的项目中，组件的更新成本较大，可以在这里重载默认的逻辑，比较组件的新旧状态和属性值的变化，来确定是否够需要更新组件。 componentWillUpdate() void componentWillUpdate(object nextProps, object nextState) 如果组件的状态或者属性改变，并且组件 shouldComponentUpdate 返回结果为 true ，此方法会被调用，通常在这这里做一些更新前的准备工作。需要注意的是，这个方法执行完毕后，新的 state 和 props 即被更新入 this.state 和 this.props 中,组件即进入 render 阶段。 注意：此时组件必然会更新，进入重新render的过程，在此时已经不允许改变组件的状态了。 class Test extends React.Component &#123;2constructor() &#123;22super();22this.state=&#123; value: 0 &#125;2&#125;2componentDidMount() &#123;22setTimeout(() =&gt; this.setState(&#123; value: 1 &#125;), 5000);2&#125;2componentWillUpdate() &#123;22this.state=&#123; value: 2 &#125;22console.log(&quot;Try to change state.value to 2&quot;);2&#125;2render() &#123;22console.log(&quot;Test component render&quot;);22console.log(&quot;Current state.value is: &quot; + this.state.value);22return null;2&#125;&#125;ReactDOM.render(2&lt;Test /&gt;,2document.getElementById(&quot;react-root&quot;));//控制台输出：Test component renderCurrent state.value is: 0Try to change state.value to 2Test component renderCurrent state.value is: 1 从输出可以看到 componentWillUpdate 方法中调用 this.setState 后，state没有变化，而且也没有再次触发组件的更新操作。 componentDidUpdate() void componentDidUpdate(object prevProps, object prevState) 组件在更新后执行，在这里已经完成了组件的更新工作了，此时，方法的输入参数变成了更新前的 props 和 state ， 这这里通常进行一些组件更新后的操作，比如，为新增加的DOM元素绑定事件等。 组件的卸载移除componentWillUnmount() void componentWillUnmount() 组件被移除前执行，通常在这里执行一些必要的清理工作，比如清除定时器任务、清除事件监听绑定、清除非 React 创建的 DOM 元素等，代码如下： class Child extends React.Component &#123;2componentDidMount() &#123;22console.log(&quot;Set interval task.&quot;);22console.log(&quot;Bind event Listener.&quot;);2&#125;2componentWillUnmount() &#123;22console.log(&quot;Remove interval task.&quot;);22console.log(&quot;Unbind event Listener.&quot;);2&#125;2render() &#123;22console.log(&quot;Child component render&quot;);22return null;2&#125;&#125;class Parent extends React.Component &#123;2constructor() &#123;22super();22this.state=&#123; value: 0 &#125;2&#125;2//5s后修改state，移除Child2componentDidMount() &#123;22setTimeout(() =&gt; this.setState(&#123;value: 1&#125;), 5000)2&#125;2componentWillUnmount() &#123;22console.log(&quot;Remove interval task.&quot;);22console.log(&quot;Unbind event Listener.&quot;);2&#125;2render() &#123;22if (this.state.value == 1) &#123;222console.log(&quot;Child component is unmounted.&quot;);222return null;22&#125;22else &#123;222console.log(&quot;Child component is mounted.&quot;);222console.log(&quot;After 5s, Child component will be unmounted.&quot;);222return &lt;Child /&gt;;22&#125;2&#125;&#125;ReactDOM.render(2&lt;Parent /&gt;,2document.getElementById(&quot;react-root&quot;));//控制台输出：Child component is mounted.After 5s, Child component will be unmounted.Child component renderSet interval task.Bind event Listener.Child component is unmounted.Remove interval task.Unbind event Listener. 参考 Component Specs and Lifecycle React Component Lifecycle React Native 中组件的生命周期","categories":[{"name":"js","slug":"js","permalink":"http://tcatche.site/categories/js/"}],"tags":[{"name":"react","slug":"react","permalink":"http://tcatche.site/tags/react/"}]},{"title":"Javascript异步编程","slug":"Javascript-async-program","date":"2016-03-31T03:55:09.000Z","updated":"2018-11-11T08:29:46.000Z","comments":true,"path":"2016/03/Javascript-async-program/","link":"","permalink":"http://tcatche.site/2016/03/Javascript-async-program/","excerpt":"","text":"Callbacks 回调函数回调函数是异步编程的最基本方法。考虑到以下两个函数 f1() 、 和 f2() ，f2()等待f1()的执行结果： function f1(cb) &#123;2setTimeout(function() &#123;22var records = [];22records.push(1, 2);22cb(records);2&#125;, 1000);&#125;function f2(records, cb) &#123;2records.push(3, 4);2cb(records);&#125; 如果 f2()等待f1()的执行结果， f1() 是很耗时的操作，可以把 f2() 作为 f1() 的回调： f1(function(records) &#123;2f2(records, function(records) &#123;22console.log(records);2&#125;)&#125;)//控制台打印[1, 2, 3, 4] 回调函数的优点是简单、容易理解和部署，缺点是不利于代码的阅读和维护，各个部分之间高度耦合，流程会很混乱，而且最大的问题是每个任务只能指定一个回调函数。 ##Listeners 事件监听事件监听也是一种常见的思路，为一个对象上绑定一个事件，传递一个想要监听的事件和一个回调函数，。一个事件监听类似于如下（jquery采用 on 函数）： f1.on(&#x27;done&#x27;, f2() &#123; //do something&#125;); 当 f1 上的 done 事件完成后将执行 f2() 函数，因此对之前实例改造如下： function f1() &#123;2setTimeout(function() &#123;22var records = [];22records.push(1, 2);22f1.trigger(&#x27;done&#x27;);2&#125;, 1000);&#125;function f2(records, cb) &#123;2records.push(3, 4);2cb(records);&#125;f1.on(&#x27;done&#x27;, function(records)&#123;2f2(records, function(records) &#123;22console.log(records);2&#125;)&#125;); 这种方法的优点是比较容易理解，可以绑定多个事件，每个事件可以指定多个回调函数，而且可以去耦合，有利于实现模块化。缺点是整个程序都要变成事件驱动型，运行流程会变得很不清晰。 发布/订阅可以对上一节的内容进行扩展，提供一个事件控制中心，某个任务执行完成，就向中心”发布”（publish）一个信号，其他任务可以向信号中心”订阅”（subscribe）这个信号，从而知道什么时候自己可以开始执行。这就叫做”发布/订阅模式”（publish-subscribe pattern），又称”观察者模式”（observer pattern）。 //首先，f2向EventCenter订阅&quot;done&quot;信号。EventCenter.subscribe(&quot;done&quot;, f2);function f1()&#123;2setTimeout(function () &#123;22// f1的任务代码22EventCenter.publish(&quot;done&quot;);2&#125;, 1000);&#125; EventCenter.publish(“done”)的意思是，f1执行完成后，发布”done”信号，从而引发f2的执行。此外，f2完成执行后，也可以取消订阅（unsubscribe）。jQuery.unsubscribe(&quot;done&quot;, f2); 这种方法的性质与”事件监听”类似，但是明显优于后者。因为我们可以通过查看 EventCenter ，了解存在多少信号、每个信号有多少订阅者，从而监控程序的运行。 流程控制库有很多流程控制库可以使用，比如Async.js，代码类似于如下： async.series([ function()&#123; ... &#125;, function()&#123; ... &#125;]); Promises对象Promisespromises的概念是由CommonJS小组的成员在 Promises/A规范 中提出来的的一种规范，目的是为异步编程提供统一接口。它的思想是，每一个异步任务返回一个 promise 对象，该对象有一个 then 方法，允许指定回调函数。比如，f1的回调函数f2,可以写成： function f1(records)&#123;2//获取defer对象 var deferred = when.defer();//when.js var deferred = $.Deferred();//jquery var records = []; setTimeout(function () &#123; records.push(1, 2); //声明任务完成，并指定传递的参数 deferred.resolve(records); &#125;, 500); //返回promise对象 return deferred.promise;&#125;function f2(records, cb) &#123;2records.push(3, 4);2cb(records);&#125;f1([]).then(f2); 这样写的优点在于，回调函数变成了链式写法，程序的流程可以看得很清楚，而且有一整套的配套方法，可以实现许多强大的功能。比如，指定多个回调函数：f1().then(f2).then(f3); 而且，它还有一个前面三种方法都没有的好处：如果一个任务已经完成，再添加回调函数，该回调函数会立即执行。 参考:1.Asynchronous JS: Callbacks, Listeners, Control Flow Libs and Promises2.Javascript异步编程的4种方法","categories":[{"name":"js","slug":"js","permalink":"http://tcatche.site/categories/js/"}],"tags":[]},{"title":"各大浏览器CSSHack收集","slug":"css-hack-in-all-browser","date":"2016-03-31T03:55:09.000Z","updated":"2018-09-04T12:17:38.000Z","comments":true,"path":"2016/03/css-hack-in-all-browser/","link":"","permalink":"http://tcatche.site/2016/03/css-hack-in-all-browser/","excerpt":"","text":"所谓的Hack就是只有特定浏览器才能识别这段hack代码。Hack 不是什么好东西，除非没有办法，我们尽量还是不要用着玩意。 下面是各个浏览器的CSS Hack 列表。 Firefox 浏览器 @-moz-document url-prefix() &#123; .selector &#123; property: value; &#125;&#125; 支持所有Gecko内核的浏览器 (包括Firefox) *&gt;.selector &#123;2property: value;&#125; Webkit 内核浏览器 @media screen and (-webkit-min-device-pixel-ratio: 0) &#123; Selector &#123; property: value; &#125;&#125; Opera 浏览器 html:first-child&gt;body Selector &#123;property:value;&#125; IE 浏览器针对不同的版本有不同个Hack方式。 IE 9 :root Selector &#123;property: value\\9;&#125; IE 9- Selector &#123;property: value\\9;&#125; IE 8 Selector &#123;property: value/;&#125;或：@media \\0screen &#123; Selector &#123;property: value;&#125;&#125; IE 8+ Selector &#123;property: value\\0;&#125; IE 7 *+html Selector&#123;property:value;&#125;或：*:first-child+html Selector &#123;property:value;&#125; IE 7- Selector &#123;*property: value;&#125; IE6 Selector &#123; _property: value;&#125;或：*html Selector &#123; property: value;&#125; 转自：http://www.codeceo.com/article/css-hack.html，侵删","categories":[],"tags":[{"name":"css","slug":"css","permalink":"http://tcatche.site/tags/css/"}]},{"title":"Css媒体查询","slug":"css-media-query","date":"2016-03-31T03:55:09.000Z","updated":"2018-08-01T10:41:24.000Z","comments":true,"path":"2016/03/css-media-query/","link":"","permalink":"http://tcatche.site/2016/03/css-media-query/","excerpt":"","text":"响应式Web设计(Responsive Web design)的理念是：页面的设计与开发应当根据用户行为以及设备环境(系统平台、屏幕尺寸、屏幕定向等)进行相应的响应和调整。 媒体查询准备工作设置Meta标签 首先我们在使用Media的时候需要先设置下面这段代码，来兼容移动设备的展示效果：&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no&quot;&gt;参数解释： width = device-width： 宽度等于当前设备的宽度 initial-scale： 初始的缩放比例（默认设置为1.0） minimum-scale： 允许用户缩放到的最小比例（默认设置为1.0） maximum-scale： 允许用户缩放到的最大比例（默认设置为1.0） user-scalable： 用户是否可以手动缩放（默认设置为no，因为我们不希望用户放大缩小页面）语法 媒体查询包含了一个媒体类型 和如CSS3规范中描述的包含一个或多个表达式的媒体属性，这些媒体属性会被解析成真或假。如果媒体查询中的媒体类型与文档要展示的设备相符则查询结果为真，并且媒体查询中的所有表达式为真。 &lt;!-- link元素中的CSS媒体查询 --&gt;&lt;link rel=&quot;stylesheet&quot; media=&quot;(max-width: 800px)&quot; href=&quot;example.css&quot; /&gt;&lt;!-- 样式表中的CSS媒体查询 --&gt;&lt;style&gt;@media (max-width: 600px) &#123; .facet_sidebar &#123; display: none; &#125;&#125;&lt;/style&gt; 当媒体查询为真时，相关的样式表或样式规则就会按照正常的级联规则被应用。即使媒体查询返回假， &lt;link&gt; 标签上带有媒体查询的样式表仍将被下载（只不过不会被应用）。 在不使用 not 或 only 操作符的情况下，媒体类型是可选的，默认为 all 。 逻辑操作符操作符 not，and 和 only可以用来构建复杂的媒体查询。 and 操作符用来把多个媒体属性组合起来，合并到同一条媒体查询中。只有当每个属性都为真时，这条查询的结果才为真。 or 当使用时，如果任何一个媒体查询返回真，样式就是有效的。or分隔的列表中每个查询都是独立的，一个查询中的操作符并不影响其它的媒体查询。这意味着 or 媒体查询列表能够作用于不同的媒体属性、类型和状态。 not 操作符用来对一条媒体查询的结果进行取反。 only 操作符表示仅在媒体查询匹配成功的情况下应用指定样式。可以通过它让选中的样式在老式浏览器中不被应用。 若使用了 not 或 only 操作符，必须明确指定一个媒体类型。 and and 关键字用于合并多个媒体属性或合并媒体属性与媒体类型。一个基本的媒体查询，即一个媒体属性与默认指定的 all媒体类型，可能像这样子：@media (min-width: 700px) &#123; ... &#125;如果你只想在横屏时应用这个，你可以使用 and 操作符合并媒体属性：(min-width: 700px) and (orientation: landscape) &#123; ... &#125;现在上面的媒体查询仅在可视区域宽度不小于700像素并在在横屏时有效。如果，你仅想再电视媒体上应用，你可以使用 and 操作符合并媒体属性：@media tv and (min-width: 700px) and (orientation: landscape) &#123; ... &#125;现在，上面媒体查询仅在电视媒体上，可视区域不小于700像素宽度并且是横屏时有效。 or 逗号分隔列表媒体查询中使用逗号分隔效果等同于or 逻辑操作符。例如，如果你想在最小宽度为700像素或是横屏的手持设备上应用一组样式，你可以这样写：@media (min-width: 700px), handheld and (orientation: landscape) &#123; ... &#125;如上文，如果是一个800像素宽的屏幕设备，媒体语句将会返回真，因为第一部分相当于 @media all and (min-width: 700px) 将会应用于该设备并且返回真，尽管我的屏幕媒体类型并不与第二部分的手持媒体类型相符。同样地，如果我是一个500像素宽的横屏手持设备，尽管第一部分因为宽度问题而不匹配，第二部分仍会成功，因此整个媒体查询返回真。 not not 关键字应用于整个媒体查询，在媒体查询为假时返回真 (比如 monochrome 应用于彩色显示设备上或一个600像素的屏幕应用于 min-width: 700px 属性查询上 )。在逗号媒体查询列表中 not 仅会否定它应用到的媒体查询上而不影响其它的媒体查询。 not 在下面的查询中最后被计算：@media not all and (monochrome) &#123; ... &#125;等价于：@media not (all and (monochrome)) &#123; ... &#125;而不是：@media (not all) and (monochrome) &#123; ... &#125; only only 关键字防止老旧的浏览器不支持带媒体属性的查询而应用到给定的样式：&lt;link rel=&quot;stylesheet&quot; media=&quot;only screen and (color)&quot; href=&quot;example.css&quot; /&gt; Media所有参数汇总以上就是我们最常需要用到的媒体查询器的几个特性，其他参数用法解释： width: 浏览器可视宽度。 height: 浏览器可视高度。 device-width: 设备屏幕的宽度。 device-height: 设备屏幕的高度。 orientation: 检测设备目前处于横向还是纵向状态。 aspect-ratio: 检测浏览器可视宽度和高度的比例。(例如：aspect-ratio:16/9) device-aspect-ratio: 检测设备的宽度和高度的比例。 color: 检测颜色的位数。（例如：min-color:32就会检测设备是否拥有32位颜色） color-index: 检查设备颜色索引表中的颜色，他的值不能是负数。 monochrome: 检测单色楨缓冲区域中的每个像素的位数。（这个太高级，估计咱很少会用的到） resolution: 检测屏幕或打印机的分辨率。(例如：min-resolution:300dpi或min-resolution:118dpcm)。 grid: 检测输出的设备是网格的还是位图设备。 常见媒体查询//实际应用一 判断设备横竖屏：/* 这是匹配横屏的状态，横屏时的css代码 */@media all and (orientation :landscape)&#123;&#125;/* 这是匹配竖屏的状态，竖屏时的css代码 */@media all and (orientation :portrait)&#123;&#125;//实际应用二 判断设备类型：@media X and (min-width:200px)&#123;&#125;X为设备类型》比如print/screen/TV等等//实际应用三 判断设备宽高：/* 宽度大于600px小于960之间时，隐藏footer结构 */@media all and (min-height:640px) and (max-height:960px)&#123; footer&#123;display:none;&#125;&#125; 组织媒体查询第一个方法是为不同屏幕大小指定完全不同的样式表。规则可以保存在独立样式表中，这使得显示逻辑能够清楚地划分出来，更便于团队进行维护。另一个优势是源代码分支之间的合并变得更为容易。缺点是如果要为每个媒体查询创建单独的样式表，则无法将一个元素的所有样式表放在同一文件夹的同一位置。当改变一个 CSS 中的一个元素时，需要创建多个位置进行查看，这使得网站 CSS 的维护变得更加困难。 第二个方法是在现有样式表中使用媒体查询，该样式表就在定义其余元素样式表的位置的旁边。这种方法的优势是可以将所有元素样式保存在同一个位置。当在团队模式下工作时，这种做法可以创建更多源代码合并工作，但这是所有基于团队的软件开发都可以管理且常见的一部分。 没有所谓正确或错误方法。只需选择最适合的方法即可。 浏览器兼容加载兼容文件JS因为IE8既不支持HTML5也不支持CSS3 Media，所以我们需要加载JS文件，来保证我们的代码实现兼容效果。Respond.js 是一个极小的增强 Web 浏览器的 JavaScript 库，使得原本不支持 CSS 媒体查询的浏览器能够支持它们。该脚本循环遍历页面上的所有 CSS 引用，并使用媒体查询分析 CSS 规则。然后，该脚本会监控浏览器宽度变化，添加或删除与 CSS 中媒体查询匹配的样式。最终结果是，能够在原本不支持的浏览器上运行媒体查询： &lt;!--[if lt IE 9]&gt; &lt;script src=&quot;libs/respond.js/&quot;&gt;&lt;/script&gt;&lt;![endif]--&gt; 设置IE渲染方式默认为最高(这部分可以选择添加也可以不添加)现在有很多人的IE浏览器都升级到IE9以上了，所以这个时候就有又很多诡异的事情发生了，例如现在是IE9的浏览器，但是浏览器的文档模式却是IE8:为了防止这种情况，我们需要下面这段代码来让IE的文档模式永远都是最新的： &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=Edge&quot;&gt;&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=Edge，chrome=1&quot;&gt; 如果有的用户电脑里面装了这个chrome的插件，chrome=1就可以让电脑里面的IE不管是哪个版本的都可以使用Webkit引擎及V8引擎进行排版及运算。 参考1. 使用 CSS 媒体查询创建响应式网站2. CSS媒体查询3. 520UED4. css3媒体查询实现网站响应式布局","categories":[{"name":"css","slug":"css","permalink":"http://tcatche.site/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"http://tcatche.site/tags/css/"}]},{"title":"css3特效","slug":"css3-transition-transform-animation","date":"2016-03-31T03:55:09.000Z","updated":"2018-08-01T10:41:24.000Z","comments":true,"path":"2016/03/css3-transition-transform-animation/","link":"","permalink":"http://tcatche.site/2016/03/css3-transition-transform-animation/","excerpt":"","text":"Transform 转换Transform 属性向元素应用 2D 或 3D 转换，该属性允许我们对元素进行旋转、缩放、移动或倾斜，主要有以下几个方法：translate()、rotate()、scale()、skew()、matrix()。 JavaScript 语法: object.style.transform=&quot;rotate(xdeg)&quot;Css语法：transform: none|transform-functions; Transform 属性: transform 向元素应用 2D 或 3D 转换。 transform-origin 允许你改变被转换元素的位置。 transform-style 规定被嵌套元素如何在 3D 空间中显示。 perspective 规定 3D 元素的透视效果。 perspective-origin 规定 3D 元素的底部位置。 backface-visibility 定义元素在不面对屏幕时是否可见。 浏览器支持: Internet Explorer 10、Firefox、Opera 支持 transform 属性。 Safari 和 Chrome 支持替代的 -webkit-transform 属性（3D 和 2D 转换）。 Internet Explorer 9 要求前缀 -ms- 版本（仅适用于 2D 转换）。 Opera 只支持 2D 转换。 translate()元素根据给定的 left（x 坐标） 和 top（y 坐标） 位置参数，从其当前位置移动。 translate(x, y) 定义 2D 转换，沿着 X 和 Y 轴移动元素。 translateX(n) 定义 2D 转换，沿着 X 轴移动元素。 translateY(n) 定义 2D 转换，沿着 Y 轴移动元素。 translateZ(z) 定义 3D 转化，仅使用用于 Z 轴的值。 语法： transform: translate(x, y);transform: translateX(n);transform: translateY(n); Examples: /* 使div向左偏移10px， 向上偏移20px */div &#123;2transform : translate(10px, 20px);2-ms-transform : translate(10px, 20px); /* IE 9 */2-webkit-transform : translate(10px, 20px); /* Safari and Chrome */2-o-transform : translate(10px, 20px); /* Opera */2-moz-transform : translate(10px, 20px); /* Firefox */&#125; rotate()元素旋转给定的角度。rotate共包含三个方法： rotate(n) 元素顺时针旋转给定的角度。允许负值，元素将逆时针旋转（2D转换）。 rotateX(x) 元素围绕其 X 轴以给定的度数进行旋转（3D转换）。 rotateY(y) 元素围绕其 Y 轴以给定的度数进行旋转（3D转换）。 rotate3d(x, y, z, angle) 定义 3D 旋转。 语法： transform: rotate(n);transform: rotateX(x);transform: rotateY(y);transform: rotate3d(x, y, z, angle); Examples: /* 使div顺时针旋转20° */div &#123;2transform : rotate(20deg);2-ms-transform : rotate(20deg); /* IE 9 */2-webkit-transform : rotate(20deg); /* Safari and Chrome */2-o-transform : rotate(20deg); /* Opera */2-moz-transform : rotate(20deg); /* Firefox */&#125; scale()元素的尺寸会增加或减少，根据给定的宽度（X 轴）和高度（Y 轴）参数。 scale(x, y) 定义 2D 缩放转换，改变元素的宽度和高度。 scale3d(x, y, z) 定义 3D 缩放转换。 scaleX(x) 定义 2D 缩放转换，改变元素的宽度。 scaleY(y) 定义 2D 缩放转换，改变元素的高度。 scaleZ(z) 定义 3D 缩放转换，通过给定一个 Z 轴的值。 语法： transform: scale(x, y);transform: scaleX(x);transform: scaleY(y); Examples: /* 使div宽度转换为原始尺寸的 2 倍，把高度转换为原始高度的 4 倍。 */div &#123;2transform : translate(2, 4);2-ms-transform : translate(2, 4); /* IE 9 */2-webkit-transform : translate(2, 4); /* Safari and Chrome */2-o-transform : translate(2, 4); /* Opera */2-moz-transform : translate(2, 4); /* Firefox */&#125; skew()元素翻转给定的角度，根据给定的水平线（X 轴）和垂直线（Y 轴）参数。 skew(x-angle, y-angle) 定义 2D 倾斜转换，沿着 X 和 Y 轴。 skewX(angle) 定义 2D 倾斜转换，沿着 X 轴。 skewY(angle) 定义 2D 倾斜转换，沿着 Y 轴。 语法： transform: skew(x-angle, y-angle);transform: skewX(angle);transform: skewY(angle); Examples: /* 使div 围绕 X 轴把翻转 30 度，围绕 Y 轴翻转 20 度。 */div &#123;2transform : translate(20deg, 40deg);2-ms-transform : translate(20deg, 40deg); /* IE 9 */2-webkit-transform : translate(20deg, 40deg); /* Safari and Chrome */2-o-transform : translate(20deg, 40deg); /* Opera */2-moz-transform : translate(20deg, 40deg); /* Firefox */&#125; matrix()暂时跳过，后续研究 Transition 过渡过渡是元素从一种样式逐渐改变为另一种的效果，要实现这一点，必须规定两项内容： 规定您希望把效果添加到哪个 CSS 属性上 规定效果的时长 当指定的 CSS 属性改变值改变出发时（比如hover,必须指定触发后会改变的style样式），过渡效果开始，如果时长未规定，则不会有过渡效果，因为默认值是 0。 语法： transition: style time;transition: style1 time1, style2 time2..., stylen timen; 过渡属性: transition 简写属性，用于在一个属性中设置四个过渡属性。 transition-property 规定应用过渡的 CSS 属性的名称。 transition-duration 定义过渡效果花费的时间。默认是 0。 transition-timing-function 规定过渡效果的时间曲线。默认是 “ease”。 transition-delay 规定过渡效果何时开始。默认是 0。 Examples: /*div:hover指定了hover时的三个变化的样式：width，height和transform，在transtion属性仅仅指定了width和transform，因此当div悬停时，width和transform会在两秒内过渡到:hover,而height没有过渡直接变化。*/div &#123;2width:100px;2height:100px;2background:yellow;2transition:width 2s, transform 2s;2-moz-transition:width 2s, height 2s, -moz-transform 2s; /* Firefox 4 */2-webkit-transition:width 2s, height 2s, -webkit-transform 2s; /* Safari and Chrome */2-o-transition:width 2s, height 2s, -o-transform 2s; /* Opera */&#125;div:hover &#123;2width:200px;2height:200px;2transform:rotate(180deg);2-moz-transform:rotate(180deg); /* Firefox 4 */2-webkit-transform:rotate(180deg); /* Safari and Chrome */2-o-transform:rotate(180deg); /* Opera */&#125; 浏览器支持: Internet Explorer 10、Firefox、Chrome 以及 Opera 支持 transition 属性。 Safari 和 Chrome 25 以及更早的版本需要前缀 -webkit-。 Internet Explorer 9 以及更早的版本，不支持 transition 属性。 animation和@keyframes动画@keyframes 规则用于创建动画。在 @keyframes 中规定某项 CSS 样式，就能创建由当前样式逐渐改为新样式的动画效果。animation 用于把 @keyframes 中创建的动画捆绑到某个css选择器。用百分比来规定变化发生的时间，或用关键词 from 和 to，等同于 0% 和 100%。0% 是动画的开始，100% 是动画的完成。为了得到最佳的浏览器支持，应该始终定义 0% 和 100% 选择器。必须定义动画的名称和时长。如果忽略时长，则动画不会允许，因为默认值是 0。 属性: @keyframes 规定动画。 animation 所有动画属性的简写属性，除了 - `animation-play-state 属性。 animation-name 规定 @keyframes 动画的名称。 animation-duration 规定动画完成一个周期所花费的秒或毫秒。默认是 0。 animation-timing-function 规定动画的速度曲线。默认是 “ease”。 animation-delay 规定动画何时开始。默认是 0。 animation-iteration-count 规定动画被播放的次数。默认是 1。 animation-direction 规定动画是否在下一周期逆向地播放。默认是 “normal”。 animation-play-state 规定动画是否正在运行或暂停。默认是 “running”。 animation-fill-mode 规定对象动画时间之外的状态。 Examples: /*@keyframes 定义一个动画动画开始时背景颜色为red，当动画进度为100%时，背景颜色为yellow*/@keyframes frames &#123;2from &#123;22background: red;2&#125;2to &#123;22background: yellow;2&#125;&#125;/* 或者： */@keyframes frames &#123;20% &#123;22background: red;2&#125;2100% &#123;22background: yellow;2&#125;&#125;/* Firefox */@-moz-keyframes frames &#123;2from &#123;22background: red;2&#125;2to &#123;22background: yellow;2&#125;&#125;/* Safari 和 Chrome */@-webkit-keyframes frames &#123;2from &#123;22background: red;2&#125;2to &#123;22background: yellow;2&#125;&#125;/* Opera */@-o-keyframes frames &#123;2from &#123;22background: red;2&#125;2to &#123;22background: yellow;2&#125;&#125;/* animation 把 &quot;frames&quot; 动画捆绑到 div 元素，时长：5 秒： */div &#123;2animation: frames 5s;2-moz-animation: frames 5s; /* Firefox */2-webkit-animation: frames 5s; /* Safari 和 Chrome */2-o-animation: frames 5s; /* Opera */&#125; 浏览器支持: Internet Explorer 10、Firefox 以及 Opera 支持 @keyframes 规则和 animation 属性。 Chrome 和 Safari 需要前缀 -webkit-。 Internet Explorer 9，以及更早的版本，不支持 @keyframes 规则或 animation 属性。 参考：[1.CSS3 教程](http:/* www.w3school.com.cn/css3/index.asp) 进阶：[1.理解CSS3 transform中的Matrix(矩阵)](http:/* blog.csdn.net/henren555/article/details/9699449)[2.好吧，CSS3 3D transform变换，不过如此！](http:/* www.zhangxinxu.com/wordpress/2012/09/css3-3d-transform-perspective-animate-transition/)","categories":[{"name":"css","slug":"css","permalink":"http://tcatche.site/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"http://tcatche.site/tags/css/"}]},{"title":"Jquery整体架构","slug":"Jquery-source-code-study","date":"2016-03-31T03:55:09.000Z","updated":"2018-11-11T08:29:58.000Z","comments":true,"path":"2016/03/Jquery-source-code-study/","link":"","permalink":"http://tcatche.site/2016/03/Jquery-source-code-study/","excerpt":"","text":"[TOC] ##1.理解架构 ###1.1 最新jQuery2.1.1版本的结构： ;(function(global, factory) &#123; factory(global);&#125;(typeof window !== &quot;undefined&quot; ? window : this, function(window, noGlobal) &#123; var jQuery = function( selector, context ) &#123;222return new jQuery.fn.init( selector, context );22&#125;;22jQuery.fn = jQuery.prototype = &#123;&#125;;22// 核心方法22// 回调系统22// 异步队列22// 数据缓存22// 队列操作22// 选择器引22// 属性操作22// 节点遍历22// 文档处理22// 样式操作22// 属性操作22// 事件体系22// AJAX交互22// 动画引擎22return jQuery;&#125;)); ###1.2 jQuery模块依赖 ###1.3 jQuery的类数组对象结构通过 $(&quot;.Class&quot;) 构建的对象结构如下所示：整个结构很明了，通过对象键值对的关系保存着属性，原型保存着方法。我们来简单的模拟一个这样的数据结构： var aQuery = function(selector) &#123; //强制为对象2if (!(this instanceof aQuery)) &#123;22return new aQuery(selector);2&#125;2var elem = document.getElementById(/[^#].*/.exec(selector)[0]);2this.length = 1;2this[0] = elem;2this.context = document;2this.selector = selector;2this.get = function(num) &#123;22return this[num];2&#125;2return this;&#125; 函数 aQuery() 内部首先保证了必须是通过 new 操作符构建。这样就能保证当前构建的是一个带有 this 的实例对象，既然是对象我们可以把所有的属性与方法作为对象的key与value的方式给映射到this上，所以如上结构就可以模拟出jQuery的这样的操作了，即可通过索引取值，也可以链式方法取值，但是这样的结构是有很大的缺陷的，每次调用ajQuery方法等于是创建了一个新的实例，那么类似get方法就要在每一个实例上重新创建一遍，性能就大打折扣，所以jQuery在结构上的优化不仅仅只是我们看到的，除了实现类数组结构、方法的原型共享，而且还实现方法的静态与实例的共存。 ###1.4 jQuery中ready与load事件jQuery有3种针对文档加载的方法： $(document).ready(function() &#123; // ...代码...&#125;)//document ready 简写$(function() &#123; // ...代码...&#125;)$(document).load(function() &#123; // ...代码...&#125;) DOM文档加载的步骤： 解析HTML结构。 加载外部脚本和样式表文件。 解析并执行脚本代码。 构造HTML DOM模型。//ready 加载图片等外部文件。 页面加载完毕。//load ready与load的区别就在于资源文件的加载，ready构建了基本的DOM结构，所以对于代码来说应该越快加载越好。ready在第 4 步完成之后就执行了，但是load要在第 6 步完成之后才执行。 ###1.5 jQuery多库共存处理引入jQuery运行这个 noConflict 函数将变量 $ 的控制权让给第一个实现它的那个库，确保jQuery不会与其他库的$对象发生冲突。在运行这个函数后，就只能使用jQuery变量访问jQuery对象。 Example: //让出控制权$.noConflict();//使用noConflict后，$不存在if (!$) &#123;2console.log(&quot;使用noConflict后，$不存在&quot;)&#125;//使用noConflict后，jQuery存在if (jQuery) &#123;2console.log(&quot;使用noConflict后，jQuery存在&quot;)&#125;//通过闭包隔离出$,通过闭包隔离后，转为局部变量$存在;(function($) &#123;2if ($) &#123;22console.log(&quot;通过闭包隔离后，转为局部变量$存在&quot;)2&#125;&#125;)(jQuery); 实现原理： Var _jQuery = window.jQuery, _$ = window.$;jQuery.noConflict = function( deep ) &#123; if ( window.$ === jQuery ) &#123; window.$ = _$; &#125;2if ( deep &amp;&amp; window.jQuery === jQuery ) &#123; window.jQuery = _jQuery; &#125; return jQuery;&#125;; jQuery在占用 $ 时，已经把之前的存在的命名空间给缓存起来， noConflict 通过对比当前的命名空间达到交换的目的: 首先，先判断下当前的 $ 空间是不是被jQuery接管了，如果是则让出控制权给之前的 _$ 引用的库，如果传入 deep 为 true 的话等于是把 jQuery 的控制权也让出去了。 ##2.核心模块 ###2.1 分离构造器通过new操作符构建一个对象，一般经过四步： 1.创建一个新对象2.将构造函数的作用域赋给新对象（所以this就指向了这个新对象）3.执行构造函数中的代码4.返回这个新对象 最后一点就说明了，我们只要返回一个新对象即可。其实new操作符主要是把原型链跟实例的this关联起来，这才是最关键的一点，所以我们如果需要原型链就必须要new操作符来进行处理。否则this则变成window对象了。 我们来剖析下jQuery的这个结构,以下是我们常见的类式写法: var $$ = ajQuery = function(selector) &#123; this.selector = selector; return this&#125;ajQuery.fn = ajQuery.prototype = &#123; selectorName:function()&#123; return this.selector; &#125;, constructor: ajQuery&#125;var a = new $$(&#x27;aaa&#x27;); //实例化a.selectorName() //aaa //得到选择器名字 首先改造jQuery无new的格式，我们可以通过instanceof判断this是否为当前实例： var $$ = ajQuery = function(selector) &#123; if(!(this instanceof ajQuery))&#123; return new ajQuery(selector); &#125; this.selector = selector; return this;&#125; 但是注意千万不要像下面这样写： //错误 这样会无限递归自己，从而造成死循环并且溢出。var $$ = ajQuery = function(selector) &#123; this.selector = selector; return new ajQuery(selector);&#125;Uncaught RangeError: Maximum call stack size exceeded jQuery为了避免出现这种死循环的问题，采取的手段是把原型上的一个init方法作为构造器 var $$ = ajQuery = function(selector) &#123; //把原型上的init作为构造器 return new ajQuery.fn.init( selector );&#125;ajQuery.fn = ajQuery.prototype = &#123; init: function() &#123; // init ajQuery; &#125;, constructor: jQuery&#125; 这样确实解决了循环递归的问题，但是又问题来了，init是ajQuery原型上作为构造器的一个方法，那么其this就不是ajQuery了，所以this就完全引用不到ajQuery的原型了,也就无法引用到ajQuery原型上定义的一系列方法。 ###2.2 静态与实例方法共享设计上一节提到分离后的构造器无法访问ajQuery原型上定义的一系列方法，jQuery给出如下方案： ajQuery.fn = ajQuery.prototype = &#123; name: &#x27;ajQuery&#x27;, init: function(selector) &#123; this.selector = selector; return this; &#125;, constructor: ajQuery&#125;ajQuery.fn.init.prototype = ajQuery.fn; 这段代码就是整个结构设计的最核心的东西了，把jQuery.prototype原型的引用赋给jQuery.fn.init.prototype的原型，这样就把2个构造器的原型给关联起来了，整个结构就活了！不得不佩服作者的设计思路，别具匠心。 init的构造图:通过原型传递解决问题，把jQuery的原型传递给jQuery.prototype.init.prototype。换句话说jQuery的原型对象覆盖了init构造器的原型对象，因为是引用传递所以不需要担心这个循环引用的性能问题。 ###2.3 插件接口的设计jQuery插件的开发分为两种： 一种是挂在jQuery命名空间下的全局函数，也可称为静态方法； 另一种是jQuery对象级别的方法，即挂在jQuery原型下的方法，这样通过选择器获取的jQuery对象实例也能共享该方法。 提供的接口：$.extend(target, [object1], [objectN]) jQuery的代码实现： jQuery.extend = jQuery.fn.extend = function() &#123;2var options,22target = arguments[0] || &#123;&#125;,22i = 1,22length = arguments.length,2// Extend jQuery itself if only one argument is passed2if ( i === length ) &#123;22target = this; //this决定这个方法是作为静态扩展还是实例扩展处理22i--;2&#125;2for ( ; i &lt; length; i++ ) &#123;22// Only deal with non-null/undefined values22if ( (options = arguments[ i ]) != null ) &#123;222// Extend the base object22&#125;2&#125;2// Return the modified object2return target;&#125;; 从jQuery的源码中可以看到，jQuery.extend和jQuery.fn.extend其实是同指向同一方法的不同引用。这里有一个设计的重点，通过调用的上下文，我们来确定这个方法是作为静态还是实例处理： jQuery.extend 调用的时候，this是指向jQuery对象，所以这里扩展在jQuery上，作为静态方法。 jQuery.fn.extend 调用的时候，this指向jQuery.fn对象，jQuery.fn 和jQuery.prototype指向同一对象，扩展fn就是扩展jQuery.prototype原型对象，因此这里增加的是原型方法，也就是对象方法了。 接口的使用： //挂在jQuery命名空间下的全局函数,扩展后可以通过jQuery.data()和jQuery.removeData()访问，//但是通过选择器获取的对象实例jQuery()不具有此方法，jQuery().data() 和 jQuery().removeData()无法访问jQuery.extend(&#123; data: function()&#123;&#125;, removeData: function()&#123;&#125;&#125;);//挂在jQuery原型下的方法,扩展后可以通过jQuery的实例对象访问，jQuery().data() 和 jQuery().removeData()//但是jQuery命名空间下不存在此方法，jQuery.data()和jQuery.removeData()无法访问jQuery.fn.extend(&#123; data: function()&#123;&#125;, removeData: function()&#123;&#125;&#125;); 注意： 根据传入的参数不同，当参数仅仅传入一个对象时是对jquery功能的扩展，如果传入多个对象时，将用扩展传入的第一个对象，此过程与本节内容无关，不再讨论。 ###2.4 回溯处理jQuery每次dom操作会返回一个jQuery对象而非dom对象，jQuery对象实际上是对dom对象的一层包装，每个jQuery对象都有三个属性：context 、selector 和 prevObject ，其中的 prevObject 属性就指向这个对象栈中的前一个对象，而通过这个属性可以回溯到最初的DOM元素集中。 在浏览器可以看到jQuery对象属性： jQuery内部维护着一个jQuery对象栈。每个遍历方法都会找到一组新元素（一个jQuery对象），然后jQuery会把这组元素推入到栈中。 jQuery为我们操作这个内部对象栈提供个非常有用的2个方法: .end() //回溯到之前的Dom元素集合.addBack()/.andSelf()(jQ1.8+) //回溯之前一个位置，然后把两个位置上的元素集组合起来，并把这个新的、组合之后的元素集推入栈的上方。 end() 方法主要用于jQuery的链式属性中。当没有使用链式用法时，我们通常只是调用变量名上的前一个对象，所以我们不需要操作栈。 Exapmple: &lt;ul class=&quot;first&quot;&gt; &lt;li class=&quot;foo&quot;&gt;list item 1&lt;/li&gt; &lt;li class=&quot;bar&quot;&gt;list item 2&lt;/li&gt;&lt;/ul&gt;&lt;ul class=&quot;second&quot;&gt; &lt;li class=&quot;foo&quot;&gt;list item 1&lt;/li&gt; &lt;li class=&quot;bar&quot;&gt;list item 2&lt;/li&gt;&lt;/ul&gt; //设置.first .foo颜色黑色，.first .foo颜色红色////首先在链式用法中只在第一个列表中查找样式为 foo 的项目，并将其颜色变成黑色。//然后end()返回调用find()之前的状态。//因此，第二次 find() 将只会查找 &lt;ul class=&quot;first&quot;&gt; 中的 &#x27;.bar&#x27;，//而不是继续在&lt;li class=&quot;foo&quot;&gt;中进行查找，结果是将匹配到的元素的颜色变成红色。$(&#x27;.first&#x27;).find(&#x27;.foo&#x27;).css(&#x27;color&#x27;, &#x27;black&#x27;).end().find(&#x27;.bar&#x27;).css(&#x27;color&#x27;, &#x27;red&#x27;);//错误//$(&#x27;.first&#x27;).find(&#x27;.foo&#x27;).css(&#x27;color&#x27;, &#x27;black&#x27;)后此时上下文已切换为.first .foo//.find(&#x27;.bar&#x27;)无法找到该元素，故需要.end()回溯至上一步$(&#x27;.first&#x27;).find(&#x27;.foo&#x27;).css(&#x27;color&#x27;, &#x27;black&#x27;).find(&#x27;.bar&#x27;).css(&#x27;color&#x27;, &#x27;red&#x27;); jQuery的代码实现： //可以看到end方法返回prevObject属性end: function() &#123; return this.prevObject || this.constructor(null); &#125;//在调用find方法查找元素时，通过pushStack方法构建jQuery对象，并返回find: function(selector) &#123;2//...........................省略................................ //通过sizzle选择器，返回结果集 jQuery.find(selector, self[i], ret); // Needed because $( selector, context ) becomes $( context ).find( selector ) ret = this.pushStack(len &gt; 1 ? jQuery.unique(ret) : ret); ret.selector = this.selector ? this.selector + &quot; &quot; + selector : selector; return ret;&#125;//pushStack对象，作用就通过新的DOM元素去创建一个新的jQuery对象pushStack: function( elems ) &#123; // Build a new jQuery matched element set var ret = jQuery.merge( this.constructor(), elems ); // Add the old object onto the stack (as a reference) ret.prevObject = this; ret.context = this.context; // Return the newly-formed element set return ret;&#125;//constructor是指向构造器jQuery.fn = jQuery.prototype = &#123;2//...........................省略................................2constructor: jQuery,&#125; 流程解析： 首先构建一个新的jQuery对象，因为constructor是指向构造器的，所以这里就等同于调用jQuery()方法了，返回了一个新的jQuery对象； 然后用jQuery.merge语句把elems节点合并到新的jQuery对象上； 最后给返回的新jQuery对象添加prevObject属性，我们看到prevObject其实还是当前jQuery的一个引用罢了，所以也就是为什么通过prevObject能取到上一个合集的原因了。 addBack() 和 addSelf() 方法与 end() 类似，多了一步合并当前对象的操作，不再赘述。 add: function( selector, context ) &#123;2return this.pushStack(22jQuery.unique(222jQuery.merge( this.get(), jQuery( selector, context ) )22)2);&#125;,addBack: function( selector ) &#123;2return this.add( selector == null ?22this.prevObject : this.prevObject.filter(selector)2);&#125;jQuery.fn.andSelf = jQuery.fn.addBack; ###2.5 迭代器迭代器是一个框架的重要设计。我们经常需要提供一种方法顺序用来处理聚合对象中各个元素，而又不暴露该对象的内部，这也是设计模式中的迭代器模式(Iterator)。针对迭代器，有几个特点： 访问一个聚合对象的内容而无需暴露它的内部。 为遍历不同的集合结构提供一个统一的接口，从而支持同样的算法在不同的集合结构上进行操作。 遍历的同时更改迭代器所在的集合结构可能会导致问题。 除此之外，还要考虑支持以下至少四种情况： 支持聚合对象，可能是对象，字符串或者数组等类型 支持参数传递 支持上下文的传递 支持循环中退出 jQuery.each() 实现： each: function( obj, callback, args ) &#123;2var value,22i = 0,22length = obj.length,22isArray = isArraylike( obj );2//支持参数传递2if ( args ) &#123;22if ( isArray ) &#123;222for ( ; i &lt; length; i++ ) &#123;2222value = callback.apply( obj[ i ], args );2222if ( value === false ) &#123;22222break;2222&#125;222&#125;22&#125; else &#123;222for ( i in obj ) &#123;2222value = callback.apply( obj[ i ], args );2222if ( value === false ) &#123;22222break;2222&#125;222&#125;22&#125;2// A special, fast, case for the most common use of each2&#125; else &#123;22//支持对象，或者数组22if ( isArray ) &#123;222for ( ; i &lt; length; i++ ) &#123;2222//call直接把obj[i]作为上下文即callback回调中的this传递进去，2222value = callback.call( obj[ i ], i, obj[ i ] );2222//支持循环中退出2222//根据回调的处理，从而判断是否要立刻中断这个循环，2222//通过回调函数callback返回的ture/false的布尔值结果就可以来判断当前是否要强制退出循环。2222if ( value === false ) &#123;22222break;2222&#125;222&#125;22&#125; else &#123;222for ( i in obj ) &#123;2222value = callback.call( obj[ i ], i, obj[ i ] );2222if ( value === false ) &#123;22222break;2222&#125;222&#125;22&#125;2&#125;2return obj;&#125;, jQuery的each方法从使用上就要分2种： $.each() $(selector).each() $(selector).each() 的实现 each: function(callback, args) &#123; return jQuery.each(this, callback, args); //调用$.each()静态方法&#125;, jQuery可以是多个合集数组DOM，所以在处理的时候经常就针对每一个DOM都要单独处理，所以一般都需要调用 $(selector).each() 方法，接口的抽象合并在jQuery内部的运用很多，把相同功能的代码功能合并处理。 ##3.回调Callbacks ###3.1 运用回调我们经常会在这些情况使用函数回调： 事件触发通知 资源加载通知 定时器延时 ajax、动画通知等等。 以上都是很单一的事件监听回调的处理方式，但是jQuery把回调函数的用法设计成一个更高的抽像，用于解耦与分离变化。 例如： jQuery针对Dom的处理提供了append 、prepend 、before 、after 等方法的处理，这几个方法的特征： 参数的传递可以是HTML字符串、DOM元素、元素数组或者jQuery对象 为了优化性能针对节点的处理需要生成文档碎片 实现代码： //callback 省略//append: function() &#123;2return this.domManip( arguments, callback);&#125;,prepend: function() &#123;2return this.domManip( arguments, callback);&#125;,before: function() &#123;2return this.domManip( arguments, callback);&#125;,after: function() &#123;2return this.domManip( arguments, callback);&#125;domManip: function(args, callback) &#123; // Flatten any nested arrays args = concat.apply([], args); // We can&#x27;t cloneNode fragments that contain checked, in WebKit if (isFunction || //多参数处理 self.domManip(args, callback); &#125; if (l) &#123; //生成文档碎片 fragment = jQuery.buildFragment(args, this[0].ownerDocument, false, this); callback.call(this[i], node, i); &#125; return this;&#125; jQuery通过抽象出一个domManip方法，然后在这个方法中处理共性，合并多个参数的处理与生成文档碎片的处理，然后最终把结果通过回调函数返回给每一个调用者。 ###3.2 观察者模式观察者模式也即发布/订阅模式的背后，总的想法是在应用程序中增强松耦合性。并非是在其它对象的方法上的单个对象调用。一个对象作为特定任务或是另一对象的活动的观察者，并且在这个任务或活动发生时，通知观察者。 观察者的使用场合就是：当一个对象的改变需要同时改变其它对象，并且它不知道具体有多少对象需要改变的时候，就应该考虑使用观察者模式。 JS里对观察者模式的实现是通过回调来实现的，我们来先定义一个Observable对象，其内部包含了2个方法：订阅add方法与发布fire方法，如下代码： var Observable = &#123;2callbacks: [],2add: function(fn) &#123;22this.callbacks.push(fn);2&#125;,2fire: function() &#123;22this.callbacks.forEach(function(fn) &#123;222fn();22&#125;)2&#125;&#125; 使用add开始订阅： Observable.add(function() &#123;2alert(1)&#125;)Observable.add(function() &#123;2alert(2)&#125;) 使用fire开始发布： Observable.fire(); // 1, 2 ###3.3 观察者模式运用假设一段ajax的请求，成功后通过done返回结果数据： $.ajax(&#123;2url: &quot;test.html&quot;,2context: document.body&#125;).done(function(data) &#123;2//data数据的处理2$(&#x27;aaron1&#x27;).html(data.a)2$(&#x27;aaron2&#x27;).html(data.b)2$(&#x27;aaron3&#x27;).html(data.c)2//其余处理&#125;); 所有的逻辑都写在done方法里面，虽然可以使用，但是问题就是逻辑太复杂了。Done里面有数据处理、html渲染、还可能有其它不同场景的业务逻辑。这样如果是换做不同的人去维护代码，增加功能就会显得很混乱而且没有扩展性。那么观察者模式能很好的解决了这个的问题。 试着优化代码: $.ajax(&#123;2url: &quot;test.html&quot;,2context: document.body&#125;).done(function(data) &#123;2pocessData()2pocessHtml()2pocessOther()&#125;function pocessData() &#123;//处理数据&#125;function pocessHtml() &#123;2$(&#x27;aaron1&#x27;).html(data.a)2$(&#x27;aaron2&#x27;).html(data.b)2$(&#x27;aaron3&#x27;).html(data.c)&#125;function pocessOther() &#123;//处理其他逻辑&#125; 这种方式的好处是，分离出各种的业务函数，从而降低了代码之间的耦合度，但是这样代码写法几乎就是“就事论事”的处理，达不到抽象复用。 使用之前的观察者模式再次优化上面的代码： Observable.add(function() &#123;2//pocessData&#125;)Observable.add(function() &#123;2$(&#x27;aaron1&#x27;).html(data.a)2$(&#x27;aaron2&#x27;).html(data.b)2$(&#x27;aaron3&#x27;).html(data.c)&#125;)Observable.add(function() &#123;2//pocessOther&#125;)$.ajax(&#123;2url: &quot;test.html&quot;,2context: document.body&#125;).done(function(data) &#123;2Observable.fire(data)&#125;) 设计该模式背后的主要动力是促进形成松散耦合。在这种模式中，并不是一个对象调用另一个对象的方法，而是一个对象订阅另一个对象的特定活动并在状态改变后获得通知。订阅者也称为观察者，而被观察的对象称为发布者或主题。当发生了一个重要的事件时，发布者将会通知（调用）所有订阅者并且可能经常以事件对象的形式传递消息。 ###3.4 jQuery回调模块Callbacks$.Callbacks是一个工厂函数，使用函数调用创建对象，它有一个可选参数 flags 用来设置回调函数的行为，对外的接口也就是self的返回。 jQuery.Callbacks()的API： callbacks.add() : 回调列表中添加一个回调或回调的集合。 callbacks.disable() : 禁用回调列表中的回调。 callbacks.disabled() : 确定回调列表是否已被禁用。 callbacks.empty() : 从列表中删除所有的回调。 callbacks.fire() : 用给定的参数调用所有的回调。 callbacks.fired() : 访问给定的上下文和参数列表中的所有回调。 callbacks.fireWith() : 访问给定的上下文和参数列表中的所有回调。 callbacks.has() : 确定列表中是否提供一个回调。 callbacks.lock() : 锁定当前状态的回调列表。 callbacks.locked() : 确定回调列表是否已被锁定。 callbacks.remove() : 从回调列表中的删除一个回调或回调集合。 参数列表： once : 确保这个回调列表只执行（ .fire() ）一次(像一个递延 Deferred)。 memory : 保持以前的值，将添加到这个列表的后面的最新的值立即执行调用任何回调 (像一个递延 Deferred)。 unique : 确保一次只能添加一个回调(所以在列表中没有重复的回调)。 stopOnFalse : 当一个回调返回false 时中断调用。 实现代码： jQuery.Callbacks = function(options) &#123; options = typeof options === &quot;string&quot; ? (optionsCache[options] || createOptions(options)) : jQuery.extend(&#123;&#125;, options); //实现代码 fire = function() &#123;&#125; self = &#123; add: function() &#123;&#125;, remove: function() &#123;&#125;, has: function(fn) &#123;&#125;, empty: function() &#123;&#125;, disable: function() &#123;&#125;, disabled: function() &#123;&#125;, lock: function() &#123;&#125;, locked: function() &#123;&#125;, fireWith: function(context, args) &#123;&#125;, fire: function() &#123;&#125;, fired: function() &#123;&#125; &#125;; return self;&#125;; 整个结构要分三部分： Options参数缓存 内部fire触发器的设计 外部 参数的缓存设计： // Callbacks是可以是接受的字符串的组合传参数，可以使用空格分割，// 这样的操作其实是不需要重复的，可以设计一个缓存池，用来储存重复的操作// jQuery把这些操作抽象出来作为内部通用工具代码options = typeof options === &quot;string&quot; ?22( optionsCache[ options ] || createOptions( options ) ) :22jQuery.extend( &#123;&#125;, options );// jQuery 通用的缓存池设计代码// String to Object options format cachevar optionsCache = &#123;&#125;;// Convert String-formatted options into Object-formatted ones and store in cachefunction createOptions( options ) &#123;2var object = optionsCache[ options ] = &#123;&#125;;2jQuery.each( options.match( rnotwhite ) || [], function( _, flag ) &#123;22object[ flag ] = true;2&#125;);2return object;&#125;// jQuery 通用的字符串转参数对象代码var rnotwhite = (/\\S+/g);// String to Object options format cachevar optionsCache = &#123;&#125;;// Convert String-formatted options into Object-formatted ones and store in cachefunction createOptions( options ) &#123;2var object = optionsCache[ options ] = &#123;&#125;;2jQuery.each( options.match( rnotwhite ) || [], function( _, flag ) &#123;22object[ flag ] = true;2&#125;);2return object;&#125; 接口的设计： callback需要在内部维护着一个list的队列数组，用于保存订阅的对象数据。同时也需要提供了add、remove、fire等订阅、发布、删除类似的接口。可以构建一个存放回调的数组，如 var list = [] ，通过闭包使这条回调数组保持存在。添加回调时，将回调push进list，执行则遍历list执行回调。 ##4.数据缓存 ##5.deferred.js ###5.1 Deferred介绍Deferred对象是由$.Deferred构造的，它用来解决JS中的异步编程，它遵循 Common Promise/A 规范。实现此规范的还有 when.js 和 dojo。 Deferred 提供了一个抽象的非阻塞的解决方案（如异步请求的响应），它创建一个promise对象，其目的是在未来某个时间点返回一个响应。简单来说就是一个异步/同步回调函数的处理方案。 $.Deferred作为新特性首次出现在版本1.5中，这个版本利用Deferred又完全重写了Ajax模块。$.Deferred在jQuery代码自身四处被使用，分别是promise方法、DOM ready、Ajax模块、动画模块。deferred.js为jQuery对象提供了两个静态方法： $.Deferred() 、 $.when() 。 jQuery的Deferred就是模块化程度非常高，可以混入任意的对象接口中配合使用： function task(name) &#123;2var dtd = $.Deferred();2setTimeout(function() &#123;22dtd.resolve(name)2&#125;, 1000)2return dtd;&#125;$.when(task(&#x27;任务一&#x27;), task(&#x27;任务二&#x27;)).done(function() &#123;2alert(&#x27;成功&#x27;)&#125;) ###5.2 用法 done/resolve 处理成功状态， fail/reject 处理失败状态， progress/notify 当前处理进度状态 调用示例： function fn1() &#123; alert(&#x27;success&#x27;);&#125;function fn2() &#123; alert(&#x27;fail&#x27;);&#125;function fn3() &#123; alert(&#x27;progress&#x27;);&#125;var deferred = $.Deferred();deferred.done(fn1).fail(fn2).progress(fn3); // 链式操作//耗时的异步操作setTimeout(function() &#123; deferred.resolve(); //deferred.reject(); //deferred.notify();&#125;, 3000) then ，一次添加成功，失败，进度回调函数，调用示例： var deferred = $.Deferred();deferred.then(fn1, fn2, fn3); 调用then后还可以继续链式调用then添加多个不同回调函数，这个then也正是jQuery对 Common Promise/A 的实现。 var deferred = $.Deferred();deferred.then(fn1, fn2, fn3); 使用always方法为成功，失败状态添加同一个回调函数，回调函数中可以使用deferred.state方法获取异步过程中的最终状态,调用示例： var deferred = $.Deferred()deferred.always(function() &#123; var state = deferred.state() if ( state === &#x27;resolved&#x27;) &#123; alert(&#x27;success&#x27;); &#125; else if (state === &#x27;rejected&#x27;) &#123; alert(&#x27;fail&#x27;); &#125;&#125;)setTimeout(function() &#123; deferred.resolve(); //deferred.reject();&#125;, 3000); $.when() 保证多个异步操作全部成功后才回调，调用示例： deferred.promise() 没有参数时，返回一个新的deferred对象；接受参数时，作用为在参数对象上部署deferred接口返回只能添加回调的对象，对象的运行状态无法被改变，即这个对象与$.Deferred()返回的对象不同，只能done/fail/progress，不能resolve/reject/notify。 ###5.3 $.Deferred接口 $.Deferred的源码中对动作接口的定义： [ &quot;resolve&quot;, &quot;done&quot;, jQuery.Callbacks(&quot;once memory&quot;), &quot;resolved&quot; ], [ &quot;reject&quot;, &quot;fail&quot;, jQuery.Callbacks(&quot;once memory&quot;), &quot;rejected&quot; ], [ &quot;notify&quot;, &quot;progress&quot;, jQuery.Callbacks(&quot;memory&quot;) ] 实质上是观察者模式的实现: || 订阅方法 || 发布方法 |||| Done (操作完成) || resolve/resolveWith（解决） |||| Fail (操作失败) || reject/rejectWith（拒绝） || 30 |||| Progress (操作进行中) || notify/notifyWith（通知） || With接口扩展了3个可以定义上下文的发布方法 $.when$.when接受若干个对象，参数仅一个且非Deferred对象将立即执行回调函数，Deferred对象和非Deferred对象混杂时，对于非Deferred对象remaining减1 Deferred对象总数 = 内部构建的Deferred对象 + 所传参数中包含的Deferred对象，所传参数中所有Deferred对象每当resolve时remaining减1，直到为0时（所有都resolve）执行回调","categories":[{"name":"js","slug":"js","permalink":"http://tcatche.site/categories/js/"}],"tags":[]}],"categories":[{"name":"js","slug":"js","permalink":"http://tcatche.site/categories/js/"},{"name":"其它","slug":"其它","permalink":"http://tcatche.site/categories/%E5%85%B6%E5%AE%83/"},{"name":"css","slug":"css","permalink":"http://tcatche.site/categories/css/"},{"name":"翻译","slug":"翻译","permalink":"http://tcatche.site/categories/%E7%BF%BB%E8%AF%91/"},{"name":"html","slug":"html","permalink":"http://tcatche.site/categories/html/"},{"name":"转载","slug":"转载","permalink":"http://tcatche.site/categories/%E8%BD%AC%E8%BD%BD/"}],"tags":[{"name":"canvas","slug":"canvas","permalink":"http://tcatche.site/tags/canvas/"},{"name":"git","slug":"git","permalink":"http://tcatche.site/tags/git/"},{"name":"promise","slug":"promise","permalink":"http://tcatche.site/tags/promise/"},{"name":"dom","slug":"dom","permalink":"http://tcatche.site/tags/dom/"},{"name":"浏览器","slug":"浏览器","permalink":"http://tcatche.site/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"},{"name":"状态","slug":"状态","permalink":"http://tcatche.site/tags/%E7%8A%B6%E6%80%81/"},{"name":"hook","slug":"hook","permalink":"http://tcatche.site/tags/hook/"},{"name":"generator","slug":"generator","permalink":"http://tcatche.site/tags/generator/"},{"name":"node","slug":"node","permalink":"http://tcatche.site/tags/node/"},{"name":"npm","slug":"npm","permalink":"http://tcatche.site/tags/npm/"},{"name":"css","slug":"css","permalink":"http://tcatche.site/tags/css/"},{"name":"color","slug":"color","permalink":"http://tcatche.site/tags/color/"},{"name":"js","slug":"js","permalink":"http://tcatche.site/tags/js/"},{"name":"安全","slug":"安全","permalink":"http://tcatche.site/tags/%E5%AE%89%E5%85%A8/"},{"name":"react","slug":"react","permalink":"http://tcatche.site/tags/react/"},{"name":"操作符","slug":"操作符","permalink":"http://tcatche.site/tags/%E6%93%8D%E4%BD%9C%E7%AC%A6/"},{"name":"快捷键","slug":"快捷键","permalink":"http://tcatche.site/tags/%E5%BF%AB%E6%8D%B7%E9%94%AE/"},{"name":"工具","slug":"工具","permalink":"http://tcatche.site/tags/%E5%B7%A5%E5%85%B7/"},{"name":"DOM","slug":"DOM","permalink":"http://tcatche.site/tags/DOM/"},{"name":"window","slug":"window","permalink":"http://tcatche.site/tags/window/"},{"name":"翻译","slug":"翻译","permalink":"http://tcatche.site/tags/%E7%BF%BB%E8%AF%91/"},{"name":"hooks","slug":"hooks","permalink":"http://tcatche.site/tags/hooks/"},{"name":"高阶函数","slug":"高阶函数","permalink":"http://tcatche.site/tags/%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0/"},{"name":"shouldComponentUpdate","slug":"shouldComponentUpdate","permalink":"http://tcatche.site/tags/shouldComponentUpdate/"},{"name":"counter","slug":"counter","permalink":"http://tcatche.site/tags/counter/"},{"name":"计数器","slug":"计数器","permalink":"http://tcatche.site/tags/%E8%AE%A1%E6%95%B0%E5%99%A8/"},{"name":"list-style","slug":"list-style","permalink":"http://tcatche.site/tags/list-style/"},{"name":"content","slug":"content","permalink":"http://tcatche.site/tags/content/"},{"name":"error","slug":"error","permalink":"http://tcatche.site/tags/error/"},{"name":"rel","slug":"rel","permalink":"http://tcatche.site/tags/rel/"},{"name":"优化","slug":"优化","permalink":"http://tcatche.site/tags/%E4%BC%98%E5%8C%96/"},{"name":"性能","slug":"性能","permalink":"http://tcatche.site/tags/%E6%80%A7%E8%83%BD/"},{"name":"async","slug":"async","permalink":"http://tcatche.site/tags/async/"},{"name":"defer","slug":"defer","permalink":"http://tcatche.site/tags/defer/"},{"name":" es6+","slug":"es6","permalink":"http://tcatche.site/tags/es6/"},{"name":"this","slug":"this","permalink":"http://tcatche.site/tags/this/"},{"name":"element","slug":"element","permalink":"http://tcatche.site/tags/element/"},{"name":"HTML","slug":"HTML","permalink":"http://tcatche.site/tags/HTML/"},{"name":"query","slug":"query","permalink":"http://tcatche.site/tags/query/"},{"name":"selector","slug":"selector","permalink":"http://tcatche.site/tags/selector/"},{"name":"bom","slug":"bom","permalink":"http://tcatche.site/tags/bom/"},{"name":"event","slug":"event","permalink":"http://tcatche.site/tags/event/"},{"name":"事件","slug":"事件","permalink":"http://tcatche.site/tags/%E4%BA%8B%E4%BB%B6/"},{"name":"listener","slug":"listener","permalink":"http://tcatche.site/tags/listener/"},{"name":"mouse","slug":"mouse","permalink":"http://tcatche.site/tags/mouse/"},{"name":"drag","slug":"drag","permalink":"http://tcatche.site/tags/drag/"},{"name":"touch","slug":"touch","permalink":"http://tcatche.site/tags/touch/"},{"name":"click","slug":"click","permalink":"http://tcatche.site/tags/click/"},{"name":"keyboard","slug":"keyboard","permalink":"http://tcatche.site/tags/keyboard/"},{"name":"cascade","slug":"cascade","permalink":"http://tcatche.site/tags/cascade/"},{"name":"style","slug":"style","permalink":"http://tcatche.site/tags/style/"},{"name":"html","slug":"html","permalink":"http://tcatche.site/tags/html/"},{"name":"bfc","slug":"bfc","permalink":"http://tcatche.site/tags/bfc/"},{"name":"块格式上下文","slug":"块格式上下文","permalink":"http://tcatche.site/tags/%E5%9D%97%E6%A0%BC%E5%BC%8F%E4%B8%8A%E4%B8%8B%E6%96%87/"},{"name":"外边距合并","slug":"外边距合并","permalink":"http://tcatche.site/tags/%E5%A4%96%E8%BE%B9%E8%B7%9D%E5%90%88%E5%B9%B6/"},{"name":"设计模式","slug":"设计模式","permalink":"http://tcatche.site/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"内存管理","slug":"内存管理","permalink":"http://tcatche.site/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"},{"name":"WebAssembly","slug":"WebAssembly","permalink":"http://tcatche.site/tags/WebAssembly/"},{"name":"规范","slug":"规范","permalink":"http://tcatche.site/tags/%E8%A7%84%E8%8C%83/"},{"name":"虚拟DOM","slug":"虚拟DOM","permalink":"http://tcatche.site/tags/%E8%99%9A%E6%8B%9FDOM/"},{"name":"JIT","slug":"JIT","permalink":"http://tcatche.site/tags/JIT/"},{"name":"test","slug":"test","permalink":"http://tcatche.site/tags/test/"},{"name":"develop","slug":"develop","permalink":"http://tcatche.site/tags/develop/"},{"name":"扩展","slug":"扩展","permalink":"http://tcatche.site/tags/%E6%89%A9%E5%B1%95/"},{"name":"BOM","slug":"BOM","permalink":"http://tcatche.site/tags/BOM/"},{"name":"es","slug":"es","permalink":"http://tcatche.site/tags/es/"},{"name":"Decorator","slug":"Decorator","permalink":"http://tcatche.site/tags/Decorator/"},{"name":"function","slug":"function","permalink":"http://tcatche.site/tags/function/"},{"name":"函数式","slug":"函数式","permalink":"http://tcatche.site/tags/%E5%87%BD%E6%95%B0%E5%BC%8F/"},{"name":"异步","slug":"异步","permalink":"http://tcatche.site/tags/%E5%BC%82%E6%AD%A5/"},{"name":"redux","slug":"redux","permalink":"http://tcatche.site/tags/redux/"}]}