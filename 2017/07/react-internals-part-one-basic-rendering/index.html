<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    
    <title>React 内部原理，第一部分：基础渲染 | TryCatch</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
        <meta name="keywords" content="react,翻译" />
    
    

    

    

    
<link rel="stylesheet" href="/libs/font-awesome/css/font-awesome.min.css">

    
<link rel="stylesheet" href="/libs/titillium-web/styles.css">

    
<link rel="stylesheet" href="/libs/source-code-pro/styles.css">

    <link rel="stylesheet" href="//at.alicdn.com/t/font_2757668_82oan8olqo.css">

    
<link rel="stylesheet" href="/css/style.css">


    
<script src="/libs/jquery/2.0.3/jquery.min.js"></script>

    
    
        
<link rel="stylesheet" href="/libs/lightgallery/css/lightgallery.min.css">

    
    
        <script type="text/javascript">
(function(i,s,o,g,r,a,m) {i['GoogleAnalyticsObject']=r;i[r]=i[r]||function() {
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-92905809-1', 'auto');
ga('send', 'pageview');

</script>
    
    
        <script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?409648b1638886ada0891d05cc80dc19";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
</script>

    
    
        <script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>
    
    

    <div class="super-board">
  <div class="super-board-mask"></div>
  <div class="super-board-container">
    <div class="super-board-top">
      <div class="sider-header">
        <span class="iconfont icon-super"></span>
        <span class="title">超级面板</span>
      </div>
    </div>
    <div class="super-board-middle">
      <div class="super-board-sider">
        <div class="sider-item" data-target="TOC">
          <span class="iconfont icon-toc"></span>
          <span class="title">文章目录</span>
        </div>
        <div class="sider-item" data-target="NEW">
          <span class="iconfont icon-history"></span>
          <span class="title">最新文章</span>
        </div>
        <div class="sider-item" data-target="UPDATED">
          <span class="iconfont icon-new"></span>
          <span class="title">最近更新</span>
        </div>
        <div class="sider-item" data-target="CATEGORIES">
          <span class="iconfont icon-category"></span>
          <span class="title">文章分类</span>
        </div>
        <div class="sider-item" data-target="TAGS">
          <span class="iconfont icon-tag"></span>
          <span class="title">标签列表</span>
        </div>
        <div class="sider-item" data-target="ARCHIVES">
          <span class="iconfont icon-archives"></span>
          <span class="title">文章归档</span>
        </div>
        <div class="sider-item" data-target="">
          <span class="iconfont"></span>
          <span class="title"></span>
        </div>
        <div class="sider-item" data-target="">
          <span class="iconfont"></span>
          <span class="title"></span>
        </div>
      </div>
      <div class="super-board-detail-wrapper">
        <div class="super-board-detail-container"></div>
      </div>
      <div class="super-board-posts-wrapper hide">
        <div class="super-board-posts-container"></div>
      </div>
    </div>
    <div class="super-board-input-wrapper" style="display: none">
        <input type="text" class="super-board-search-input" placeholder="想要查找什么..." />
    </div>
    <div class="super-board-search-close">
      <span class="iconfont icon-close"></span>
    </div>
  </div>
</div>
<script>
(function (window) {
  var INSIGHT_CONFIG = {
    TRANSLATION: {
        POSTS: '最新文章',
        PAGES: '页面',
        CATEGORIES: '文章分类',
        TAGS: '文章标签',
        UNTITLED: '(未命名)',
    },
    ROOT_URL: '/',
    CONTENT_URL: '/content.json',
  };
  window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>

<script src="/js/super-board.js"></script>

    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script async src="https://cdn.jsdelivr.net/gh/ireade/caniuse-embed/public/caniuse-embed.min.js"></script>
    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="page-percent"><div></div></div>
  <header id="header">
  <a class="logo-container" href="/">
    <img src="/images/avatar.png" alt="Author's avatar">
    <span class="header-author">
      tcatche
    </span>
  </a>
  <div id="header-nav" class="nav-container">
    <ul>
      
          <li class="main-nav-list-item" >
            <a class="main-nav-list-link" href="/">主页</a>
          </li>
      
          
              <li class="main-nav-list-item show-super-board" data-target="js" data-type="CATEGORIES">js</li>
          
              <li class="main-nav-list-item show-super-board" data-target="翻译" data-type="CATEGORIES">翻译</li>
          
              <li class="main-nav-list-item show-super-board" data-target="css" data-type="CATEGORIES">css</li>
          
              <li class="main-nav-list-item show-super-board" data-target="其它" data-type="CATEGORIES">其它</li>
          
              <li class="main-nav-list-item show-super-board" data-target="html" data-type="CATEGORIES">html</li>
          
              <li class="main-nav-list-item show-super-board" data-target="转载" data-type="CATEGORIES">转载</li>
          
        
    </ul>
  </div>
</header>
  <div class="main-body container-inner">
    <div class="main-body-inner">
      <section id="main">
        <div class="main-body-content">
          <article id="post-react-internals-part-one-basic-rendering" class="article article-single article-type-post" itemscope itemprop="blogPost">
    <header class="article-header" >
        
    
        <h1 class="article-title" itemprop="name">
        React 内部原理，第一部分：基础渲染
        </h1>
    

        <div class="article-subtitle">
            <div class="article-meta">
                <div class="article-category meta-item">
    <i class="iconfont icon-calendar"></i>
    <span class="post-category show-super-board clickable" data-target="2017" data-type="ARCHIVES">
        2017-07-25
    </span>
</div>
                
    <span class="word-count meta-item">
      <i class="iconfont icon-shuliang"></i>
      字数: 4.2k
    </span>
    <span class="word-count meta-item">
      <i class="iconfont icon-countdown"></i>
      阅读时长: 27mins
    </span>

                <span class="article-reads">
                    <i class="iconfont icon-eye"></i>
                    <span id="busuanzi_container_page_pv">
                        <span>
                            阅读次数: <span id="busuanzi_value_page_pv"></span>次
                        </span>
                    </span>
                </span>
                
    <div class="article-category meta-item">
        <i class="iconfont icon-category"></i>分类：
        
        
            <span class="post-category show-super-board clickable" data-target="翻译" data-type="CATEGORIES">翻译</span>
        
    </div>

                
    
    <div class="article-tag meta-item">
        <i class="iconfont icon-tag"></i>标签：
        
            <span class="post-tag show-super-board clickable" data-target="react" data-type="TAGS">react</span>
        
            <span class="post-tag show-super-board clickable" data-target="翻译" data-type="TAGS">翻译</span>
        
    </div>

            </div>
        </div>
    </header>
    <div class="article-inner">
        
        <div class="article-entry" itemprop="articleBody">
            <blockquote>
<p>原文：<a target="_blank" rel="noopener" href="http://www.mattgreer.org/articles/react-internals-part-one-basic-rendering/">React Internals, Part One: basic rendering</a></p>
</blockquote>
<p>In this five part series, we will “recreate” React from the ground up, learning how it works along the way. Once we’ve finished, you should have a good grasp of how React works, and when and why it calls the various lifecycle methods of a component.</p>
<p>在这五部分系列中，我们将从头开始“重新创建” React，学习其如何工作。一旦完成，你应该对 React 的工作原理有一个很好地掌握，以及它在何时，为何调用组件的各种生命周期方法。</p>
<h2 id="本系列（The-series）"><a href="#本系列（The-series）" class="headerlink" title="本系列（The series）"></a>本系列（The series）</h2><ul>
<li><strong>part one: basic rendering</strong> &lt;- you are here</li>
<li><a target="_blank" rel="noopener" href="http://www.mattgreer.org/articles/react-internals-part-two-componentWillMount-and-componentDidMount/">part two: componentWillMount and componentDidMount</a></li>
<li><a target="_blank" rel="noopener" href="http://www.mattgreer.org/articles/react-internals-part-three-basic-updating">part three: basic updating</a></li>
<li><a target="_blank" rel="noopener" href="http://www.mattgreer.org/articles/react-internals-part-four-setState">part four: setState</a></li>
<li><a target="_blank" rel="noopener" href="http://www.mattgreer.org/articles/react-internals-part-five-transactions/">part five: transactions</a></li>
</ul>
<p>全部译文：</p>
<ul>
<li><a href="/2017/07/react-internals-part-one-basic-rendering/"><strong>第一部分：基础渲染</strong> &lt;- 当前位置</a></li>
<li><a href="/2017/07/react-internals-part-two-componentWillMount-and-componentDidMount/">第二部分：componentWillMount and componentDidMount</a></li>
<li><a href="/2017/07/react-internals-part-three-basic-updating/">第三部分：基本更新</a></li>
<li><a href="/2017/07/react-internals-part-four-setState/">第四部分：setState</a></li>
<li><a href="/2017/08/react-internals-part-five-transactions/">第五部分：事务</a></li>
</ul>
<h2 id="声明（disclaimer）"><a href="#声明（disclaimer）" class="headerlink" title="声明（disclaimer）"></a>声明（disclaimer）</h2><p>This series is based on React 15.3, in particular using ReactDOM and the stack reconciler. The fancy new fiber reconciler is out of scope here. The React clone we are going to build will not even come close to implementing all of React. But Feact’s source code will mirror React’s as much as possible.</p>
<p>本系列基于 React 15.3，特别是使用 ReactDOM 和堆栈 reconciler。这款高性能的 fiber reconciler 超出了本文的范围。我们要构建的 React 克隆版（Feact）不会实现所有的 React 功能。但是，Feact 的源代码将尽可能地反映 React 的内容。</p>
<h2 id="一些背景：元素和组件（Some-Background-Elements-and-Components）"><a href="#一些背景：元素和组件（Some-Background-Elements-and-Components）" class="headerlink" title="一些背景：元素和组件（Some Background: Elements and Components）"></a>一些背景：元素和组件（Some Background: Elements and Components）</h2><p>At the heart of React are three different types of entities: native DOM elements, virtual elements and components.</p>
<p>React 的核心是三种不同类型的实体：原生 DOM 元素，虚拟元素和组件。</p>
<h3 id="原生-DOM-元素（native-DOM-elements）"><a href="#原生-DOM-元素（native-DOM-elements）" class="headerlink" title="原生 DOM 元素（native DOM elements）"></a>原生 DOM 元素（native DOM elements）</h3><p>These are exactly what they sound like, the actual DOM elements that the browser uses as the building blocks of a webpage. At some point, React will call <code>document.createElement()</code> to get one, and use the browser’s DOM api to update them such as <code>element.insertBefore()</code>, <code>element.nodeValue</code>, etc.</p>
<p>正如它的名字所说，原生 DOM 元素是浏览器用作构建网页块的实际 DOM 元素。在某些时候，React会调用 <code>document.createElement()</code> 来创建它，并使用浏览器的 DOM API 如 <code>element.insertBefore()</code>、<code>element.nodeValue</code> 等来更新它们。</p>
<h3 id="虚拟-React-元素（virtual-React-elements）"><a href="#虚拟-React-元素（virtual-React-elements）" class="headerlink" title="虚拟 React 元素（virtual React elements）"></a>虚拟 React 元素（virtual React elements）</h3><p>A virtual React element (just called an “element” in the source code), is an in memory representation of what you’d like a given DOM element (or entire tree of elements) to be for a particular render. An element can either directly represent a DOM element such as <code>h1</code>, <code>div</code>, etc. Or it can represent a user defined composite component, which is explained below.</p>
<p>虚拟的 React 元素（在源代码中称为“元素”），是表示特定渲染中给定的DOM元素（或整个元素树）在内存中的表示形式。一个React 元素可以直接表示一个 DOM 元素，如<code>h1</code>、<code>div</code>等，或者表示一个用户定义的复合组件，这将在下面解释。</p>
<h3 id="组件（Components）"><a href="#组件（Components）" class="headerlink" title="组件（Components）"></a>组件（Components）</h3><p>“Component” is a pretty generic term in React. They are entities within React that do various types of work. Different types of components do different things. For example, <code>ReactDOMComponent</code> from ReactDOM is responsible for bridging between React elements and their corresponding native DOM elements.</p>
<p>“组件”是 React 中相当通用的术语。它们是 React 中的执行不同类型工作的实体。不同类型的组件做不同的事情。例如，ReactDOM 的 <code>ReactDOMComponent</code> 负责在 React 元素及其对应的原生 DOM 元素之间进行连接。</p>
<h3 id="用户定义的复合组件（User-Defined-Composite-Components）"><a href="#用户定义的复合组件（User-Defined-Composite-Components）" class="headerlink" title="用户定义的复合组件（User Defined Composite Components）"></a>用户定义的复合组件（User Defined Composite Components）</h3><p>You are already familiar with one type of component: the composite component. Whenever you call <code>React.createClass()</code>, or have an es6 class extend <code>React.Component</code>, you are creating a Composite Component class. It turns out our view of the component lifecycle with methods like <code>componentWillMount</code>, <code>shouldComponentUpdate</code> is just one piece of the puzzle. These are the lifecycle methods that we hook into because they benefit us. But React components have other lifecycle methods such as <code>mountComponent</code> and <code>receiveComponent</code>. We never implement, call, or even know these other lifecycle methods exist. They are only used internally by React.</p>
<p>你已经熟悉一种类型的组件：复合组件。无论何时调用 <code>React.createClass()</code> ，或者有一个 es6 类扩展了 <code>React.Component</code>，都将创建一个复合组件类。我们经常所看到的组件生命周期的方法，如 <code>componentWillMount</code>、<code>shouldComponentUpdate</code> 只是它的一部分，这些我们经常使用的生命周期方法，因为他们很有帮助。但是 React 组件还具有其他生命周期方法，如 <code>mountComponent</code> 和 <code>receiveComponent</code>。我们从来没有实现，调用，甚至知道这些其他的生命周期方法存在。它们仅在 React 内部被使用。</p>
<blockquote>
<p>The truth is the components we create are incomplete. React will take our component class, and wrap it in a <code>ReactCompositeComponentWrapper</code>, which then gives the components we wrote the full lifecycle hooks and ability to participate in React.</p>
</blockquote>
<blockquote>
<p>事实是我们创建的组件是不完整的。 React 将我们的组件类包装在<code> ReactCompositeComponentWrapper</code> 中，然后给出了我们可以编写完整生命周期钩子和参与 React 的能力的组件。</p>
</blockquote>
<h2 id="React-是声明式的（React-is-declarative）"><a href="#React-是声明式的（React-is-declarative）" class="headerlink" title="React 是声明式的（React is declarative）"></a>React 是声明式的（React is declarative）</h2><p>When it comes to components, our job is to define component <strong>classes</strong>. But we never instantiate them. Instead React will instantiate an instance of our classes when it needs to.</p>
<p>当开始编写组件的时候，我们的工作就是定义<strong>组件类</strong>。但是我们从不实例化它们。相反，React 会在需要时实例化类的实例。 </p>
<p>We also don’t consciously instantiate elements. But we do implicitly when we write JSX, such as:</p>
<p>我们也不必实例化元素。但是，当我们编写 JSX 时，我们会隐式地进行实例化，比如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>That bit of JSX gets translated into this by the compiler:</p>
<p>这一段 JSX 被编译器翻译成：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> React.createElement(<span class="string">&#x27;div&#x27;</span>, <span class="literal">null</span>, <span class="string">&#x27;hello&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>so in a sense, we are causing an element to be created because our code will call <code>React.createElement()</code>. But in another sense we aren’t, because it’s up to React to instantiate our component and then call <code>render()</code> for us. It’s simplest to consider React declarive. We describe what we want, and React figures out how to make it happen.</p>
<p>所以在某种意义上，我们造成一个元素被创建，因为我们的代码将调用 <code>React.createElement()</code>。但是在另一个意义上，并不是这样，因为实际是 React 实例化了我们的组件，为我们调用 <code>render()</code> 。让 React 是声明式的是最简单的。我们描述我们想要什么，而由 React 计算出如何实现。</p>
<h2 id="一个小型的，山寨的-React，我们叫它-Feact（A-tiny-fake-React-called-Feact）"><a href="#一个小型的，山寨的-React，我们叫它-Feact（A-tiny-fake-React-called-Feact）" class="headerlink" title="一个小型的，山寨的 React，我们叫它 Feact（A tiny, fake React called Feact）"></a>一个小型的，山寨的 React，我们叫它 Feact（A tiny, fake React called Feact）</h2><p>Now with a little bit of background under our belt, let’s get started building our React clone. Since this clone is tiny and fake, we’ll give it the imaginative name “Feact”.</p>
<p>现在我们对背景有一点了解，让我们开始构建我们的 React 克隆版。这个克隆是非常小型的山寨的，我们给它一个有想象力的名字 <code>Feact</code>。 </p>
<p>Let’s pretend we want to create this tiny Feact app:</p>
<p>我们假装要创建这个小巧的 Feact 应用程序：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Feact.render(<span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>hello world<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>, <span class="built_in">document</span>.getElementById(<span class="string">&#x27;root&#x27;</span>));</span><br></pre></td></tr></table></figure>

<p>For starters, let’s ditch the JSX. Assuming Feact was fully implemented, after running the JSX through the compiler we’d end up with</p>
<p>对于初学者，让我们来看看 JSX。假设 Feact 已经完全实现了 JSX，在通过编译器运行后，我们最终会得到：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Feact.render(</span><br><span class="line">  Feact.createElement(<span class="string">&#x27;h1&#x27;</span>, <span class="literal">null</span>, <span class="string">&#x27;hello world&#x27;</span>),</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">&#x27;root&#x27;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>JSX is a large topic on its own and a bit of a distraction. So from here on out, we will use <code>Feact.createElement</code> instead of JSX, so let’s go ahead and implement it</p>
<p>JSX 本身就是一个很大内容，有点脱离本文主题。所以从这里开始，我们将使用 <code>Feact.createElement</code> 代替 JSX，让我们继续实现它：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Feact = &#123;</span><br><span class="line">  <span class="function"><span class="title">createElement</span>(<span class="params">type, props, children</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> element = &#123;</span><br><span class="line">      type,</span><br><span class="line">      <span class="attr">props</span>: props || &#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (children) &#123;</span><br><span class="line">      element.props.children = children;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Elements are just simple objects representing something we want rendered.</p>
<p>元素只是我们想要渲染的东西的简单对象表示。</p>
<h3 id="Feact-render-应该做什么？（What-should-Feact-render-do-）"><a href="#Feact-render-应该做什么？（What-should-Feact-render-do-）" class="headerlink" title="Feact.render() 应该做什么？（What should Feact.render() do?）"></a>Feact.render() 应该做什么？（What should Feact.render() do?）</h3><p>Our call to <code>Feact.render()</code> passes in what we want rendered and where it should go. This is the starting point of any Feact app. For our first attempt, let’s define <code>render()</code> to look something like this</p>
<p>我们调用 <code>Feact.render()</code> ，传递了我们想要渲染的内容，以及它的位置。这是任何 Feact 应用的入口。对于我们的第一次尝试，让我们定义这样的 <code>render()</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Feact = &#123;</span><br><span class="line">  <span class="function"><span class="title">createElement</span>(<span class="params"></span>)</span> &#123; <span class="comment">/* as before */</span> &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params">element, container</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> componentInstance = <span class="keyword">new</span> FeactDOMComponent(element);</span><br><span class="line">    <span class="keyword">return</span> componentInstance.mountComponent(container);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>When <code>render()</code> finishes, we have a finished webpage. So based on that, we know FeactDOMComponent is truly digging in and creating DOM for us. Let’s go ahead and take a stab at implementing it:</p>
<p>当 <code>render()</code> 完成时，我们会有一个完整的网页。基于此，我们知道 <code>FeactDOMComponent</code> 参与并为我们创建了 DOM。让我们继续努力实施它：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FeactDOMComponent</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">element</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>._currentElement = element;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">mountComponent</span>(<span class="params">container</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> domElement = <span class="built_in">document</span>.createElement(<span class="built_in">this</span>._currentElement.type);</span><br><span class="line">    <span class="keyword">const</span> text = <span class="built_in">this</span>._currentElement.props.children;</span><br><span class="line">    <span class="keyword">const</span> textNode = <span class="built_in">document</span>.createTextNode(text);</span><br><span class="line">    domElement.appendChild(textNode);</span><br><span class="line"></span><br><span class="line">    container.appendChild(domElement);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>._hostNode = domElement;</span><br><span class="line">    <span class="keyword">return</span> domElement;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>mountComponent</code> stores the DOM element it creates in <code>this._hostNode</code>. We don’t need that in part one, but we will in part three.</p>
</blockquote>
<blockquote>
<p><code>mountComponent</code> 存储它创建的 DOM元素到 <code>this._hostNode</code>。在本文我们不需要它，但是在第三部分的文章我们需要。</p>
</blockquote>
<p>在线示例：<a target="_blank" rel="noopener" href="https://jsfiddle.net/city41/ohmzvb4o/9">fiddle</a></p>
<p>In about 40 lines of pretty crappy code we’ve got an incredibly limited and pathetic little “React clone”! Feact isn’t going to take over the world, but it’s serving as a nice learning sandbox.</p>
<p>在这大约 40 行的相当糟糕的代码，我们得到了一个令人难以置信的非常的小的“React 克隆”。Feact 不会接管世界，但它是一个很好的学习沙箱。</p>
<h2 id="添加用户定义的组件（Adding-user-defined-components）"><a href="#添加用户定义的组件（Adding-user-defined-components）" class="headerlink" title="添加用户定义的组件（Adding user defined components）"></a>添加用户定义的组件（Adding user defined components）</h2><p>We want to be able to render more than just a single, hardcoded, DOM element. So let’s add support for defining component classes:</p>
<p>我们希望能够渲染不仅仅是一个单一的，硬编码的 DOM 元素，我们来添加对自定义组件类的支持：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Feact = &#123;</span><br><span class="line">  <span class="function"><span class="title">createClass</span>(<span class="params">spec</span>)</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Constructor</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">this</span>.props = props;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Constructor.prototype.render = spec.render;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Constructor;</span><br><span class="line">  &#125;, </span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params">element, container</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// our previous implementation can&#x27;t</span></span><br><span class="line">    <span class="comment">// handle user defined components,</span></span><br><span class="line">    <span class="comment">// so we need to rethink this method</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> MyTitle = Feact.createClass(&#123;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Feact.createElement(<span class="string">&#x27;h1&#x27;</span>, <span class="literal">null</span>, <span class="built_in">this</span>.props.message);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Feact.render(&#123;</span><br><span class="line">  Feact.createElement(MyTitle, &#123; <span class="attr">message</span>: <span class="string">&#x27;hey there Feact&#x27;</span> &#125;),</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">&#x27;root&#x27;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>Remember, we’re not dealing with JSX for this blog post series, because we’ve got plenty to deal with already. If we had JSX available, the above would look like</p>
<p>请记住，我们这系列文章并不处理 JSX，因为我们已经有很多要处理的内容了。如果我们有可用的 JSX 处理器，上面将会是被编译成这样：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Feact.render(</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">MyTitle</span> <span class="attr">message</span>=<span class="string">&quot;hey there Feact&quot;</span> /&gt;</span></span>,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">&#x27;root&#x27;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>We passed the component class into <code>createElement</code>. An element can either represent a primitive DOM element, or it can represent a composite component. The distinction is easy, if <code>type</code> is a string, the element is a native primitive. If it is a function, the element represents a composite component.</p>
<p>我们将组件类传递给 <code>createElement</code>。元素可以表示原生 DOM 元素，也可以表示复合组件。区别很容易，如果 type 是一个字符串，则元素表示原始 DOM 元素。如果它是一个函数，则该元素表示一个复合组件。</p>
<h3 id="改进-Feact-render-（Improving-Feact-render-）"><a href="#改进-Feact-render-（Improving-Feact-render-）" class="headerlink" title="改进 Feact.render()（Improving Feact.render()）"></a>改进 Feact.render()（Improving Feact.render()）</h3><p>If you trace back through the code so far, you will see that <code>Feact.render()</code> as it stands now can’t handle composite components, so let’s fix that:</p>
<p>如果你回溯到目前为止的代码，你会看到现在的 <code>Feact.render()</code> 不能处理复合组件，所以我们来改进一下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Feact = &#123;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params">element, container</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> componentInstance =</span><br><span class="line">      <span class="keyword">new</span> FeactCompositeComponentWrapper(element);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> componentInstance.mountComponent(container);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FeactCompositeComponentWrapper</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">element</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>._currentElement = element;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">mountComponent</span>(<span class="params">container</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> Component = <span class="built_in">this</span>._currentElement.type;</span><br><span class="line">    <span class="keyword">const</span> componentInstance = <span class="keyword">new</span> Component(<span class="built_in">this</span>._currentElement.props);</span><br><span class="line">    <span class="keyword">const</span> element = componentInstance.render();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> domComponentInstance = <span class="keyword">new</span> FeactDOMComponent(element);</span><br><span class="line">    <span class="keyword">return</span> domComponentInstance.mountComponent(container);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>By giving users the ability to define their own components, Feact can now create dynamic DOM nodes that can change depending on the value of the props. There’s a lot going on in this upgrade to Feact, but if you trace through it, it’s not too bad. You can see where we call <code>componentInstance.render()</code>, to get our hands on an element that we can then pass into <code>FeactDOMComponent</code>.</p>
<p>通过给用户定义自己的组件的能力，Feact 现在可以创建能够根据 props 的值改变的动态 DOM 节点。在升级 Feact 的过程中有很多事情要做，但是如果你跟踪它的进行过程，这并不是很困难。你可以看到我们在哪里调用 <code>componentInstance.render()</code> ，以获得一个可以传入 <code>FeactDOMComponent</code> 的元素。 </p>
<blockquote>
<p>Notice how <code>FeactCompositeComponentWrapper</code> is directly creating a <code>FeactDOMComponent</code>? That’s a tight coupling which isn’t so great. We’ll fix this later. If React was this tightly coupled, it’d only ever be able to build web apps. Keeping <code>ReactCompositeComponentWrapper</code> in the dark about other component types surely made building React Native easier.</p>
</blockquote>
<blockquote>
<p>注意 <code>FeactCompositeComponentWrapper</code> 如何直接创建一个 <code>FeactDOMComponent</code> ？这个耦合很紧密的，但问题不大。我们稍后会解决这个问题。如果 React 是紧密耦合的，那么它只能构建 Web 应用程序。保持 <code>ReactCompositeComponentWrapper</code> 与其他组件类型透明会使本地化的 React（React Native） 更容易。</p>
</blockquote>
<h3 id="复合组件的改进-An-improvement-for-composite-components"><a href="#复合组件的改进-An-improvement-for-composite-components" class="headerlink" title="复合组件的改进(An improvement for composite components)"></a>复合组件的改进(An improvement for composite components)</h3><p>Currently our composite components must return elements that represent primitive DOM nodes, we can’t return other composite component elements. Let’s fix that. We want to be able to do this</p>
<p>目前，我们的复合组件必须返回原始 DOM 节点的元素，我们不能返回其他复合组件元素。我们来解决这个问题，我们希望能够实现这个功能：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> MyMessage = Feact.createClass(&#123;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.props.asTitle) &#123;</span><br><span class="line">      <span class="keyword">return</span> Feact.createElement(MyTitle, &#123;</span><br><span class="line">        <span class="attr">message</span>: <span class="built_in">this</span>.props.message</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> Feact.createElement(<span class="string">&#x27;p&#x27;</span>, <span class="literal">null</span>, <span class="built_in">this</span>.props.message);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>This composite component’s <code>render()</code> is either going to return a primitive element or a composite component element. Currently Feact can’t handle this, if <code>asTitle</code> was true, <code>FeactCompositeComponentWrapper</code> would give <code>FeactDOMComponent</code> a non-native element, and <code>FeactDOMComponent</code> would blow up. Let’s fix <code>FeactCompositeComponentWrapper</code></p>
<p>该复合元素的 <code>render()</code> 方法返回一个原始元素或者复合元素。当前版本的 Feact 无法处理它，如果 <code>asTitle</code> 值为 <code>true</code>，<code>FeactCompositeComponentWrapper</code> 将会传递给 <code>FeactDOMComponent</code> 一个非原始的元素，<code>FeactDOMComponent</code> 就会挂掉，我们来修复 <code>FeactCompositeComponentWrapper</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FeactCompositeComponentWrapper</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">element</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>._currentElement = element;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">mountComponent</span>(<span class="params">container</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> Component = <span class="built_in">this</span>._currentElement.type;</span><br><span class="line">    <span class="keyword">const</span> componentInstance = <span class="keyword">new</span> Component(<span class="built_in">this</span>._currentElement.props);</span><br><span class="line">    <span class="keyword">let</span> element = componentInstance.render();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">typeof</span> element.type === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">      element = (<span class="keyword">new</span> element.type(element.props)).render();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> domComponentInstance = <span class="keyword">new</span> FeactDOMComponent(element);</span><br><span class="line">    domComponentInstance.mountComponent(container);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Heads up, this “fix” is a short cut that’s just good enough to meet our current needs. Notice how it repeatedly calls <code>render</code> until it gets down to a primitive element? That’s not good enough, because those subcomponents need to participate in the entire lifecycle. For example, if we had support for <code>componentWillMount</code>, those subcomponents would never get their’s called. We’ll fix this later.</p>
</blockquote>
<blockquote>
<p>首先，这个“修复”是一个小的，足以满足我们当前的需求。注意，如果它重复调用 <code>render</code>，直到最终变成一个原始元素？这不够好，因为这些子组件需要参与整个生命周期。例如，如果我们已经支持了 componentWillMount` ，那么这些子组件的这个方法将永远不会被调用。我们稍后会解决这个问题。</p>
</blockquote>
<h2 id="再一次修复-Feact-render-（Fixing-Feact-render-again）"><a href="#再一次修复-Feact-render-（Fixing-Feact-render-again）" class="headerlink" title="再一次修复 Feact.render()（Fixing Feact.render() again）"></a>再一次修复 Feact.render()（Fixing Feact.render() again）</h2><p>The first version of <code>Feact.render()</code> could only handle primitive elements. Now it can only handle composite elements. It needs to be able to handle both. We could write a “factory” function that will create a component for us based on the element’s type, but there’s another approach that React took. Since <code>FeactCompositeComponentWrapper</code> components ultimately result in a <code>FeactDOMComponent</code>, let’s just take whatever element we were given and wrap it in such a way that we can just use a <code>FeactCompositeComponentWrapper</code></p>
<p>第一个版本的 <code>Feact.render()</code> 只能处理原始元素，现在它只能处理复合元素。它需要能够处理两者。我们可以编写一个<strong>工厂</strong>函数，它将根据元素的类型为我们创建一个组件，但是还有另外一种 React 采用的方法。由于 <code>FeactCompositeComponentWrapper</code> 组件最终产生了 <code>FeactDOMComponent</code>，所以我们只需要使其接收我们给定的任何元素，并将它包装起来，以便我们可以只使用 <code>FeactCompositeComponentWrapper</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> TopLevelWrapper = <span class="function"><span class="keyword">function</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.props = props;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">TopLevelWrapper.prototype.render = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.props;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Feact = &#123;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params">element, container</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> wrapperElement = <span class="built_in">this</span>.createElement(TopLevelWrapper, element);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> componentInstance = <span class="keyword">new</span> FeactCompositeComponentWrapper(wrapperElement);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// as before</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>ToplevelWrapper</code> is basically a simple composite component. It could have been defined by calling <code>Feact.createClass()</code>. Its <code>render</code> method just returns the user provided element. Since <code>ToplevelWrapper</code> will get wrapped in a <code>FeactCompositeComponentWrapper</code>, we don’t care what type the user provided element was, <code>FeactCompositeComponentWrapper</code> will do the right thing regardless.</p>
<p><code>ToplevelWrapper</code> 基本上是一个简单的复合组件。它可以通过调用 <code>Feact.createClass()</code> 来定义。它的渲染方法只返回用户提供的元素。由于<code>ToplevelWrapper</code> 将被包装在 <code>FeactCompositeComponentWrapper</code> 中，所以我们不关心用户提供的元素是什么类型的，<code>FeactCompositeComponentWrapper</code> 会做正确的事情。</p>
<h2 id="第一部分总结（Conclusion-to-part-one）"><a href="#第一部分总结（Conclusion-to-part-one）" class="headerlink" title="第一部分总结（Conclusion to part one）"></a>第一部分总结（Conclusion to part one）</h2><p>With that, Feact can render simple components. As far as basic rendering is concerned, we’ve hit most of the major considerations. In real React, rendering is much more complicated as there are many other things to consider such as events, focus, scroll position of the window, performance, and much more.</p>
<p>Here’s a final fiddle that wraps up all we’ve built so far:</p>
<p>现在，Feact 可以渲染简单的组件。就基本渲染而言，我们已经遇到了大多数需要主要考虑因素。在真实的 React 中，渲染要复杂得多，因为还有许多其他的事情需要考虑，比如事件，焦点，滚动窗口的位置，性能等等。</p>
<p>这是最后的 fiddle 示例，包装了我们迄今为止所建立的所有内容：</p>
<p>在线示例：<a target="_blank" rel="noopener" href="https://jsfiddle.net/city41/7x2zgevj/17">fiddle</a></p>
<p><a target="_blank" rel="noopener" href="http://www.mattgreer.org/articles/react-internals-part-two-componentWillMount-and-componentDidMount">on to part two!</a><br><a target="_blank" rel="noopener" href="http://www.mattgreer.org/articles/react-internals-part-two-componentWillMount-and-componentDidMount">第二部分译文</a></p>

        </div>
        
<footer class="article-footer">
  <div class="cc">
    <a class="cc-images" rel="license noopener" target="_blank" href="http://creativecommons.org/licenses/by-nc/4.0/">
      <img alt="知识共享许可协议" style="border-width:0" src="/images/chooser_cc.png" />
      <img alt="知识共享许可协议" style="border-width:0" src="/images/chooser_by.png" />
      <img alt="知识共享许可协议" style="border-width:0" src="/images/chooser_nc.png" />
    </a>
    <span class="cc-text"> 本网站<strong>原创内容（非转载文章）</strong>采用
      <a rel="license noopener" target="_blank" href="http://creativecommons.org/licenses/by-nc/4.0/">
        知识共享署名-非商业性使用 4.0 国际许可协议</a>
      进行许可。
    </span>
  </div>
</footer>
    </div>
</article>

    <section id="comments">
    
        
<link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
<!--  
<link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">
<script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script>
-->
<div id="comment-container"></div>
<script>
  $(function() {
    setTimeout(function() {
      var gitalk = new Gitalk({
        clientID: '010a558ff67c828f318a',
        clientSecret: '08a6f4955996cb3d6ecb5fdfb4d564a9297a264b',
        repo: 'tcatche.github.io.comments',
        owner: 'tcatche',
        admin: ['tcatche'],
        id: location.pathname.substr(0, 50),      // Ensure uniqueness and length less than 50
        distractionFreeMode: true,
        perPage: 30
      });
      gitalk.render('comment-container');
  
      // var gitment = new Gitment({
      //   id: location.pathname, // 可选。默认为 location.href
      //   owner: 'tcatche',
      //   repo: 'tcatche.github.io.comments',
      //   oauth: {
      //     client_id: '010a558ff67c828f318a',
      //     client_secret: '08a6f4955996cb3d6ecb5fdfb4d564a9297a264b',
      //   },
      // })
      // gitment.render('comment-container');
    }, 100)
  })
</script>
    
    </section>


        </div>
      </section>
      
    </div>
  </div>
  <footer id="footer">
    <div class="container-inner">
        <div class="logo-wrap">
            <a href="/" class="logo"></a>
        </div>
        <div class="credit">
            <p>&copy; 2016 - 2021 tcatche</p>
            <p>Powered by <a href="//hexo.io/" target="_blank">Hexo</a>. Hosted by <a  target="_blank" rel="noopener" href="https://pages.github.com/">Github Pages</a>. </p>
            <p>Theme based <a href="//github.com/ppoffice" target="_blank">PPOffice</a> and modify by Tcatche. </p>
            <p>
                <span id="busuanzi_container_site_pv">总访问量<span id="busuanzi_value_site_pv"></span>次</span>
                <!-- <span id="busuanzi_container_site_uv" style="display: none">总访客<span id="busuanzi_value_site_uv"></span>人</span> -->
            </p>
        </div>
    </div>
</footer>
  <div id="fixed">
  <i class="fa-search ins-search-icon hide" name="search"></i>
  <div class="ins-search">
    <div class="ins-search-mask"></div>
    <div class="ins-search-container">
        <div class="ins-image-wrapper"></div>
        <div class="ins-bookmark-wrapper">
            <div class="ins-bookmark-container"></div>
        </div>
        <div class="ins-input-wrapper">
            <input type="text" class="ins-search-input" placeholder="想要查找什么..." />
        </div>
        <div class="ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
        <div class="ins-search-close">&times;</div>
    </div>
</div>
<script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '最新文章',
            PAGES: '页面',
            CATEGORIES: '文章分类',
            TAGS: '文章标签',
            UNTITLED: '(未命名)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>

<script src="/js/insight.js"></script>

  <i id="back-to-top" class="iconfont show-super-board-icon icon-super" name="goto top"></i>
  <i id="back-to-top" class="iconfont icon-icon_message" name="goto top"></i>
</div>
  


    
        
<script src="/libs/lightgallery/js/lightgallery.min.js"></script>

        
<script src="/libs/lightgallery/js/lg-thumbnail.min.js"></script>

        
<script src="/libs/lightgallery/js/lg-pager.min.js"></script>

        
<script src="/libs/lightgallery/js/lg-autoplay.min.js"></script>

        
<script src="/libs/lightgallery/js/lg-fullscreen.min.js"></script>

        
<script src="/libs/lightgallery/js/lg-zoom.min.js"></script>

        
<script src="/libs/lightgallery/js/lg-hash.min.js"></script>

        
<script src="/libs/lightgallery/js/lg-share.min.js"></script>

        
<script src="/libs/lightgallery/js/lg-video.min.js"></script>

    


<!-- Custom Scripts -->

<script src="/js/main.js"></script>


</body>
</html>
